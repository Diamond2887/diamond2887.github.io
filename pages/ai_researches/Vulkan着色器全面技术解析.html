<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vulkan着色器全面技术解析</title>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --accent-color: #e74c3c;
            --light-bg: #f8f9fa;
            --dark-bg: #2c3e50;
            --text-color: #333;
            --light-text: #f8f9fa;
            --border-radius: 8px;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--light-bg);
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--secondary-color) 100%);
            color: var(--light-text);
            padding: 40px 30px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--shadow);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .subtitle {
            font-size: 1.2rem;
            text-align: center;
            opacity: 0.9;
            max-width: 800px;
            margin: 0 auto;
        }
        
        h2 {
            color: var(--secondary-color);
            border-bottom: 3px solid var(--primary-color);
            padding-bottom: 10px;
            margin: 35px 0 20px 0;
            font-size: 1.8rem;
        }
        
        h3 {
            color: var(--secondary-color);
            margin: 25px 0 15px 0;
            font-size: 1.4rem;
        }
        
        h4 {
            color: var(--secondary-color);
            margin: 20px 0 10px 0;
            font-size: 1.2rem;
        }
        
        .section-container {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }
        
        .section-container:hover {
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
        }
        
        .highlight {
            background-color: #e8f4fc;
            border-left: 4px solid var(--primary-color);
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }
        
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 18px;
            border-radius: var(--border-radius);
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            line-height: 1.5;
            font-size: 0.95rem;
        }
        
        .code-block code {
            display: block;
            white-space: pre;
            tab-size: 4;
        }
        
        .shader-stage {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 25px 0;
        }
        
        .stage-card {
            flex: 1;
            min-width: 250px;
            background-color: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--shadow);
            border-top: 4px solid var(--primary-color);
        }
        
        .stage-card h4 {
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .stage-card h4::before {
            content: "●";
            color: var(--accent-color);
            font-size: 1.5rem;
        }
        
        .optimization-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .optimization-card {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--shadow);
            border-left: 4px solid var(--accent-color);
        }
        
        .pipeline-visual {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 30px 0;
            padding: 20px;
            background-color: #f0f7ff;
            border-radius: var(--border-radius);
        }
        
        .pipeline-steps {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            width: 100%;
        }
        
        .pipeline-step {
            background-color: var(--primary-color);
            color: white;
            padding: 12px 20px;
            border-radius: var(--border-radius);
            min-width: 180px;
            text-align: center;
            font-weight: bold;
            position: relative;
        }
        
        .pipeline-step::after {
            content: "→";
            position: absolute;
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--secondary-color);
            font-weight: bold;
        }
        
        .pipeline-step:last-child::after {
            display: none;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: var(--shadow);
            border-radius: var(--border-radius);
            overflow: hidden;
        }
        
        .comparison-table th {
            background-color: var(--secondary-color);
            color: white;
            padding: 15px;
            text-align: left;
        }
        
        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #eee;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .comparison-table tr:hover {
            background-color: #f0f7ff;
        }
        
        .note {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }
        
        .key-point {
            background-color: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }
        
        .accordion {
            margin: 20px 0;
        }
        
        .accordion-item {
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            overflow: hidden;
        }
        
        .accordion-header {
            background-color: #f5f5f5;
            padding: 15px 20px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .accordion-header:hover {
            background-color: #e9e9e9;
        }
        
        .accordion-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .accordion-content.active {
            padding: 20px;
            max-height: 1000px;
        }
        
        .accordion-toggle {
            font-size: 1.2rem;
            transition: transform 0.3s;
        }
        
        .accordion-header.active .accordion-toggle {
            transform: rotate(45deg);
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #666;
            border-top: 1px solid #ddd;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .shader-stage, .optimization-grid {
                flex-direction: column;
                grid-template-columns: 1fr;
            }
            
            .pipeline-steps {
                flex-direction: column;
                align-items: center;
            }
            
            .pipeline-step {
                width: 100%;
                max-width: 300px;
            }
            
            .pipeline-step::after {
                content: "↓";
                right: 50%;
                transform: translateX(50%);
                top: auto;
                bottom: -15px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Vulkan着色器全面技术解析</h1>
        <p class="subtitle">从理论架构到实践优化，深入探索Vulkan着色器管线的核心技术</p>
    </header>
    
    <div class="section-container">
        <h2>引言</h2>
        <p>Vulkan作为新一代的图形API，其核心优势在于提供了<strong>底层直接控制能力</strong>和<strong>高性能渲染管线</strong>。在Vulkan的渲染架构中，着色器管线是可编程渲染管线的核心组成部分。</p>
        
        <div class="highlight">
            <p>现代3D游戏和图形应用中，<strong>着色器的数量可达数万个</strong>，传统的API设计已无法满足如此大规模的处理需求。Vulkan通过给予开发者对GPU处理过程的直接控制权，实现了更高效的并行处理和内存管理。</p>
        </div>
        
        <p>与传统API的"黑盒"处理方式不同，Vulkan允许开发者精确控制着色器的执行顺序和数据流动，这种细粒度的控制能力为性能优化提供了巨大空间。</p>
    </div>
    
    <div class="section-container">
        <h2>一、Vulkan着色器管线架构与执行流程</h2>
        
        <h3>1.1 着色器管线整体架构</h3>
        <p>Vulkan着色器管线是一个<strong>有序的处理流程</strong>，从顶点数据输入到最终像素输出，每个阶段都有其特定的功能定位。</p>
        
        <div class="pipeline-visual">
            <h4>Vulkan着色器管线执行流程</h4>
            <div class="pipeline-steps">
                <div class="pipeline-step">顶点着色器</div>
                <div class="pipeline-step">细分控制着色器</div>
                <div class="pipeline-step">细分求值着色器</div>
                <div class="pipeline-step">几何着色器</div>
                <div class="pipeline-step">片段着色器</div>
            </div>
            <p>预光栅化阶段 → 光栅化 → 光栅化后阶段</p>
        </div>
        
        <div class="note">
            <p><strong>注意：</strong>在Vulkan中，<strong>管线对象是不可变的</strong>，一旦创建就不能修改。这意味着如果需要不同的渲染配置，必须创建新的管线对象。这种设计虽然增加了创建管线的开销，但能够带来显著的性能优势。</p>
        </div>
        
        <h3>1.2 着色器阶段执行顺序</h3>
        <p>Vulkan着色器管线的执行顺序具有严格的定义：<strong>顶点着色器</strong>作为管线的第一个阶段，是必须包含的；随后可以启用细分着色器；接着是可选的几何着色器；最后是片段着色器。</p>
        
        <div class="key-point">
            <p><strong>关键点：</strong>在管线的执行过程中，<strong>一个阶段的输出成为下一个阶段的输入</strong>。这种数据传递机制确保了整个管线的连贯性。并非所有的渲染都需要使用所有的着色器阶段。</p>
        </div>
    </div>
    
    <div class="section-container">
        <h2>二、各着色器阶段详细功能解析</h2>
        
        <div class="shader-stage">
            <div class="stage-card">
                <h4>顶点着色器</h4>
                <p>顶点着色器是Vulkan着色器管线的<strong>起始阶段</strong>，对输入的顶点及其相关数据进行操作，每次处理一个顶点。</p>
                <p><strong>主要功能：</strong></p>
                <ul>
                    <li>坐标变换（模型→世界→观察→裁剪空间）</li>
                    <li>法线变换、纹理坐标生成</li>
                    <li>传递顶点属性到后续阶段</li>
                </ul>
            </div>
            
            <div class="stage-card">
                <h4>细分着色器</h4>
                <p>细分着色器是Vulkan着色器管线中的<strong>可选阶段</strong>，由细分控制着色器和细分求值着色器组成。</p>
                <p><strong>主要功能：</strong></p>
                <ul>
                    <li>基于特定规则细分几何体</li>
                    <li>提高网格质量</li>
                    <li>动态调整细分级别</li>
                </ul>
            </div>
            
            <div class="stage-card">
                <h4>几何着色器</h4>
                <p>几何着色器处理经过顶点处理后装配的图元数据，并输出形成输出图元的顶点序列。</p>
                <p><strong>主要功能：</strong></p>
                <ul>
                    <li>生成或销毁图元</li>
                    <li>几何形状的程序化生成</li>
                    <li>LOD动态调整</li>
                </ul>
            </div>
            
            <div class="stage-card">
                <h4>片段着色器</h4>
                <p>片段着色器是Vulkan着色器管线的<strong>最后一个可编程阶段</strong>，对光栅化生成的每个片段执行。</p>
                <p><strong>主要功能：</strong></p>
                <ul>
                    <li>颜色计算（光照、纹理采样）</li>
                    <li>透明度处理（alpha测试和混合）</li>
                    <li>决定最终像素显示效果</li>
                </ul>
            </div>
        </div>
    </div>
    
    <div class="section-container">
        <h2>三、Vulkan着色器编程实践示例</h2>
        
        <h3>3.1 着色器代码编写基础</h3>
        <p>在Vulkan中，着色器使用<strong>GLSL（OpenGL Shading Language）</strong>编写，然后编译为<strong>SPIR-V</strong>格式。</p>
        
        <div class="accordion">
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    顶点着色器示例
                    <span class="accordion-toggle">+</span>
                </div>
                <div class="accordion-content">
                    <div class="code-block">
<code>#version 450

// 输入顶点位置，位置索引为0
layout(location = 0) in vec4 position;
// 输入顶点颜色，位置索引为1
layout(location = 1) in vec3 inColor;

// 统一缓冲区对象，绑定点0
layout(binding = 0) uniform UniformBufferObject {
    mat4 model;      // 模型矩阵
    mat4 view;       // 视图矩阵
    mat4 proj;       // 投影矩阵
} ubo;

// 输出到片段着色器的颜色，位置索引为0
layout(location = 0) out vec3 fragColor;

void main() {
    // 执行MVP变换
    gl_Position = ubo.proj * ubo.view * ubo.model * position;
    // 传递颜色属性
    fragColor = inColor;
}</code>
                    </div>
                </div>
            </div>
            
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    片段着色器示例
                    <span class="accordion-toggle">+</span>
                </div>
                <div class="accordion-content">
                    <div class="code-block">
<code>#version 450

// 从顶点着色器输入的颜色，位置索引为0
layout(location = 0) in vec3 fragColor;

// 输出颜色，位置索引为0
layout(location = 0) out vec4 outColor;

void main() {
    // 直接使用插值后的颜色
    outColor = vec4(fragColor, 1.0);
}</code>
                    </div>
                </div>
            </div>
            
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    细分着色器示例
                    <span class="accordion-toggle">+</span>
                </div>
                <div class="accordion-content">
                    <p><strong>细分控制着色器：</strong></p>
                    <div class="code-block">
<code>#version 450
layout(vertices = 3) out;

void main() {
    if (gl_InvocationID == 0) {
        gl_TessLevelInner[0] = 16.0;
        gl_TessLevelOuter[0] = 16.0;
        gl_TessLevelOuter[1] = 16.0;
        gl_TessLevelOuter[2] = 16.0;
    }
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
}</code>
                    </div>
                    
                    <p><strong>细分求值着色器：</strong></p>
                    <div class="code-block">
<code>#version 450
layout(triangles, equal_spacing, cw) in;

void main() {
    vec4 pos = gl_TessCoord.x * gl_in[0].gl_Position + 
               gl_TessCoord.y * gl_in[1].gl_Position + 
               gl_TessCoord.z * gl_in[2].gl_Position;
    gl_Position = pos;
}</code>
                    </div>
                </div>
            </div>
        </div>
        
        <h3>3.4 完整管线创建流程</h3>
        <p>在C++代码中创建包含上述着色器的图形管线，需要以下步骤：</p>
        
        <div class="highlight">
            <p>1. 创建着色器模块（读取SPIR-V文件并创建VkShaderModule对象）</p>
            <p>2. 定义着色器阶段信息（指定阶段类型、着色器模块和入口函数名）</p>
            <p>3. 配置顶点输入状态（顶点绑定描述和顶点属性描述）</p>
            <p>4. 创建完整的图形管线</p>
        </div>
    </div>
    
    <div class="section-container">
        <h2>四、性能优化策略与最佳实践</h2>
        
        <h3>4.1 着色器代码优化原则</h3>
        <p>Vulkan着色器的性能优化需要从多个层面进行考虑。首先是<strong>着色器代码本身的优化</strong>。</p>
        
        <div class="optimization-grid">
            <div class="optimization-card">
                <h4>避免重复计算</h4>
                <p>将常用的计算结果存储在临时变量中，避免重复计算相同的值。</p>
            </div>
            
            <div class="optimization-card">
                <h4>简化数学运算</h4>
                <p>使用更简单的数学表达式替代复杂的计算，例如用乘法替代除法。</p>
            </div>
            
            <div class="optimization-card">
                <h4>合理使用条件分支</h4>
                <p>GPU的并行执行模型使得条件分支的代价很高，应该尽量避免或简化。</p>
            </div>
            
            <div class="optimization-card">
                <h4>优化内存访问模式</h4>
                <p>确保内存访问是对齐的和连续的，避免随机访问。</p>
            </div>
        </div>
        
        <h3>4.2 管线配置优化策略</h3>
        <p><strong>管线状态优化</strong>是提高性能的关键策略，包括最小化管线状态变化、描述符集变化和动态状态变化。</p>
        
        <div class="note">
            <p><strong>批次绘制：</strong>通过将相似的绘制调用分组并在单个批次中提交，可以显著减少开销并提高性能。</p>
        </div>
        
        <h3>4.3 内存管理与缓存优化</h3>
        <p>Vulkan着色器的内存管理对性能有重要影响。<strong>始终启用着色器缓存</strong>是一个基本的优化原则。</p>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>优化技术</th>
                    <th>性能提升</th>
                    <th>功耗降低</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>硬件加速YCbCr转换</td>
                    <td>35-50% 帧率提升</td>
                    <td>15-20% 功耗降低</td>
                </tr>
                <tr>
                    <td>着色器优化</td>
                    <td>15-25% 帧率提升</td>
                    <td>5-10% 功耗降低</td>
                </tr>
                <tr>
                    <td>管线缓存使用</td>
                    <td>显著减少编译时间</td>
                    <td>减少CPU负载</td>
                </tr>
            </tbody>
        </table>
        
        <h3>4.4 并行处理与异步优化</h3>
        <p>Vulkan的一个重要优势是支持<strong>多队列并行处理</strong>。当存在片段到计算工作负载时，应该使用多个Vulkan队列。</p>
        
        <div class="key-point">
            <p><strong>异步计算：</strong>可以使用异步计算来饱和GPU，让计算着色器和图形着色器同时工作。但计算着色器和图形着色器之间的数据共享需要通过适当的同步机制来保证数据一致性。</p>
        </div>
    </div>
    
    <div class="section-container">
        <h2>五、着色器间数据传递与协调机制</h2>
        
        <h3>5.1 数据传递基础机制</h3>
        <p>Vulkan着色器阶段之间的数据传递通过<strong>输入输出变量</strong>实现，所有着色器阶段都可以通过输入输出变量相互传递数据。</p>
        
        <div class="highlight">
            <p>数据传递的基本规则是：<strong>一个阶段的输出成为下一个阶段的输入</strong>。例如，顶点着色器的输出变量会被传递给细分着色器（如果启用）或几何着色器，最终传递给片段着色器。</p>
        </div>
        
        <h3>5.2 接口匹配机制</h3>
        <p>Vulkan着色器间的数据传递通过<strong>Location修饰符</strong>和<strong>类型匹配</strong>来实现。</p>
        
        <div class="accordion">
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    接口匹配规则
                    <span class="accordion-toggle">+</span>
                </div>
                <div class="accordion-content">
                    <p><strong>1. 用户自定义输出变量</strong>被认为与下一个阶段的输入变量匹配，当且仅当两个变量被相同的Location和Component描述符修饰，且类型匹配。</p>
                    <p><strong>2. 接口块匹配：</strong>当管线内有多个阶段时，一个阶段的输出和下一个阶段的输入形成接口。</p>
                    <p><strong>3. 数组处理：</strong>细分控制着色器逐顶点输出变量与块，以及细分控制、细分求值、几何着色器的逐顶点输入变量与块必须声明为数组。</p>
                </div>
            </div>
        </div>
        
        <h3>5.4 数据一致性保证机制</h3>
        <p>Vulkan通过多种机制保证着色器间数据的一致性，其中最重要的是<strong>管线屏障（Pipeline Barrier）</strong>。</p>
        
        <div class="note">
            <p><strong>管线屏障的工作原理：</strong>管线屏障提供命令缓冲区内的同步控制，可用于控制单个队列内的资源访问。可以同时同步多个资源，只需在屏障调用中包含多个内存屏障。</p>
        </div>
    </div>
    
    <div class="section-container">
        <h2>六、高级特性与发展趋势</h2>
        
        <h3>6.1 现代着色器技术</h3>
        <p>Vulkan正在不断发展，引入了许多新的着色器技术。其中最值得关注的是<strong>网格着色器（Mesh Shader）</strong>和<strong>工作图（Work Graph）</strong>技术。</p>
        
        <div class="key-point">
            <p>早期测试显示，网格着色器和工作图技术可以在复杂场景中<strong>减少90%或更多的绘制调用</strong>。这意味着游戏可以渲染更多的对象而不会影响性能。</p>
        </div>
        
        <h3>6.2 混合渲染技术</h3>
        <p>现代游戏越来越多地使用<strong>混合渲染技术</strong>，即在需要的地方使用光线追踪效果，其余部分使用传统渲染。</p>
        
        <h3>6.3 性能分析与调试工具</h3>
        <p>为了更好地优化Vulkan着色器，开发者需要使用专业的性能分析工具：</p>
        <ul>
            <li><strong>GPU-Z：</strong>用于监控GPU使用情况</li>
            <li><strong>RenderDoc：</strong>用于高级分析和调试</li>
            <li><strong>Vulkan性能查询：</strong>Vulkan内置的性能查询功能</li>
        </ul>
        
        <h3>6.5 未来发展方向</h3>
        <p>展望未来，Vulkan着色器技术将继续发展：</p>
        <ol>
            <li><strong>更高效的着色器编译：</strong>通过机器学习和人工智能技术生成更优化的代码</li>
            <li><strong>自适应渲染技术：</strong>根据硬件能力和场景复杂度自动调整渲染策略</li>
            <li><strong>统一的着色器模型：</strong>减少不同着色器阶段之间的差异</li>
            <li><strong>与AI/ML的集成：</strong>实现更智能的渲染效果</li>
        </ol>
    </div>
    
    <div class="section-container">
        <h2>结论</h2>
        <p>Vulkan着色器管线作为现代图形渲染的核心技术，提供了从顶点处理到像素着色的完整可编程能力。</p>
        
        <div class="highlight">
            <p><strong>理论架构层面：</strong>Vulkan着色器管线采用了清晰的阶段化设计，管线的不可变性设计虽然增加了创建开销，但能够带来显著的运行时性能优势。</p>
            <p><strong>功能特性方面：</strong>每个着色器阶段都有其独特的功能定位，这些阶段的协同工作实现了从3D几何到2D图像的完整转换。</p>
            <p><strong>实践应用角度：</strong>通过合理的管线配置、高效的内存管理和优化的着色器代码，可以实现高性能的图形渲染。</p>
            <p><strong>优化策略方面：</strong>性能优化需要从多个层面进行，关键是要根据具体场景选择合适的优化策略。</p>
            <p><strong>数据协调机制：</strong>通过合理使用管线屏障、内存屏障和同步对象，可以确保不同着色器阶段之间的数据一致性。</p>
        </div>
        
        <p>对于开发者而言，深入理解Vulkan着色器的工作原理，熟练掌握编程技巧，并持续关注技术发展趋势，将是在现代图形编程领域保持竞争力的关键。</p>
    </div>
    
    <footer>
        <p>Vulkan着色器全面技术解析 | 内容基于技术文档整理</p>
        <p>© 2023 图形技术研究</p>
    </footer>

    <script>
        // 手风琴折叠功能
        function toggleAccordion(header) {
            const content = header.nextElementSibling;
            const isActive = content.classList.contains('active');
            
            // 关闭所有其他项
            document.querySelectorAll('.accordion-content').forEach(item => {
                item.classList.remove('active');
            });
            
            document.querySelectorAll('.accordion-header').forEach(item => {
                item.classList.remove('active');
            });
            
            // 如果当前项未激活，则激活它
            if (!isActive) {
                content.classList.add('active');
                header.classList.add('active');
            }
        }
        
        // 页面加载时默认打开第一个手风琴项
        document.addEventListener('DOMContentLoaded', function() {
            const firstAccordion = document.querySelector('.accordion-header');
            if (firstAccordion) {
                firstAccordion.classList.add('active');
                firstAccordion.nextElementSibling.classList.add('active');
            }
        });
    </script>
</body>
</html>