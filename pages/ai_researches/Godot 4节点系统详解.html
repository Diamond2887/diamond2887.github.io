<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Godot 4节点系统详解</title>
    <style>
        :root {
            --primary-color: #478cbf;
            --secondary-color: #3a6a8c;
            --accent-color: #f0f8ff;
            --text-color: #333;
            --light-gray: #f5f5f5;
            --border-color: #ddd;
            --shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--light-gray);
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .content {
            padding: 20px;
        }
        
        .chapter {
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .chapter-header {
            background-color: var(--accent-color);
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.3s;
        }
        
        .chapter-header:hover {
            background-color: #e0efff;
        }
        
        .chapter-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .toggle-icon {
            font-size: 1.2rem;
            transition: transform 0.3s;
        }
        
        .chapter-content {
            padding: 20px;
            display: none;
        }
        
        .chapter.active .chapter-content {
            display: block;
        }
        
        .chapter.active .toggle-icon {
            transform: rotate(90deg);
        }
        
        h2 {
            color: var(--secondary-color);
            margin: 20px 0 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        
        h3 {
            color: var(--primary-color);
            margin: 15px 0 10px;
        }
        
        p {
            margin-bottom: 15px;
        }
        
        ul, ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 5px;
        }
        
        code {
            background-color: var(--light-gray);
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
        }
        
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            line-height: 1.4;
        }
        
        .diagram {
            background-color: white;
            border: 1px solid var(--border-color);
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
            text-align: center;
        }
        
        .node-hierarchy {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin: 20px 0;
        }
        
        .node {
            background-color: var(--primary-color);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            margin: 5px;
            text-align: center;
            min-width: 120px;
        }
        
        .node-child {
            background-color: var(--secondary-color);
        }
        
        .node-leaf {
            background-color: #5a9bc7;
        }
        
        .connector {
            width: 2px;
            height: 20px;
            background-color: var(--border-color);
            margin: 0 auto;
        }
        
        .table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        .table th, .table td {
            border: 1px solid var(--border-color);
            padding: 10px;
            text-align: left;
        }
        
        .table th {
            background-color: var(--accent-color);
        }
        
        .table tr:nth-child(even) {
            background-color: var(--light-gray);
        }
        
        .note {
            background-color: #fff9e6;
            border-left: 4px solid #ffcc00;
            padding: 10px 15px;
            margin: 15px 0;
        }
        
        .warning {
            background-color: #ffe6e6;
            border-left: 4px solid #ff3333;
            padding: 10px 15px;
            margin: 15px 0;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 30px;
            color: #666;
            border-top: 1px solid var(--border-color);
        }
        
        @media (max-width: 768px) {
            .node-hierarchy {
                flex-direction: column;
            }
            
            .connector {
                width: 20px;
                height: 2px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Godot 4节点系统详解</h1>
            <p class="subtitle">从基础概念到高级特性，全面解析Godot 4节点系统</p>
        </header>
        
        <div class="content">
            <div class="chapter active">
                <div class="chapter-header">
                    <div class="chapter-title">一、Node基础概念与核心机制</div>
                    <div class="toggle-icon">▶</div>
                </div>
                <div class="chapter-content">
                    <h2>1.1 Node类的本质与作用</h2>
                    <p><strong>Node是Godot引擎中所有场景对象的基类</strong>，它就像是一个"万能容器"，其他节点都继承自它，可以用来组织和管理游戏中的各种元素。</p>
                    
                    <div class="diagram">
                        <div class="node-hierarchy">
                            <div class="node">Node</div>
                            <div class="connector"></div>
                            <div class="node node-child">Node2D</div>
                            <div class="connector"></div>
                            <div class="node node-leaf">Sprite2D</div>
                        </div>
                        <p>节点继承关系示例</p>
                    </div>
                    
                    <p>在实际应用中，Node类的核心作用体现在以下几个方面：</p>
                    <ul>
                        <li><strong>层次化管理</strong>：一个给定的节点可以包含任意数量的节点作为子节点，但要求所有的兄弟节点（即该节点的直接子节点）必须有唯一的名字。</li>
                        <li><strong>生命周期管理</strong>：Node类提供了完整的生命周期回调机制。</li>
                        <li><strong>属性与方法体系</strong>：Node类定义了一系列核心属性和方法。</li>
                    </ul>
                    
                    <h2>1.2 Node生命周期详解</h2>
                    <p>理解Node的生命周期是掌握Godot 4节点系统的关键。节点的生命周期从创建到销毁经历了多个阶段：</p>
                    
                    <table class="table">
                        <tr>
                            <th>阶段</th>
                            <th>方法</th>
                            <th>描述</th>
                        </tr>
                        <tr>
                            <td>创建阶段</td>
                            <td>_init()</td>
                            <td>节点创建时执行，用于初始化基本属性</td>
                        </tr>
                        <tr>
                            <td>进入树阶段</td>
                            <td>_enter_tree()</td>
                            <td>节点被添加到场景树时调用</td>
                        </tr>
                        <tr>
                            <td>准备阶段</td>
                            <td>_ready()</td>
                            <td>节点及其所有子节点都进入场景树后调用</td>
                        </tr>
                        <tr>
                            <td>处理阶段</td>
                            <td>_process()/_physics_process()</td>
                            <td>分别在渲染帧和物理帧被调用</td>
                        </tr>
                        <tr>
                            <td>退出树阶段</td>
                            <td>_exit_tree()</td>
                            <td>节点从树中移除之前调用</td>
                        </tr>
                    </table>
                    
                    <h2>1.3 Node的核心属性与方法</h2>
                    <p>Node类提供了丰富的属性和方法来支持场景树的管理：</p>
                    
                    <h3>核心属性</h3>
                    <ul>
                        <li><strong>name</strong>：节点名称，在同级节点中必须唯一</li>
                        <li><strong>owner</strong>：节点的拥有者，必须是该节点的祖先节点</li>
                        <li><strong>process</strong>：控制是否接收渲染帧通知</li>
                        <li><strong>physics_process</strong>：控制是否接收物理帧通知</li>
                    </ul>
                    
                    <h3>核心方法</h3>
                    <ul>
                        <li><strong>add_child()</strong>：将指定节点添加为子节点</li>
                        <li><strong>get_node()</strong>：通过路径获取节点</li>
                        <li><strong>has_node()</strong>：检查指定路径的节点是否存在</li>
                        <li><strong>queue_free()</strong>：将节点加入队列以在当前帧末尾删除</li>
                    </ul>
                    
                    <h2>1.4 Godot 4中Node的新特性</h2>
                    <p>Godot 4相比Godot 3在Node类上进行了一些重要改进：</p>
                    <ul>
                        <li><strong>命名规范统一</strong>：所有3D节点现在都继承自Node3D</li>
                        <li><strong>功能整合</strong>：一些独立的节点被整合到基础节点中</li>
                        <li><strong>信号系统改进</strong>：信号成为了一级类型，可以直接作为方法参数传递</li>
                    </ul>
                </div>
            </div>
            
            <div class="chapter">
                <div class="chapter-header">
                    <div class="chapter-title">二、PackedScene场景资源管理</div>
                    <div class="toggle-icon">▶</div>
                </div>
                <div class="chapter-content">
                    <h2>2.1 PackedScene的本质与作用</h2>
                    <p><strong>PackedScene是对序列化场景的抽象</strong>，它提供了场景文件的简化接口，允许对场景资源本身进行各种操作和检查。</p>
                    
                    <div class="diagram">
                        <div class="node-hierarchy">
                            <div class="node">场景文件(.tscn)</div>
                            <div class="connector"></div>
                            <div class="node node-child">PackedScene</div>
                            <div class="connector"></div>
                            <div class="node node-leaf">实例化</div>
                        </div>
                        <p>PackedScene与实例化关系</p>
                    </div>
                    
                    <p>PackedScene的主要作用包括：</p>
                    <ul>
                        <li><strong>资源管理</strong>：将复杂的节点树结构序列化并存储为.tscn文件</li>
                        <li><strong>实例化机制</strong>：通过instantiate()方法快速创建场景的实例</li>
                        <li><strong>内存优化</strong>：PackedScene本身不占用运行时内存</li>
                    </ul>
                    
                    <h2>2.2 PackedScene的创建与保存</h2>
                    <p>创建PackedScene有多种方式：</p>
                    
                    <h3>通过编辑器创建</h3>
                    <ol>
                        <li>通过菜单"场景 -> 新建场景"创建新场景</li>
                        <li>在场景面板中选择合适的根节点类型</li>
                        <li>添加所需的子节点并设置属性</li>
                        <li>保存为.tscn文件</li>
                    </ol>
                    
                    <h3>通过代码创建</h3>
                    <pre><code># 创建节点结构
var node = Node2D.new()
var body = RigidBody2D.new()
var collision = CollisionShape2D.new()

# 构建节点层次
body.add_child(collision)
node.add_child(body)

# 设置拥有关系
body.owner = node

# 创建PackedScene并打包
var scene = PackedScene.new()
scene.pack(node)

# 保存到文件
ResourceSaver.save(scene, "res://path/name.tscn")</code></pre>
                    
                    <div class="note">
                        <p><strong>注意：</strong>pack()方法只会打包指定节点及其所有被拥有的子节点。</p>
                    </div>
                    
                    <h2>2.3 PackedScene的实例化机制</h2>
                    <p>实例化PackedScene是使用场景资源的关键操作：</p>
                    
                    <h3>基本实例化方法</h3>
                    <pre><code># 使用preload（编译期已知路径）
var packed_scene = preload("res://scenes/enemy.tscn")
var instance = packed_scene.instantiate()
add_child(instance)

# 使用ResourceLoader（运行期动态路径）
var packed_scene = ResourceLoader.load("res://scenes/enemy.tscn")
if packed_scene is PackedScene:
    var instance = packed_scene.instantiate()
    add_child(instance)</code></pre>
                    
                    <h2>2.4 PackedScene的高级用法</h2>
                    
                    <h3>打包现有节点</h3>
                    <pre><code>func save_current_scene():
    var scene = PackedScene.new()
    # 打包当前节点及其所有子节点
    scene.pack(get_tree().current_scene)
    ResourceSaver.save(scene, "user://saved_scene.tscn")</code></pre>
                    
                    <h3>场景状态管理</h3>
                    <p>get_state()方法返回代表场景文件内容的SceneState对象，can_instantiate()方法检查场景是否可以实例化。</p>
                </div>
            </div>
            
            <div class="chapter">
                <div class="chapter-header">
                    <div class="chapter-title">三、MainLoop与SceneTree的关系解析</div>
                    <div class="toggle-icon">▶</div>
                </div>
                <div class="chapter-content">
                    <h2>3.1 MainLoop：游戏主循环的抽象基类</h2>
                    <p><strong>MainLoop是Godot项目中游戏循环的抽象基类</strong>，它定义了游戏主循环的基本接口。</p>
                    
                    <div class="diagram">
                        <div class="node-hierarchy">
                            <div class="node">MainLoop</div>
                            <div class="connector"></div>
                            <div class="node node-child">SceneTree</div>
                        </div>
                        <p>MainLoop与SceneTree的继承关系</p>
                    </div>
                    
                    <p>MainLoop的核心方法是：</p>
                    <ul>
                        <li><strong>_initialize()</strong>：在初始化时调用一次</li>
                        <li><strong>_process(delta)</strong>：在每个进程帧被调用</li>
                        <li><strong>_physics_process(delta)</strong>：在每个物理帧被调用</li>
                        <li><strong>_finalize()</strong>：在程序退出前调用</li>
                    </ul>
                    
                    <h2>3.2 SceneTree：默认的游戏循环实现</h2>
                    <p><strong>SceneTree继承自MainLoop</strong>，是引擎使用的默认MainLoop实现，负责管理游戏循环。</p>
                    
                    <p>SceneTree的主要功能包括：</p>
                    <ul>
                        <li><strong>节点层次管理</strong>：管理场景中节点的层次结构</li>
                        <li><strong>场景管理</strong>：负责场景的加载、切换和卸载</li>
                        <li><strong>游戏循环控制</strong>：实现完整的游戏循环，包括处理输入、更新逻辑、渲染画面</li>
                    </ul>
                    
                    <h2>3.3 两者的关系与协作机制</h2>
                    <p>MainLoop与SceneTree的关系可以总结为：</p>
                    <ul>
                        <li><strong>继承关系</strong>：SceneTree是MainLoop的子类</li>
                        <li><strong>功能扩展</strong>：SceneTree在MainLoop的基础上对节点管理进行了扩展</li>
                        <li><strong>协作机制</strong>：应用程序启动时，自动创建SceneTree实例并设置为当前的MainLoop</li>
                    </ul>
                    
                    <h2>3.4 特殊情况下的自定义MainLoop</h2>
                    <p>虽然SceneTree是默认的游戏循环实现，但在某些特殊情况下，可能需要创建自定义的MainLoop：</p>
                    
                    <pre><code>class_name CustomMainLoop
extends MainLoop

var time_elapsed = 0

func _initialize():
    print("游戏初始化")

func _process(delta):
    time_elapsed += delta
    print("已运行时间: ", time_elapsed)
    # 返回true结束主循环
    return Input.is_key_pressed(KEY_ESCAPE)

func _physics_process(delta):
    print("物理更新: ", delta)

func _finalize():
    print("游戏结束")</code></pre>
                </div>
            </div>
            
            <div class="chapter">
                <div class="chapter-header">
                    <div class="chapter-title">四、信号与连接机制深度解析</div>
                    <div class="toggle-icon">▶</div>
                </div>
                <div class="chapter-content">
                    <h2>4.1 信号系统的设计理念</h2>
                    <p><strong>信号是Godot内置的委托机制</strong>，它实现了计算机编程中的观察者模式。信号系统的核心设计理念是<strong>解耦</strong>。</p>
                    
                    <div class="diagram">
                        <div class="node-hierarchy">
                            <div class="node">信号发送者</div>
                            <div class="connector"></div>
                            <div class="node node-child">信号</div>
                            <div class="connector"></div>
                            <div class="node node-leaf">信号接收者</div>
                        </div>
                        <p>信号连接的基本模型</p>
                    </div>
                    
                    <p>这种设计带来了以下优势：</p>
                    <ul>
                        <li>减少代码耦合，提高模块独立性</li>
                        <li>使代码更灵活，易于维护和扩展</li>
                        <li>支持一对多的事件通知机制</li>
                    </ul>
                    
                    <h2>4.2 Godot 4信号系统的重大改进</h2>
                    <p>Godot 4对信号系统进行了革命性的改进：</p>
                    
                    <h3>一级类型支持</h3>
                    <p>从Godot 4.0开始，<strong>信号成为了一级类型</strong>。这意味着你可以直接将信号作为方法参数传递。</p>
                    
                    <h3>新的连接语法</h3>
                    <p>在Godot 3中，连接信号需要使用字符串：</p>
                    <pre><code>button.connect("pressed", self, "_on_button_pressed")</code></pre>
                    
                    <p>在Godot 4中，可以直接使用信号对象：</p>
                    <pre><code>button.pressed.connect(self._on_button_pressed)</code></pre>
                    
                    <h2>4.3 信号的定义与发出</h2>
                    
                    <h3>定义信号</h3>
                    <pre><code>extends Node2D

# 无参数信号
signal health_depleted

# 带参数的信号
signal health_changed(old_value, new_value)

var health = 100</code></pre>
                    
                    <h3>发出信号</h3>
                    <pre><code>func take_damage(amount):
    var old_health = health
    health -= amount
    health_changed.emit(old_health, health)
    if health <= 0:
        health_depleted.emit()</code></pre>
                    
                    <h2>4.4 信号连接的多种方式</h2>
                    
                    <h3>通过编辑器连接</h3>
                    <ol>
                        <li>在场景面板中选择发出信号的节点</li>
                        <li>切换到"节点"选项卡，找到要连接的信号</li>
                        <li>双击信号打开连接窗口</li>
                        <li>选择接收信号的目标节点和方法</li>
                        <li>点击"连接"完成设置</li>
                    </ol>
                    
                    <h3>通过代码连接</h3>
                    <pre><code>func _ready():
    # 获取要连接的节点
    var button = get_node("Button")
    var timer = get_node("Timer")
    
    # 连接信号到方法
    button.pressed.connect(self._on_button_pressed)
    
    # 连接带参数的信号
    timer.timeout.connect(self._on_timer_timeout, [42])
    
    # 使用lambda表达式
    button.pressed.connect(lambda: print("按钮被按下"))</code></pre>
                    
                    <h2>4.5 信号连接的高级特性</h2>
                    
                    <h3>信号的断开连接</h3>
                    <pre><code># 断开特定连接
button.pressed.disconnect(self._on_button_pressed)

# 断开所有连接
button.pressed.disconnect_all()</code></pre>
                    
                    <h3>信号的优先级</h3>
                    <pre><code># 设置优先级（数值越大优先级越高）
button.pressed.set_priority(self._on_high_priority, 10)
button.pressed.set_priority(self._on_low_priority, 1)</code></pre>
                    
                    <h2>4.6 内置信号与自定义信号</h2>
                    
                    <h3>内置信号</h3>
                    <p>Godot的各种节点都提供了丰富的内置信号：</p>
                    <ul>
                        <li><strong>Button</strong>：pressed、released、hover_entered、hover_exited等</li>
                        <li><strong>Timer</strong>：timeout</li>
                        <li><strong>Node</strong>：ready、tree_entered、tree_exited等</li>
                    </ul>
                    
                    <h3>自定义信号的最佳实践</h3>
                    <ol>
                        <li>使用过去时态命名信号</li>
                        <li>信号参数应该包含有意义的信息</li>
                        <li>避免在信号处理函数中进行耗时操作</li>
                        <li>合理使用信号优先级</li>
                        <li>及时断开不再需要的信号连接</li>
                    </ol>
                </div>
            </div>
            
            <div class="chapter">
                <div class="chapter-header">
                    <div class="chapter-title">五、节点类型全景图</div>
                    <div class="toggle-icon">▶</div>
                </div>
                <div class="chapter-content">
                    <h2>5.1 基础节点类型</h2>
                    <ul>
                        <li><strong>Node</strong>：所有对象的基类，是一个"万能容器"</li>
                        <li><strong>Node2D</strong>：2D场景中所有节点的基类</li>
                        <li><strong>Node3D</strong>：3D场景中所有节点的基类</li>
                        <li><strong>CanvasItem</strong>：用于2D图形绘制和用户界面元素的基础节点</li>
                    </ul>
                    
                    <h2>5.2 2D游戏节点</h2>
                    
                    <h3>视觉显示节点</h3>
                    <ul>
                        <li><strong>Sprite2D</strong>：用于显示静态2D图片</li>
                        <li><strong>AnimatedSprite2D</strong>：用于播放2D动画序列</li>
                        <li><strong>Line2D</strong>：用于绘制2D线条</li>
                        <li><strong>Polygon2D</strong>：用于绘制2D多边形</li>
                    </ul>
                    
                    <h3>物理相关节点</h3>
                    <ul>
                        <li><strong>RigidBody2D</strong>：刚体2D，具有完整的物理模拟特性</li>
                        <li><strong>StaticBody2D</strong>：静态2D物理体，不会因物理作用而移动</li>
                        <li><strong>CharacterBody2D</strong>：角色2D身体，专门用于角色控制</li>
                        <li><strong>Area2D</strong>：2D区域，用于检测进入/离开的对象</li>
                    </ul>
                    
                    <h2>5.3 3D游戏节点</h2>
                    
                    <h3>3D基础节点</h3>
                    <ul>
                        <li><strong>Node3D</strong>：3D场景的基础节点</li>
                        <li><strong>Camera3D</strong>：3D相机，控制3D场景的视角</li>
                        <li><strong>Light3D</strong>：3D灯光，提供光照效果</li>
                    </ul>
                    
                    <h3>3D几何体节点</h3>
                    <ul>
                        <li><strong>MeshInstance3D</strong>：用于显示3D网格模型</li>
                        <li><strong>MultiMeshInstance3D</strong>：用于高效渲染大量相似的3D网格</li>
                    </ul>
                    
                    <h2>5.4 用户界面节点</h2>
                    
                    <h3>UI基础节点</h3>
                    <ul>
                        <li><strong>Control</strong>：所有UI控件的基类</li>
                        <li><strong>Container</strong>：容器节点，用于容纳其他UI控件</li>
                        <li><strong>Panel</strong>：面板，用于创建具有边框和背景的区域</li>
                    </ul>
                    
                    <h3>按钮类节点</h3>
                    <ul>
                        <li><strong>Button</strong>：基础按钮</li>
                        <li><strong>TextureButton</strong>：使用纹理的按钮</li>
                        <li><strong>CheckBox</strong>：复选框</li>
                    </ul>
                    
                    <h2>5.5 音频与动画节点</h2>
                    
                    <h3>音频节点</h3>
                    <ul>
                        <li><strong>AudioStreamPlayer</strong>：音频流播放器</li>
                        <li><strong>AudioStreamPlayer2D</strong>：2D音频播放器</li>
                        <li><strong>AudioStreamPlayer3D</strong>：3D音频播放器</li>
                    </ul>
                    
                    <h3>动画节点</h3>
                    <ul>
                        <li><strong>AnimationPlayer</strong>：动画播放器</li>
                        <li><strong>AnimationTree</strong>：动画树，用于复杂的动画状态机</li>
                        <li><strong>Bone2D/3D</strong>：骨骼节点，用于骨骼动画</li>
                    </ul>
                    
                    <h2>5.6 特殊功能节点</h2>
                    
                    <h3>定时器节点</h3>
                    <ul>
                        <li><strong>Timer</strong>：定时器，用于在指定时间间隔后触发事件</li>
                        <li><strong>SceneTreeTimer</strong>：场景树定时器，由SceneTree管理</li>
                    </ul>
                    
                    <h3>其他实用节点</h3>
                    <ul>
                        <li><strong>ResourcePreloader</strong>：资源预加载器</li>
                        <li><strong>ShaderMaterial</strong>：着色器材质</li>
                        <li><strong>WorldEnvironment</strong>：世界环境设置</li>
                    </ul>
                </div>
            </div>
            
            <div class="chapter">
                <div class="chapter-header">
                    <div class="chapter-title">六、节点系统高级特性</div>
                    <div class="toggle-icon">▶</div>
                </div>
                <div class="chapter-content">
                    <h2>6.1 节点组（Node Groups）</h2>
                    <p><strong>节点组是一种强大的节点管理机制</strong>，允许你将节点组织成逻辑组，便于批量操作和管理。</p>
                    
                    <h3>创建和管理节点组</h3>
                    <pre><code># 将节点添加到组
add_to_group("enemies")

# 从组中移除节点
remove_from_group("enemies")

# 获取组内所有节点
var enemy_nodes = get_tree().get_nodes_in_group("enemies")

# 向组内所有节点调用方法
get_tree().call_group("enemies", "take_damage", 10)</code></pre>
                    
                    <h3>节点组的优势</h3>
                    <ul>
                        <li><strong>灵活的节点引用</strong>：无论节点在场景树的什么位置，都可以通过组名快速获取</li>
                        <li><strong>批量操作</strong>：可以对组内的所有节点执行相同的操作</li>
                        <li><strong>事件广播</strong>：可以向组内的所有节点发送信号</li>
                    </ul>
                    
                    <h2>6.2 自动加载节点（Autoload）</h2>
                    <p><strong>自动加载节点是Godot提供的单例机制</strong>，允许节点在游戏启动时自动实例化并添加为根节点的直接子节点。</p>
                    
                    <h3>自动加载的特点</h3>
                    <ul>
                        <li><strong>全局可访问</strong>：无需预先加载即可从代码的任何位置访问</li>
                        <li><strong>永不销毁</strong>：切换场景时不会被释放</li>
                        <li><strong>类似单例</strong>：但不是真正的单例模式，可以被实例化多次</li>
                    </ul>
                    
                    <h3>使用自动加载</h3>
                    <pre><code># 访问自动加载的PlayerData
PlayerData.health = 100
PlayerData.score = 0</code></pre>
                    
                    <div class="warning">
                        <p><strong>警告：</strong>运行时绝对不能通过free()或queue_free()移除自动加载，否则引擎会崩溃。</p>
                    </div>
                    
                    <h2>6.3 节点路径（NodePath）系统</h2>
                    <p><strong>NodePath是预解析的场景树路径</strong>，用于在节点层次结构中定位节点或属性。</p>
                    
                    <h3>路径格式</h3>
                    <p>NodePath由以下部分组成：</p>
                    <ul>
                        <li>用斜杠分隔的节点名称列表</li>
                        <li>可选的用冒号分隔的"子名称"列表</li>
                    </ul>
                    
                    <h3>路径操作符</h3>
                    <pre><code># 访问子节点
$Player # 等同于 get_node("Player")
$Player/Weapon # 等同于 get_node("Player/Weapon")

# 访问父节点的兄弟节点
$../Enemy # 父节点的兄弟节点Enemy</code></pre>
                    
                    <h2>6.4 节点激活与禁用机制</h2>
                    <p>节点的激活状态和处理模式提供了灵活的控制机制：</p>
                    
                    <h3>激活状态</h3>
                    <ul>
                        <li><strong>active</strong>：控制节点是否处于激活状态</li>
                        <li>禁用的节点不会接收任何事件和更新</li>
                    </ul>
                    
                    <h3>处理模式</h3>
                    <ul>
                        <li><strong>process</strong>：如果启用，每帧调用_process()</li>
                        <li><strong>physics_process</strong>：如果启用，每物理帧调用_physics_process()</li>
                    </ul>
                    
                    <h2>6.5 节点序列化与反序列化</h2>
                    
                    <h3>节点的序列化</h3>
                    <p>当使用PackedScene保存节点时，会自动进行序列化。序列化过程会保存：</p>
                    <ul>
                        <li>节点的属性值</li>
                        <li>子节点结构</li>
                        <li>信号连接</li>
                        <li>资源引用</li>
                    </ul>
                    
                    <h3>自定义序列化</h3>
                    <pre><code>func _get_property_list():
    var props = super._get_property_list()
    # 添加自定义属性
    props.append({name="custom_property", type=TYPE_STRING, hint=PROPERTY_HINT_NONE})
    return props</code></pre>
                    
                    <h2>6.6 节点引用管理</h2>
                    
                    <h3>强引用与弱引用</h3>
                    <ul>
                        <li><strong>强引用</strong>：通过变量直接引用节点，会阻止节点被释放</li>
                        <li><strong>弱引用</strong>：使用WeakRef类创建弱引用，不会阻止节点释放</li>
                    </ul>
                    
                    <h3>安全的节点访问模式</h3>
                    <pre><code># 安全的节点获取方式
var node = get_node_or_null("Path/To/Node")
if node != null:
    node.do_something()

# 使用断言确保节点存在
assert has_node("Path/To/Node"), "节点不存在"
var node = get_node("Path/To/Node")</code></pre>
                </div>
            </div>
            
            <div class="chapter">
                <div class="chapter-header">
                    <div class="chapter-title">七、节点系统最佳实践与性能优化</div>
                    <div class="toggle-icon">▶</div>
                </div>
                <div class="chapter-content">
                    <h2>7.1 节点层次结构设计原则</h2>
                    
                    <h3>保持合理的层次深度</h3>
                    <ul>
                        <li>避免过深的节点层次（建议不超过5层）</li>
                        <li>合理使用容器节点进行逻辑分组</li>
                        <li>每个节点应承担单一职责</li>
                    </ul>
                    
                    <h3>命名规范</h3>
                    <ul>
                        <li>使用有意义的节点名称</li>
                        <li>遵循项目统一的命名约定</li>
                        <li>避免使用默认名称（如Node、Node2D等）</li>
                    </ul>
                    
                    <h2>7.2 性能优化策略</h2>
                    
                    <h3>减少节点更新开销</h3>
                    <ol>
                        <li><strong>禁用不必要的处理</strong>：
                            <ul>
                                <li>对不需要每帧更新的节点设置process=false</li>
                                <li>使用set_physics_process(false)禁用物理处理</li>
                            </ul>
                        </li>
                        <li><strong>使用节点组进行批量操作</strong>：
                            <pre><code># 向所有敌人造成伤害（高效方法）
get_tree().call_group("enemies", "take_damage", 10)

# 低效方法（遍历所有子节点）
for enemy in get_children():
    if enemy.is_in_group("enemies"):
        enemy.take_damage(10)</code></pre>
                        </li>
                        <li><strong>优化节点树结构</strong>：
                            <ul>
                                <li>避免在循环中调用get_node()</li>
                                <li>在_ready()中缓存常用节点引用</li>
                                <li>使用NodePath进行预解析路径</li>
                            </ul>
                        </li>
                    </ol>
                    
                    <h2>7.3 内存管理优化</h2>
                    
                    <h3>合理使用PackedScene</h3>
                    <ol>
                        <li>将可重用的游戏对象定义为PackedScene</li>
                        <li>使用对象池管理频繁创建和销毁的节点</li>
                        <li>及时释放不再使用的场景实例</li>
                    </ol>
                    
                    <h3>内存泄漏预防</h3>
                    <ol>
                        <li>避免创建不必要的强引用</li>
                        <li>使用弱引用（WeakRef）处理临时引用</li>
                        <li>确保信号连接被正确断开</li>
                        <li>使用queue_free()而不是直接free()</li>
                    </ol>
                    
                    <h2>7.4 代码组织最佳实践</h2>
                    
                    <h3>节点脚本的职责分离</h3>
                    <ul>
                        <li>一个节点只负责一项主要功能</li>
                        <li>将通用功能封装成工具类</li>
                        <li>使用接口和抽象类实现多态行为</li>
                    </ul>
                    
                    <h3>信号使用规范</h3>
                    <ol>
                        <li>使用描述性的信号名称</li>
                        <li>信号参数应包含必要的信息</li>
                        <li>避免在信号处理函数中进行复杂计算</li>
                        <li>及时清理不再需要的信号连接</li>
                    </ol>
                    
                    <h2>7.5 常见问题与解决方案</h2>
                    
                    <h3>节点未找到错误</h3>
                    <ul>
                        <li>检查节点路径是否正确</li>
                        <li>确保节点确实存在于场景树中</li>
                        <li>使用has_node()方法进行安全检查</li>
                    </ul>
                    
                    <h3>性能问题</h3>
                    <ul>
                        <li>使用性能分析工具定位问题</li>
                        <li>检查是否有不必要的_process()调用</li>
                        <li>优化节点层次和更新逻辑</li>
                    </ul>
                    
                    <h2>7.6 实战案例：游戏对象管理系统</h2>
                    <pre><code># 游戏对象管理器（自动加载）
extends Node

# 存储所有游戏对象
var game_objects = {}

func register_object(id, object):
    if id not in game_objects:
        game_objects[id] = object
        object.connect("destroyed", self, "_on_object_destroyed", [id])

func unregister_object(id):
    if id in game_objects:
        game_objects.erase(id)

func _on_object_destroyed(id):
    unregister_object(id)

# 使用示例
# 在敌人脚本中
func _ready():
    # 注册到对象管理器
    GameManager.register_object("enemy_" + str(get_instance_id()), self)

func die():
    # 发出销毁信号
    emit_signal("destroyed")
    queue_free()</code></pre>
                </div>
            </div>
            
            <div class="chapter">
                <div class="chapter-header">
                    <div class="chapter-title">结语</div>
                    <div class="toggle-icon">▶</div>
                </div>
                <div class="chapter-content">
                    <p>Godot 4的节点系统是一个功能强大且灵活的架构，它不仅提供了游戏对象的基本管理功能，还通过丰富的节点类型和高级特性支持各种复杂的游戏开发需求。</p>
                    
                    <p>通过本文的详细解析，我们了解到：</p>
                    <ul>
                        <li><strong>Node作为所有场景对象的基类</strong>，提供了完整的生命周期管理和节点操作接口。</li>
                        <li><strong>PackedScene实现了场景资源的高效管理</strong>，通过序列化和实例化机制，使得游戏对象可以被灵活地创建、复用和销毁。</li>
                        <li><strong>MainLoop与SceneTree的关系</strong>体现了Godot的架构设计理念。</li>
                        <li><strong>信号系统的重大改进</strong>不仅简化了代码，还提供了更好的开发体验和类型安全。</li>
                        <li><strong>丰富的节点类型</strong>覆盖了2D/3D游戏开发的各个方面。</li>
                        <li><strong>高级特性如节点组、自动加载、节点路径系统</strong>等，为复杂游戏逻辑的实现提供了强大的工具。</li>
                    </ul>
                    
                    <p>在实际开发中，我们应该遵循以下原则：</p>
                    <ol>
                        <li>保持节点层次结构的清晰和合理</li>
                        <li>合理使用各种节点类型，充分发挥其特性</li>
                        <li>注意性能优化，避免不必要的计算开销</li>
                        <li>遵循良好的代码组织规范，提高可维护性</li>
                    </ol>
                    
                    <p>Godot 4的节点系统还在持续改进和完善中。建议开发者密切关注官方文档的更新，参与社区讨论，不断学习和掌握新的特性。通过不断实践，你将能够熟练运用节点系统构建出高效、稳定、可扩展的游戏。</p>
                </div>
            </div>
        </div>
        
        <footer>
            <p>内容由 AI 生成 | Godot 4节点系统详解</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const chapterHeaders = document.querySelectorAll('.chapter-header');
            
            chapterHeaders.forEach(header => {
                header.addEventListener('click', function() {
                    const chapter = this.parentElement;
                    chapter.classList.toggle('active');
                });
            });
        });
    </script>
</body>
</html>