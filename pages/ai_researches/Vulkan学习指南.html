<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vulkan学习指南</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f7fa;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .description {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .content-section {
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.05);
            margin-bottom: 25px;
            overflow: hidden;
        }
        
        .section-header {
            background-color: #4a6ee0;
            color: white;
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s;
        }
        
        .section-header:hover {
            background-color: #3a5bc7;
        }
        
        .section-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }
        
        .toggle-icon {
            font-size: 1.2rem;
            transition: transform 0.3s;
        }
        
        .section-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease, padding 0.3s ease;
        }
        
        .section-content.expanded {
            padding: 20px;
            max-height: 10000px;
        }
        
        .subsection {
            margin-bottom: 25px;
            border: 1px solid #eaeaea;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .subsection-header {
            background-color: #f0f4ff;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .subsection-header h3 {
            margin: 0;
            font-size: 1.2rem;
            color: #3a5bc7;
        }
        
        .subsection-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease, padding 0.3s ease;
        }
        
        .subsection-content.expanded {
            padding: 15px;
            max-height: 10000px;
        }
        
        p {
            margin-bottom: 15px;
        }
        
        ul, ol {
            margin-bottom: 15px;
            padding-left: 20px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }
        
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        
        th {
            background-color: #f0f4ff;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .note {
            background-color: #e7f3ff;
            border-left: 4px solid #4a90e2;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        .important {
            background-color: #fff8e1;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        
        .code-block {
            position: relative;
        }
        
        .code-header {
            background-color: #3a3a3a;
            color: white;
            padding: 8px 15px;
            border-radius: 8px 8px 0 0;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
        }
        
        .code-lang {
            font-weight: bold;
        }
        
        .code-copy {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #666;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .section-header h2 {
                font-size: 1.3rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Vulkan学习指南</h1>
        <p class="description">基于GLFW与GLM在Windows平台使用MinGW和CMake开发</p>
    </header>

    <div class="content-section">
        <div class="section-header" onclick="toggleSection(this)">
            <h2>一、Vulkan SDK详细安装步骤</h2>
            <span class="toggle-icon">▶</span>
        </div>
        <div class="section-content">
            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>1.1 下载Vulkan SDK</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>Vulkan SDK是开发Vulkan应用程序的核心组件，它包含了头文件、标准验证层、调试工具和Vulkan函数加载器。</p>
                    <div class="note">
                        <p><strong>下载步骤：</strong></p>
                        <ol>
                            <li>打开浏览器访问 LunarG Vulkan SDK下载页面</li>
                            <li>在下载页面找到Windows版本的SDK安装程序</li>
                            <li>点击下载按钮获取安装文件</li>
                        </ol>
                    </div>
                    <p>Vulkan SDK安装包通常命名格式为 <code>VulkanSDK-&lt;版本号&gt;-Installer.exe</code>，例如 <code>VulkanSDK-1.4.321.0-Installer.exe</code>。安装包中同时包含了32位和64位版本的SDK文件。</p>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>1.2 运行安装程序</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>下载完成后，双击运行安装程序，按照以下步骤完成安装：</p>
                    <div class="note">
                        <p><strong>安装过程：</strong></p>
                        <ol>
                            <li>双击下载的安装程序文件，启动安装向导</li>
                            <li>在欢迎界面点击"Next"继续</li>
                            <li>阅读并接受许可协议条款</li>
                            <li>选择安装位置，<strong>默认位置为C:\VulkanSDK\&lt;版本号&gt;\</strong></li>
                            <li>选择需要安装的组件，建议保持默认选择</li>
                            <li>点击"Install"开始安装</li>
                            <li>等待安装过程完成</li>
                            <li>点击"Finish"完成安装</li>
                        </ol>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>1.3 环境变量配置</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>安装完成后，系统会自动设置以下<strong>环境变量</strong>：</p>
                    <ul>
                        <li><strong>VULKAN_SDK</strong>：指向SDK安装目录，如 <code>C:\VulkanSDK\1.4.321.0</code></li>
                        <li><strong>VK_SDK_PATH</strong>：与VULKAN_SDK相同的值，用于兼容旧版本</li>
                    </ul>
                    <div class="note">
                        <p><strong>验证环境变量：</strong></p>
                        <ol>
                            <li>右键点击"此电脑"选择"属性"</li>
                            <li>点击"高级系统设置"</li>
                            <li>在"系统属性"窗口中点击"环境变量"</li>
                            <li>检查系统变量中是否存在VULKAN_SDK和VK_SDK_PATH</li>
                        </ol>
                    </div>
                    <p>如果环境变量没有自动设置，你需要手动添加：</p>
                    <ol>
                        <li>在系统变量中点击"新建"</li>
                        <li>变量名：VULKAN_SDK</li>
                        <li>变量值：SDK安装目录（如C:\VulkanSDK\1.4.321.0）</li>
                        <li>点击"确定"保存</li>
                    </ol>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>1.4 SDK目录结构说明</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>Vulkan SDK的目录结构包含以下重要文件夹：</p>
                    <table>
                        <thead>
                            <tr>
                                <th>文件夹</th>
                                <th>说明</th>
                                <th>包含内容</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Bin</strong></td>
                                <td>可执行文件和动态库</td>
                                <td>vkcube.exe（示例程序）、vulkaninfo.exe（验证工具）、glslangValidator.exe（着色器编译器）、Vulkan加载器和验证层的动态库</td>
                            </tr>
                            <tr>
                                <td><strong>Include</strong></td>
                                <td>头文件</td>
                                <td>Vulkan核心头文件（vulkan.h）、扩展头文件、平台相关头文件</td>
                            </tr>
                            <tr>
                                <td><strong>Lib</strong></td>
                                <td>静态库文件</td>
                                <td>vulkan-1.lib（核心库）、其他平台相关库文件</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>1.5 验证安装成功</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>安装完成后，需要验证Vulkan SDK是否正确安装并能正常工作。</p>
                    <div class="note">
                        <p><strong>验证方法一：运行示例程序</strong></p>
                        <ol>
                            <li>打开文件资源管理器</li>
                            <li>导航到SDK安装目录的Bin文件夹（如C:\VulkanSDK\1.4.321.0\Bin）</li>
                            <li>双击运行<strong>vkcube.exe</strong>程序</li>
                            <li>如果看到一个旋转的立方体窗口，则说明安装成功</li>
                        </ol>
                    </div>
                    <div class="note">
                        <p><strong>验证方法二：使用vulkaninfo命令</strong></p>
                        <ol>
                            <li>打开命令提示符（CMD）</li>
                            <li>输入命令 <strong>vulkaninfo</strong></li>
                            <li>该命令会显示详细的Vulkan安装信息和GPU支持情况</li>
                            <li>如果看到类似以下输出，则说明安装成功：</li>
                        </ol>
                        <pre>Vulkan Instance Version: 1.3.204

Instance Extensions: count = 10</pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>1.6 调试层配置</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>Vulkan的调试层是开发过程中的重要工具，它可以帮助检测API使用错误和性能问题。Vulkan SDK已经包含了预构建的验证层。</p>
                    <div class="note">
                        <p><strong>启用调试层：</strong></p>
                        <ol>
                            <li>打开命令提示符</li>
                            <li>输入以下命令设置环境变量：</li>
                        </ol>
                        <pre>set VK_INSTANCE_LAYERS=VK_LAYER_KHRONOS_validation</pre>
                        <p>这将启用Khronos官方提供的验证层</p>
                    </div>
                    <p><strong>配置调试回调（可选）：</strong>要在应用程序中获取详细的调试信息，需要在代码中设置调试回调函数。这部分内容将在后续的代码示例中详细介绍。</p>
                </div>
            </div>
        </div>
    </div>

    <div class="content-section">
        <div class="section-header" onclick="toggleSection(this)">
            <h2>二、Vulkan对象与基本概念</h2>
            <span class="toggle-icon">▶</span>
        </div>
        <div class="section-content">
            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>2.1 实例（Instance）</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p><strong>实例（VkInstance）</strong>是Vulkan应用程序与系统交互的入口点。它代表了一个Vulkan实现的实例，负责管理全局状态和资源。</p>
                    <p><strong>实例的作用：</strong></p>
                    <ul>
                        <li>作为Vulkan API的全局入口点</li>
                        <li>管理应用程序信息和扩展</li>
                        <li>枚举系统中的物理设备</li>
                        <li>提供全局的错误处理机制</li>
                        <li>管理调试层和验证层</li>
                    </ul>
                    <p><strong>创建实例的步骤：</strong></p>
                    <ol>
                        <li>填写VkApplicationInfo结构，指定应用程序名称、版本等信息</li>
                        <li>填写VkInstanceCreateInfo结构，指定需要的扩展和验证层</li>
                        <li>调用vkCreateInstance函数创建实例</li>
                    </ol>
                    <p>实例就像是一个"总管"，可以设置全局的东西，如验证层和扩展。它是操作系统层面管理所有显卡设备的逻辑功能，可以枚举出所有的显卡（包括集成显卡和独立显卡）。</p>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>2.2 物理设备与逻辑设备</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p><strong>物理设备（VkPhysicalDevice）</strong>代表系统中的实际图形硬件（GPU）。在创建实例后，可以通过枚举获得系统中所有支持Vulkan的物理设备。</p>
                    <p><strong>逻辑设备（VkDevice）</strong>是物理设备的逻辑抽象，代表一个具有独立状态和资源的Vulkan实现实例。逻辑设备必须从物理设备创建，并且不能独立销毁，而是随创建它的实例一起销毁。</p>
                    <p><strong>选择物理设备的考虑因素：</strong></p>
                    <ul>
                        <li>设备的支持特性（如几何着色器、细分着色器等）</li>
                        <li>内存大小和类型</li>
                        <li>队列族的数量和类型</li>
                        <li>扩展支持情况</li>
                        <li>性能指标</li>
                    </ul>
                    <p>创建逻辑设备时需要指定使用的队列族和启用的功能。逻辑设备创建涉及在VkDeviceQueueCreateInfo结构中指定队列族的详细信息。</p>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>2.3 队列族与队列</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>Vulkan设备通过<strong>队列（VkQueue）</strong>提供执行引擎接口。命令被记录到命令缓冲区中，然后提交到队列执行。</p>
                    <p><strong>队列族（Queue Family）的特点：</strong></p>
                    <ul>
                        <li>队列被划分为不同的族，每个族支持一种或多种功能</li>
                        <li>同一族内的队列具有相似特性，并且相互兼容</li>
                        <li>队列族支持的功能包括：图形、计算、视频解码、视频编码、保护内存管理、稀疏内存管理和传输</li>
                    </ul>
                    <p><strong>队列的类型：</strong></p>
                    <ul>
                        <li><strong>图形队列</strong>：用于图形渲染命令</li>
                        <li><strong>计算队列</strong>：用于计算着色器命令</li>
                        <li><strong>传输队列</strong>：用于内存复制和数据传输命令</li>
                    </ul>
                    <p>一个设备可能报告多个相似的队列族，而不是报告一个族的多个成员，这表示这些族的成员虽然具有相似的能力，但彼此之间不直接兼容。</p>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>2.4 表面（Surface）</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p><strong>表面（VkSurfaceKHR）</strong>是窗口系统接口（WSI）的一部分，用于在屏幕上呈现渲染结果。Vulkan API本身是完全平台无关的，因此需要使用标准化的WSI扩展与窗口管理器交互。</p>
                    <p><strong>表面的作用：</strong></p>
                    <ul>
                        <li>作为窗口系统的抽象接口</li>
                        <li>提供呈现目标</li>
                        <li>管理窗口相关的Vulkan资源</li>
                        <li>处理窗口大小变化和重绘事件</li>
                    </ul>
                    <p>创建表面需要平台相关的扩展：</p>
                    <ul>
                        <li>Windows：VK_KHR_win32_surface</li>
                        <li>Linux（X11）：VK_KHR_xlib_surface</li>
                        <li>Linux（Wayland）：VK_KHR_wayland_surface</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>2.5 命令池与命令缓冲区</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p><strong>命令池（VkCommandPool）</strong>用于分配命令缓冲区，它与特定的队列族相关联。命令池提供了一种高效的方式来管理命令缓冲区的分配和释放。</p>
                    <p><strong>命令缓冲区（VkCommandBuffer）</strong>用于记录要执行的命令序列。Vulkan是一个延迟渲染API，大多数操作都需要先记录到命令缓冲区中，然后提交到队列执行。</p>
                    <p><strong>命令缓冲区的类型：</strong></p>
                    <ul>
                        <li><strong>主命令缓冲区</strong>：可以直接提交到队列执行</li>
                        <li><strong>二级命令缓冲区</strong>：用于被主命令缓冲区调用执行</li>
                    </ul>
                    <p><strong>命令缓冲区的使用流程：</strong></p>
                    <ol>
                        <li>从命令池分配命令缓冲区</li>
                        <li>开始记录命令（vkBeginCommandBuffer）</li>
                        <li>记录各种命令（设置状态、绘制、内存操作等）</li>
                        <li>结束记录（vkEndCommandBuffer）</li>
                        <li>提交到队列执行（vkQueueSubmit）</li>
                    </ol>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>2.6 内存管理</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>Vulkan的内存管理是显式的，这意味着应用程序必须负责管理所有设备内存的分配和释放。</p>
                    <p><strong>内存类型：</strong></p>
                    <p>Vulkan内存分为两大类：</p>
                    <ol>
                        <li><strong>主机内存（Host Memory）</strong>：CPU可访问的内存，用于Vulkan实现的非设备可见存储</li>
                        <li><strong>设备内存（Device Memory）</strong>：设备可见的内存，用于图像和缓冲区对象的内容</li>
                    </ol>
                    <p><strong>内存堆和内存类型：</strong></p>
                    <ul>
                        <li><strong>内存堆（Memory Heap）</strong>：代表不同的内存区域，分为设备本地和主机本地</li>
                        <li><strong>内存类型（Memory Type）</strong>：描述内存的属性，如CPU可访问性、缓存行为、设备相关性等</li>
                    </ul>
                    <p><strong>内存分配的步骤：</strong></p>
                    <ol>
                        <li>查询物理设备的内存属性（vkGetPhysicalDeviceMemoryProperties）</li>
                        <li>根据资源需求选择合适的内存类型</li>
                        <li>调用vkAllocateMemory分配内存</li>
                        <li>使用vkBindBufferMemory或vkBindImageMemory将内存绑定到资源</li>
                    </ol>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>2.7 渲染通道与帧缓冲</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p><strong>渲染通道（VkRenderPass）</strong>描述了渲染操作中使用的图像类型、使用方式以及内容处理方式。它定义了渲染过程的完整生命周期，包括：</p>
                    <ul>
                        <li>每个附件的格式和用法</li>
                        <li>子通道（Subpass）的数量和依赖关系</li>
                        <li>加载和存储操作</li>
                        <li>清除值</li>
                    </ul>
                    <p><strong>帧缓冲（VkFramebuffer）</strong>是渲染通道的具体实例，它将渲染通道中定义的抽象附件绑定到实际的图像视图。一个渲染通道可以创建多个帧缓冲，每个帧缓冲可以使用不同的图像。</p>
                    <p><strong>渲染通道和帧缓冲的关系：</strong></p>
                    <ul>
                        <li>渲染通道定义了渲染的"蓝图"</li>
                        <li>帧缓冲提供了实际的"画布"</li>
                        <li>渲染操作必须在渲染通道中执行</li>
                        <li>每个子通道都在特定的帧缓冲上执行</li>
                    </ul>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>2.8 管线对象</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p><strong>管线（VkPipeline）</strong>定义了图形渲染的完整流程，包括固定功能阶段和可编程着色器阶段。Vulkan的管线是高度配置化的，几乎所有状态都需要在创建时指定。</p>
                    <p><strong>管线的类型：</strong></p>
                    <ul>
                        <li><strong>图形管线（Graphics Pipeline）</strong>：用于3D图形渲染</li>
                        <li><strong>计算管线（Compute Pipeline）</strong>：用于通用计算</li>
                        <li><strong>光线追踪管线（Ray Tracing Pipeline）</strong>：用于光线追踪渲染</li>
                    </ul>
                    <p><strong>图形管线的主要组件：</strong></p>
                    <ol>
                        <li><strong>着色器模块（Shader Module）</strong>：包含SPIR-V字节码的着色器程序</li>
                        <li><strong>顶点输入状态</strong>：定义顶点数据的格式和布局</li>
                        <li><strong>输入装配状态</strong>：定义如何将顶点组装成图元</li>
                        <li><strong>光栅化状态</strong>：控制光栅化过程</li>
                        <li><strong>多采样状态</strong>：控制抗锯齿</li>
                        <li><strong>深度模板状态</strong>：控制深度和模板测试</li>
                        <li><strong>颜色混合状态</strong>：控制颜色输出</li>
                    </ol>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>2.9 同步对象</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>Vulkan的同步机制是显式的，需要应用程序负责管理不同队列之间和主机与设备之间的执行顺序。</p>
                    <p><strong>主要同步对象：</strong></p>
                    <ol>
                        <li><strong>信号量（Semaphore）</strong>：用于控制多个队列之间的资源访问
                            <ul>
                                <li>可以在队列提交时等待信号量</li>
                                <li>可以在队列提交时发出信号量</li>
                                <li>支持时间线信号量（Timeline Semaphore）</li>
                            </ul>
                        </li>
                        <li><strong>栅栏（Fence）</strong>：用于主机等待设备完成任务
                            <ul>
                                <li>有两种状态：已发出（signaled）和未发出（unsignaled）</li>
                                <li>可以通过vkWaitForFences等待栅栏</li>
                                <li>可以通过vkResetFences重置栅栏</li>
                            </ul>
                        </li>
                        <li><strong>事件（Event）</strong>：提供细粒度的同步原语
                            <ul>
                                <li>可以在命令缓冲区中发出信号</li>
                                <li>可以在命令缓冲区中等待</li>
                                <li>可以在主机上查询状态</li>
                            </ul>
                        </li>
                    </ol>
                    <p><strong>同步机制的重要性：</strong></p>
                    <p>由于Vulkan的命令执行是异步的，不同队列之间没有隐式的顺序保证，因此必须使用同步对象来确保正确的执行顺序。例如，在呈现图像之前必须确保渲染完成，在开始新的渲染之前必须确保前一帧的资源已经释放。</p>
                </div>
            </div>
        </div>
    </div>

    <div class="content-section">
        <div class="section-header" onclick="toggleSection(this)">
            <h2>三、使用Vulkan绘制三角形</h2>
            <span class="toggle-icon">▶</span>
        </div>
        <div class="section-content">
            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>3.1 环境配置与项目设置</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>在开始编写Vulkan代码之前，需要完成以下环境配置：</p>
                    <p><strong>所需软件：</strong></p>
                    <ol>
                        <li><strong>VS Code</strong>：轻量级跨平台代码编辑器</li>
                        <li><strong>MinGW-w64</strong>：Windows下的GCC编译器</li>
                        <li><strong>CMake</strong>：跨平台构建系统</li>
                        <li><strong>GLFW</strong>：窗口创建和输入处理库</li>
                        <li><strong>GLM</strong>：线性代数库（头文件形式）</li>
                    </ol>
                    <p><strong>项目目录结构：</strong></p>
                    <pre>VulkanTriangle/
├── CMakeLists.txt
├── main.cpp
├── shaders/
│   ├── triangle.vert.spv
│   └── triangle.frag.spv
└── include/
    └── glm/ (GLM头文件)</pre>
                    <p><strong>CMake配置文件（CMakeLists.txt）：</strong></p>
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">CMake</span>
                            <button class="code-copy" onclick="copyCode(this)">复制</button>
                        </div>
                        <pre>cmake_minimum_required(VERSION 3.10)
project(VulkanTriangle)

# 设置C++标准
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 查找Vulkan SDK
find_package(Vulkan REQUIRED)

# 设置包含目录
include_directories(
    ${Vulkan_INCLUDE_DIRS}
    ${CMAKE_CURRENT_SOURCE_DIR}/include
)

# 设置链接库
link_libraries(
    ${Vulkan_LIBRARIES}
    glfw3dll
)

# 添加可执行文件
add_executable(VulkanTriangle main.cpp)

# 设置编译选项
set_target_properties(VulkanTriangle PROPERTIES
    COMPILE_FLAGS "-std=c++17 -Wall -Wextra"
)</pre>
                    </div>
                    <p><strong>VS Code配置：</strong></p>
                    <ol>
                        <li>安装C++扩展</li>
                        <li>创建tasks.json文件用于构建：</li>
                    </ol>
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">JSON</span>
                            <button class="code-copy" onclick="copyCode(this)">复制</button>
                        </div>
                        <pre>{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "build",
            "type": "shell",
            "command": "cmake --build build",
            "group": "build"
        }
    ]
}</pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>3.2 基础初始化</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p>现在开始编写Vulkan应用程序的基础结构：</p>
                    <p><strong>main.cpp基础代码：</strong></p>
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-lang">C++</span>
                            <button class="code-copy" onclick="copyCode(this)">复制</button>
                        </div>
                        <pre>#define GLFW_INCLUDE_VULKAN
#include &lt;GLFW/glfw3.h&gt;

#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;

const uint32_t WIDTH = 800;
const uint32_t HEIGHT = 600;

class HelloTriangleApplication {
public:
    void run() {
        initWindow();
        initVulkan();
        mainLoop();
        cleanup();
    }

private:
    GLFWwindow* window = nullptr;
    VkInstance instance = VK_NULL_HANDLE;
    VkPhysicalDevice physicalDevice = VK_NULL_HANDLE;
    VkDevice device = VK_NULL_HANDLE;
    VkQueue graphicsQueue = VK_NULL_HANDLE;
    VkSurfaceKHR surface = VK_NULL_HANDLE;

    void initWindow() {
        glfwInit();
        glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
        glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

        window = glfwCreateWindow(WIDTH, HEIGHT, "Vulkan Triangle", nullptr, nullptr);
    }

    void initVulkan() {
        createInstance();
        createSurface();
        pickPhysicalDevice();
        createLogicalDevice();
    }

    void mainLoop() {
        while (!glfwWindowShouldClose(window)) {
            glfwPollEvents();
        }
    }

    void cleanup() {
        vkDestroyDevice(device, nullptr);
        vkDestroySurfaceKHR(instance, surface, nullptr);
        vkDestroyInstance(instance, nullptr);
        glfwDestroyWindow(window);
        glfwTerminate();
    }

    void createInstance() {
        VkApplicationInfo appInfo{};
        appInfo.sType = VK_STRUCTURE_TYPE_APPLICATION_INFO;
        appInfo.pApplicationName = "Hello Triangle";
        appInfo.applicationVersion = VK_MAKE_VERSION(1, 0, 0);
        appInfo.pEngineName = "No Engine";
        appInfo.engineVersion = VK_MAKE_VERSION(1, 0, 0);
        appInfo.apiVersion = VK_API_VERSION_1_3;

        VkInstanceCreateInfo createInfo{};
        createInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
        createInfo.pApplicationInfo = &appInfo;

        uint32_t glfwExtensionCount = 0;
        const char** glfwExtensions;
        glfwExtensions = glfwGetRequiredInstanceExtensions(&glfwExtensionCount);

        createInfo.enabledExtensionCount = glfwExtensionCount;
        createInfo.ppEnabledExtensionNames = glfwExtensions;

        createInfo.enabledLayerCount = 0;

        if (vkCreateInstance(&createInfo, nullptr, &instance) != VK_SUCCESS) {
            throw std::runtime_error("failed to create instance!");
        }
    }

    void createSurface() {
        if (glfwCreateWindowSurface(instance, window, nullptr, &surface) != VK_SUCCESS) {
            throw std::runtime_error("failed to create window surface!");
        }
    }

    void pickPhysicalDevice() {
        uint32_t deviceCount = 0;
        vkEnumeratePhysicalDevices(instance, &deviceCount, nullptr);

        if (deviceCount == 0) {
            throw std::runtime_error("failed to find GPUs with Vulkan support!");
        }

        std::vector&lt;VkPhysicalDevice&gt; devices(deviceCount);
        vkEnumeratePhysicalDevices(instance, &deviceCount, devices.data());

        for (const auto& device : devices) {
            if (isDeviceSuitable(device)) {
                physicalDevice = device;
                break;
            }
        }

        if (physicalDevice == VK_NULL_HANDLE) {
            throw std::runtime_error("failed to find a suitable GPU!");
        }
    }

    bool isDeviceSuitable(VkPhysicalDevice device) {
        VkPhysicalDeviceProperties deviceProperties;
        VkPhysicalDeviceFeatures deviceFeatures;
        vkGetPhysicalDeviceProperties(device, &deviceProperties);
        vkGetPhysicalDeviceFeatures(device, &deviceFeatures);

        // 检查设备是否支持基本图形功能
        return deviceProperties.deviceType == VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU &&
               deviceFeatures.geometryShader;
    }

    void createLogicalDevice() {
        QueueFamilyIndices indices = findQueueFamilies(physicalDevice);

        std::vector&lt;VkDeviceQueueCreateInfo&gt; queueCreateInfos;
        std::set&lt;uint32_t&gt; uniqueQueueFamilies = {indices.graphicsFamily.value(), indices.presentFamily.value()};

        float queuePriority = 1.0f;
        for (uint32_t queueFamily : uniqueQueueFamilies) {
            VkDeviceQueueCreateInfo queueCreateInfo{};
            queueCreateInfo.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
            queueCreateInfo.queueFamilyIndex = queueFamily;
            queueCreateInfo.queueCount = 1;
            queueCreateInfo.pQueuePriorities = &queuePriority;
            queueCreateInfos.push_back(queueCreateInfo);
        }

        VkPhysicalDeviceFeatures deviceFeatures{};
        deviceFeatures.geometryShader = VK_TRUE;

        VkDeviceCreateInfo createInfo{};
        createInfo.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
        createInfo.queueCreateInfoCount = static_cast&lt;uint32_t&gt;(queueCreateInfos.size());
        createInfo.pQueueCreateInfos = queueCreateInfos.data();
        createInfo.pEnabledFeatures = &deviceFeatures;

        createInfo.enabledExtensionCount = 0;

        if (vkCreateDevice(physicalDevice, &createInfo, nullptr, &device) != VK_SUCCESS) {
            throw std::runtime_error("failed to create logical device!");
        }

        vkGetDeviceQueue(device, indices.graphicsFamily.value(), 0, &graphicsQueue);
    }

    struct QueueFamilyIndices {
        std::optional&lt;uint32_t&gt; graphicsFamily;
        std::optional&lt;uint32_t&gt; presentFamily;

        bool isComplete() {
            return graphicsFamily.has_value() && presentFamily.has_value();
        }
    };

    QueueFamilyIndices findQueueFamilies(VkPhysicalDevice device) {
        QueueFamilyIndices indices;

        uint32_t queueFamilyCount = 0;
        vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, nullptr);

        std::vector&lt;VkQueueFamilyProperties&gt; queueFamilies(queueFamilyCount);
        vkGetPhysicalDeviceQueueFamilyProperties(device, &queueFamilyCount, queueFamilies.data());

        int i = 0;
        for (const auto& queueFamily : queueFamilies) {
            if (queueFamily.queueFlags & VK_QUEUE_GRAPHICS_BIT) {
                indices.graphicsFamily = i;
            }

            VkBool32 presentSupport = false;
            vkGetPhysicalDeviceSurfaceSupportKHR(device, i, surface, &presentSupport);

            if (presentSupport) {
                indices.presentFamily = i;
            }

            if (indices.isComplete()) {
                break;
            }

            i++;
        }

        return indices;
    }
};

int main() {
    HelloTriangleApplication app;

    try {
        app.run();
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}</pre>
                    </div>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>3.11 编译和运行</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p><strong>编译步骤：</strong></p>
                    <ol>
                        <li>创建build目录：<code>mkdir build</code></li>
                        <li>进入build目录：<code>cd build</code></li>
                        <li>运行CMake：<code>cmake ..</code></li>
                        <li>编译项目：<code>cmake --build .</code></li>
                    </ol>
                    <p><strong>运行程序：</strong></p>
                    <ol>
                        <li>在build目录中找到生成的可执行文件</li>
                        <li>双击运行或在命令行中执行</li>
                        <li>应该看到一个窗口中显示一个彩色三角形</li>
                    </ol>
                </div>
            </div>

            <div class="subsection">
                <div class="subsection-header" onclick="toggleSubsection(this)">
                    <h3>3.12 代码说明</h3>
                    <span class="toggle-icon">▶</span>
                </div>
                <div class="subsection-content">
                    <p><strong>关键代码分析：</strong></p>
                    <ol>
                        <li><strong>顶点着色器</strong>：定义了三角形三个顶点的位置和颜色，使用内置变量gl_VertexIndex来选择不同的顶点数据。</li>
                        <li><strong>片段着色器</strong>：接收顶点着色器传递的颜色值，并输出到最终的颜色缓冲区。</li>
                        <li><strong>渲染通道</strong>：定义了颜色附件的格式和使用方式，设置了清除值为黑色。</li>
                        <li><strong>命令缓冲区录制</strong>：在渲染通道中绑定管线并执行绘制命令，绘制3个顶点组成的三角形。</li>
                        <li><strong>同步机制</strong>：使用信号量和栅栏来确保渲染顺序正确，避免资源竞争。</li>
                        <li><strong>双缓冲机制</strong>：使用两个帧缓冲交替渲染和呈现，确保画面流畅。</li>
                    </ol>
                    <p>通过这个完整的示例，你已经学会了如何使用Vulkan在屏幕上绘制一个三角形。这个基础可以扩展到更复杂的图形应用，包括3D模型渲染、纹理映射、光照计算等高级功能。</p>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>内容由 AI 生成</p>
    </footer>

    <script>
        function toggleSection(element) {
            const content = element.nextElementSibling;
            const icon = element.querySelector('.toggle-icon');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.textContent = '▶';
            } else {
                content.classList.add('expanded');
                icon.textContent = '▼';
            }
        }
        
        function toggleSubsection(element) {
            const content = element.nextElementSibling;
            const icon = element.querySelector('.toggle-icon');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                icon.textContent = '▶';
            } else {
                content.classList.add('expanded');
                icon.textContent = '▼';
            }
        }
        
        function copyCode(button) {
            const codeBlock = button.parentElement.nextElementSibling;
            const textArea = document.createElement('textarea');
            textArea.value = codeBlock.textContent;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            // 显示复制成功反馈
            const originalText = button.textContent;
            button.textContent = '已复制!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 2000);
        }
        
        // 默认展开第一部分
        document.querySelector('.section-header').click();
    </script>
</body>
</html>