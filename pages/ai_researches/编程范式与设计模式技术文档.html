<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>编程范式与设计模式技术文档</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f7fa;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        header {
            background: linear-gradient(135deg, #2c3e50, #4a6491);
            color: white;
            padding: 30px;
            text-align: center;
        }
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        .content {
            padding: 20px;
        }
        .chapter {
            margin-bottom: 30px;
            border: 1px solid #e1e4e8;
            border-radius: 8px;
            overflow: hidden;
        }
        .chapter-title {
            background: #f6f8fa;
            padding: 15px 20px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #e1e4e8;
        }
        .chapter-title::after {
            content: '+';
            font-size: 1.5rem;
        }
        .chapter-title.active::after {
            content: '-';
        }
        .section {
            margin-bottom: 20px;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            overflow: hidden;
        }
        .section-title {
            background: #f9fafb;
            padding: 12px 20px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .section-title::after {
            content: '+';
            font-size: 1.2rem;
        }
        .section-title.active::after {
            content: '-';
        }
        .subsection {
            margin-bottom: 15px;
            border: 1px solid #eaecef;
            border-radius: 4px;
            overflow: hidden;
        }
        .subsection-title {
            background: #fcfdfe;
            padding: 10px 20px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
        }
        .content-body {
            padding: 20px;
            display: none;
        }
        .content-body.active {
            display: block;
        }
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        ul, ol {
            margin: 15px 0;
            padding-left: 30px;
        }
        li {
            margin-bottom: 8px;
        }
        code {
            background-color: #f6f8fa;
            border-radius: 3px;
            padding: 2px 5px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
        }
        pre {
            background-color: #f6f8fa;
            border-radius: 6px;
            padding: 15px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            border: 1px solid #e1e4e8;
        }
        .code-block {
            position: relative;
        }
        .code-header {
            background: #e1e4e8;
            padding: 5px 10px;
            font-weight: bold;
            border-bottom: 1px solid #d1d5da;
            border-radius: 6px 6px 0 0;
        }
        .code-body {
            padding: 15px;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .highlight {
            background-color: #fff8e1;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        footer {
            text-align: center;
            padding: 20px;
            color: #6c757d;
            font-size: 0.9rem;
            border-top: 1px solid #eaecef;
        }
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            header {
                padding: 20px;
            }
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>编程范式与设计模式技术文档</h1>
            <div class="subtitle">面向过程、面向对象、基于组件开发技术体系研究与C++实现</div>
        </header>
        
        <div class="content">
            <div class="chapter">
                <div class="chapter-title">1. 编程范式技术体系概述</div>
                <div class="content-body">
                    <div class="section">
                        <div class="section-title">1.1 技术演进脉络与发展历程</div>
                        <div class="content-body">
                            <p>软件开发方法随着软件规模的不断扩大而逐步演进，经历了从面向过程到面向对象，再到基于组件开发的发展历程。</p>
                            <p>面向过程编程的历史可以追溯到20世纪50年代，当时计算机科学家们开始探索如何将问题分解为一系列更小的子问题，并通过逐步解决问题的方法来编写程序。这种方法很快就被大多数早期的编程语言所采纳，如FORTRAN、ALGOL和C语言。</p>
                            <p>面向对象编程的发展历程更为悠久，可追溯到1960年代，但其广泛应用和发展主要是在1980年代和1990年代之后。1967年Simula 67的出现首次引入了类和继承机制，为面向对象开发语言奠定了坚实的基础。1980年Smalltalk 80的问世标志着面向对象程序设计方法正式形成。随着时间的推移，到了20世纪80年代中期到90年代，面向对象开发语言迎来了繁荣时期。</p>
                            <p>基于组件的开发方法是面向对象方法的进一步发展，它将软件系统拆分为独立的组件，每个组件都有独立的功能和接口。组件化设计的目标是将系统拆分为独立、可复用的模块，通过组件的组合实现复杂功能，核心诉求是"复用性"和"可维护性"。</p>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">1.2 核心概念与基本特征</div>
                        <div class="content-body">
                            <p><strong>面向过程编程（Procedural Programming）</strong>是一种早期的编程范式，侧重于编写一系列的过程或函数来实现程序。过程可以理解为一系列的指令，它们按照特定的顺序执行，以完成特定的任务。在面向过程的编程语言中，程序的状态通常由变量表示，这些变量可以在过程之间传递和共享。</p>
                            <p><strong>面向对象编程（Object-Oriented Programming, OOP）</strong>是一种编程范式，它使用"对象"来设计软件系统。对象可以包含数据（属性）和代码（方法）。面向对象的四个基本原则是：封装、继承、多态和抽象。</p>
                            <p><strong>基于组件的开发方法</strong>是一种以组件为中心思想的软件开发方法，它将现实世界中的实体抽象为组件，并通过组件的封装、复用、替换来描述软件系统中的各种功能和服务。在C++编程中，设计的基本单位并非单个类，而是类、函数等的集合，这种集合常被称为库或框架，同时也是复用、维护等的基本单位。</p>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">1.3 应用场景与技术选型</div>
                        <div class="content-body">
                            <p>不同的编程范式适用于不同的应用场景。</p>
                            <p><strong>面向过程编程</strong>适用于那些功能一旦实现之后就很少需要改变的场景，例如简单的脚本、一次性任务等。在某些情况下（如嵌入式系统、底层驱动开发等），面向过程的程序可能具有更好的性能表现，因为类调用时需要实例化，可能带来一定的性能开销。</p>
                            <p><strong>面向对象编程</strong>广泛应用于各个领域，包括游戏开发、企业级应用开发等。游戏是一个充满各种对象和交互的复杂系统，包括角色、怪物、道具、场景、游戏规则等，面向对象编程为游戏开发提供了天然的优势。在企业级的信息系统中，如客户关系管理（CRM）系统、企业资源规划（ERP）系统、供应链管理（SCM）系统等，通常涉及到大量的数据处理、业务逻辑实现和用户权限管理等复杂功能。</p>
                            <p><strong>基于组件的开发方法</strong>适用于大规模系统开发，能够更好地利用现有的组件和资源。组件化设计特别适合需要高度可扩展性和可维护性的系统，如现代游戏引擎、大型企业应用平台等。在游戏开发中，组件模式是一种常用的设计模式，它通过将多个功能独立包装成单独的组件，可以自由地装配或拆卸，从而达到很好的解耦效果。</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="chapter">
                <div class="chapter-title">2. 三种编程范式深度对比分析</div>
                <div class="content-body">
                    <div class="section">
                        <div class="section-title">2.1 面向过程编程（POP）详解</div>
                        <div class="content-body">
                            <p>面向过程编程以过程为中心，关注解决问题的步骤。虽然面向过程也强调模块化，但其模块通常是由函数或过程组成的，而不像面向对象那样由对象组成。</p>
                            <p><strong>面向过程编程的核心特点：</strong></p>
                            <ul>
                                <li><strong>数据与函数分离</strong>：在面向过程编程中，数据和函数是分离的，通常是松散连接的。这种分离方式使得程序的结构相对简单，但也带来了一些问题，如数据的一致性难以保证，函数之间的耦合度较高等。</li>
                                <li><strong>自顶向下的设计方法</strong>：面向过程编程遵循自顶向下的方法，而面向对象编程则采用自底向上的方法，其中对象协作完成任务。自顶向下的设计方法适合于问题域相对清晰、功能需求明确的场景。</li>
                                <li><strong>模块化特征</strong>：面向过程编程强调模块化，通过函数调用来实现代码的复用。然而，相对于面向对象，面向过程的代码复用性较低，因为每个函数或过程通常只关注特定的任务，而不易于被其他任务重用。</li>
                                <li><strong>性能优势</strong>：面向过程编程具有简单直接、逻辑清晰的优点，适合小型、简单任务。执行效率高，无需创建对象，函数调用开销小。易于调试，流程明确，问题定位简单。</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">2.2 面向对象编程（OOP）详解</div>
                        <div class="content-body">
                            <p>面向对象编程以"对象"为核心，将现实世界的实体抽象为类（Class）和对象（Object），通过封装、继承、多态三大特性，构建模块化、可复用的代码结构。</p>
                            <p><strong>面向对象编程的核心特征：</strong></p>
                            <ul>
                                <li><strong>封装机制</strong>：面向对象编程通过封装将数据和操作数据的函数捆绑在一起，形成一个独立的对象。这样做的目的是隐藏对象的实现细节，仅暴露必要的操作接口给外界。通过封装，可以降低代码间的耦合度，增加系统的可维护性和可扩展性。</li>
                                <li><strong>继承机制</strong>：继承允许一个对象（子类）继承另一个对象（父类）的属性和方法。这使得子类可以复用父类的代码，极大地提高了代码的重用性，并且能够创建出逻辑层次更加清晰的代码结构。</li>
                                <li><strong>多态机制</strong>：多态是指允许不同对象对同一消息做出响应的能力。具体到编程中，这意味着通过父类类型的引用来调用一个方法时，实际执行的是子类中对应的方法。多态是OOP中实现可扩展性和灵活性的关键。</li>
                                <li><strong>抽象机制</strong>：抽象是指简化复杂现实世界的过程，通过创建抽象数据类型（ADT），只暴露操作对象的核心概念，而不展现内部的复杂逻辑。</li>
                            </ul>
                            <p><strong>面向对象编程的优点：</strong></p>
                            <ul>
                                <li>高复用性，通过继承和组合，可复用已有类</li>
                                <li>高可维护性，封装降低模块间耦合，修改局部不影响整体</li>
                            </ul>
                            <p><strong>面向对象编程的缺点：</strong></p>
                            <ul>
                                <li>学习曲线较陡峭，需要掌握面向对象的概念和设计原则</li>
                                <li>对于小规模和简单问题，面向对象可能带来不必要的复杂性</li>
                                <li>在某些情况下，面向对象的开销较大，执行效率可能不如面向过程</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">2.3 基于组件开发（CBD）详解</div>
                        <div class="content-body">
                            <p>基于组件的开发方法是一种基于编写和使用独立模块化组件的方式进行软件开发，模块化程度更高，具有高度可重用性和可移植性，并且具有独立的接口和行为。</p>
                            <p><strong>基于组件开发的核心特征：</strong></p>
                            <ul>
                                <li><strong>组件化架构</strong>：基于组件的架构也称为基于组件的设计和模块化编程，是一种旨在将行为分解为简洁、可重用组件的软件设计方法。在C++中，模板允许我们定义与通用类型一起工作的函数和类，这允许函数或类接受任何类型，而且只需要编写一次。</li>
                                <li><strong>接口与实现分离</strong>：理想的接口应具备以下特点：向用户呈现完整且连贯的一组概念；在组件的所有部分保持一致；不向用户透露实现细节；可以有多种实现方式；是静态类型的；使用应用程序级类型表达；以有限且明确定义的方式依赖于其他接口。</li>
                                <li><strong>COM组件模型</strong>：COM（Component Object Model，组件对象模型）是由微软推出的一种软件组件架构。COM为软件组件提供了一种语言无关的二进制标准，使得不同语言编写的组件能够互相通信和互操作。COM主要由以下几个核心概念构成：接口（Interface）、类厂（Class Factory）、引用计数（Reference Counting）。</li>
                                <li><strong>CORBA标准</strong>：公共对象请求代理体系结构（CORBA）是对象管理组（OMG）定义的标准，它使多种计算机语言编写、运行在多台计算机上的软件组件能够协同工作。CORBA是一种分布式对象计算的软件架构，它具有架构、位置、实现语言和供应商的独立性；如果需要，各个对象方法可以用不同的语言在不同的位置实现。</li>
                            </ul>
                            <p><strong>基于组件开发的优点：</strong></p>
                            <ul>
                                <li>提高了软件的可重用性，降低了开发成本和编码量</li>
                                <li>降低了软件的维护成本，使得程序更加的独立可扩展性更强，降低软件复杂度</li>
                                <li>适用于大规模系统开发，更好地利用了现有的组件和资源</li>
                            </ul>
                            <p><strong>基于组件开发的缺点：</strong></p>
                            <ul>
                                <li>需要大量的组件库和组件配置，开发成本较高</li>
                                <li>组件的互换性和兼容性可能受限，程序运行稳定性等因素需要加以考虑</li>
                                <li>组件开发和管理需要专门的开发人员和产品经理进行设计和实施</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">2.4 技术特点对比与选型建议</div>
                        <div class="content-body">
                            <p>三种编程范式在技术特点上存在显著差异。面向过程编程的数据和函数是分离的，而面向对象编程通过封装将数据和方法捆绑在类中。面向过程编程遵循自顶向下的方法，而面向对象编程采用自底向上的方法。</p>
                            <p>在性能方面，面向过程编程在执行简单任务时具有效率优势，而面向对象编程在处理需要复杂交互的不同数据类型时表现更好。在性能关键的应用中，面向过程编程通常更容易学习并表现出色，而面向对象编程则更好地支持可扩展性、团队协作和长期维护。</p>
                            <p>在代码组织方面，面向过程编程按照过程或函数来组织代码，而面向对象编程围绕代表现实世界实体的对象来组织代码，支持可重用性和可扩展性。这种范式鼓励继承和多态，便于管理复杂系统。</p>
                            <p><strong>选型建议：</strong></p>
                            <ul>
                                <li>对于简单的问题和小规模程序，面向过程编程具有高效性和执行速度优势</li>
                                <li>对于需要高度可扩展性、团队协作和长期维护的大型复杂系统，面向对象编程是更好的选择</li>
                                <li>对于大规模系统开发，特别是需要高度可重用性和可维护性的场景，基于组件的开发方法提供了更好的解决方案</li>
                            </ul>
                            <p>在实际开发中，常见的做法是采用不同方法的混合模式，根据实际需要选择使用不同的开发方法来开发软件系统，以最大限度地发挥其优势。</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="chapter">
                <div class="chapter-title">3. 面向对象核心概念深度解析</div>
                <div class="content-body">
                    <div class="section">
                        <div class="section-title">3.1 继承机制详解</div>
                        <div class="content-body">
                            <p>继承是面向对象编程中的一个核心概念，它允许一个类（子类/派生类）从另一个类（父类/基类）那里获得属性和方法。子类可以重用父类的代码，并添加或修改自己的特性。</p>
                            <p><strong>继承的语法形式：</strong></p>
                            <div class="code-block">
                                <div class="code-header">C++继承语法</div>
                                <pre><code>class BaseClass { 
    // ... 父类成员 ... 
}; 
class DerivedClass : public BaseClass {    // public 继承 
    // ... 子类成员 ... 
};</code></pre>
                            </div>
                            <p>继承方式决定了基类成员在派生类中的访问权限。C++支持三种继承方式：</p>
                            <ul>
                                <li><strong>public继承</strong>：父类的public成员在子类中仍然是public，protected成员在子类中仍然是protected，private成员在子类中不可访问。这种继承方式保持了基类成员的访问属性，是最常用的继承方式。</li>
                                <li><strong>protected继承</strong>：父类的public和protected成员在子类中都变成protected，private成员在子类中不可访问。这种继承方式将基类的公有成员转换为保护成员，通常用于实现继承而非接口继承。</li>
                                <li><strong>private继承</strong>：父类的所有成员在子类中都变成private，private成员在子类中不可访问。一般不推荐使用这种继承方式，因为它破坏了继承的is-a关系。</li>
                            </ul>
                            <p>在继承体系中，基类和派生类都有独立的作用域。不同作用域可以定义同一个名字的变量，不同作用域的同名函数不能构成重载，同一个作用域内同名函数才有可能构成重载。当子类和父类有同名成员时，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫做隐藏或重定义。</p>
                            <p>继承的构造函数规则特别重要。继承中规定：父类的成员必须通过调用父类的构造函数完成初始化。因此，继承中子类需要帮助父类初始化。如果子类中没写父类构造函数，则父类会自动调用无参的构造函数，但是父类写了其他构造函数，但没写无参则报错，除非全缺省。</p>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">3.2 多继承与菱形继承问题</div>
                        <div class="content-body">
                            <p>C++支持多继承，即一个类可以继承自多个基类。</p>
                            <p><strong>多继承的语法形式：</strong></p>
                            <div class="code-block">
                                <div class="code-header">C++多继承语法</div>
                                <pre><code>class DerivedClass : public BaseClass1, public BaseClass2 {
    // ... 子类成员 ... 
};</code></pre>
                            </div>
                            <p>然而，如果多个基类继承自相同的祖先类，就会导致菱形继承问题。菱形继承是多继承的一种特殊情况，当一个类从两个基类继承，而这两个基类又都继承自同一个基类时，就形成了菱形继承结构。</p>
                            <p><strong>菱形继承带来两个主要问题：</strong></p>
                            <ul>
                                <li><strong>二义性问题</strong>：菱形继承意味着两个父类都继承了爷爷类，所以两个父类都有相同的爷爷成员，导致孙子会有两个相同的成员。二义性是指继承了多个有相同爷爷类的父类，也就继承了多份相同的爷爷类成员，直接指定这些爷爷类成员时会发生冲突，不能唯一确认。</li>
                                <li><strong>数据冗余问题</strong>：数据冗余是指两份相同继承，导致内存空间的浪费和数据一致性的问题。</li>
                            </ul>
                            <p>C++引入了虚继承（virtual inheritance）来解决菱形继承的二义性和数据冗余问题。</p>
                            <p><strong>虚继承的语法形式：</strong></p>
                            <div class="code-block">
                                <div class="code-header">C++虚继承语法</div>
                                <pre><code>class BaseClass {};
class DerivedClass1 : virtual public BaseClass {};
class DerivedClass2 : virtual public BaseClass {};
class FinalDerived : public DerivedClass1, public DerivedClass2 {};</code></pre>
                            </div>
                            <p><strong>虚继承的特性：</strong></p>
                            <ul>
                                <li><strong>共享基类实例</strong>：虚继承确保共享基类（虚基类）在继承体系中只保留一份副本，避免了数据冗余和二义性。</li>
                                <li><strong>构造函数调用规则</strong>：虚继承的基类只会调用一次构造，由实例化的子类进行构造，这个子类需要对所有祖先进行构造；非基类且非实例化的子类的派生类中的对基类的构造函数会自动失效。</li>
                                <li><strong>实现复杂性</strong>：虚继承会增加实现的复杂性，仅在必要时使用，虚继承可能引入额外的间接访问开销。多继承可认为是C++的缺陷之一，所以后来例如Java语言等都没有多继承。</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">3.3 虚函数与多态机制</div>
                        <div class="content-body">
                            <p>虚函数是C++中实现多态的关键。在基类中声明为virtual的成员函数，可以在派生类中被重写（override）。当通过基类指针或引用调用虚函数时，实际调用的函数版本取决于指针或引用所指向的对象的实际类型，而不是指针或引用本身的类型。</p>
                            <p><strong>虚函数的声明语法：</strong></p>
                            <div class="code-block">
                                <div class="code-header">C++虚函数声明</div>
                                <pre><code>class Base {
public:
    virtual void someFunction() {
        // ... 基类实现 ...
    }
};</code></pre>
                            </div>
                            <p>在派生类中重写虚函数时，建议使用override关键字（C++11及以后）：</p>
                            <div class="code-block">
                                <div class="code-header">C++虚函数重写</div>
                                <pre><code>class Derived : public Base {
public:
    void someFunction() override {
        // ... 派生类实现 ...
    }
};</code></pre>
                            </div>
                            <p>override关键字显式地告诉编译器，这个函数是重写基类中的虚函数。如果基类中没有对应的虚函数，编译器会报错，这有助于避免错误。</p>
                            <p><strong>多态分为两类：</strong></p>
                            <ul>
                                <li><strong>静态多态（编译时多态）</strong>：函数重载是静态多态的典型例子。静态绑定又称为前期绑定（早绑定），在程序编译期间就确定了程序的行为。</li>
                                <li><strong>动态多态（运行时多态）</strong>：虚函数多态是动态多态的典型例子。动态绑定也称为后期绑定（晚绑定），是在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数。</li>
                            </ul>
                            <p><strong>构成多态的条件：</strong></p>
                            <ul>
                                <li>必须存在继承关系</li>
                                <li>继承关系中必须有同名的虚函数，并且它们是覆盖关系（函数原型相同）</li>
                            </ul>
                            <p><strong>纯虚函数和抽象类：</strong></p>
                            <p>纯虚函数是在基类中声明但没有提供实现的虚函数，通过在函数声明的末尾使用"= 0"进行标记。包含纯虚函数的类称为抽象类（Abstract Class），抽象类不能被实例化，只能作为基类被继承。</p>
                            <div class="code-block">
                                <div class="code-header">C++纯虚函数和抽象类</div>
                                <pre><code>class Shape {   // 抽象类 
public:
    virtual double area() const = 0;   // 纯虚函数 
    virtual void draw() const = 0;        // 纯虚函数 
};</code></pre>
                            </div>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">3.4 虚函数表机制详解</div>
                        <div class="content-body">
                            <p>虚函数表（Virtual Function Table, vtable）是C++编译器在幕后用来实现虚函数的一种机制。每个包含虚函数的类（以及其派生类）都有一个与之关联的虚函数表。虚函数表是一个函数指针数组，其中每个元素指向该类的一个虚函数的实际地址。</p>
                            <p><strong>虚函数表的工作原理：</strong></p>
                            <ol>
                                <li><strong>创建对象</strong>：当创建一个包含虚函数的类的对象时，编译器会在对象内存的开头（或某个固定位置）添加一个指向该类的虚函数表的指针（通常称为vptr）。</li>
                                <li><strong>调用虚函数</strong>：当通过基类指针或引用调用虚函数时，编译器会：
                                    <ul>
                                        <li>通过对象的vptr找到对应的虚函数表</li>
                                        <li>在虚函数表中查找要调用的虚函数的索引（这个索引在编译时就确定了）</li>
                                        <li>根据索引找到虚函数的实际地址，并调用该函数</li>
                                    </ul>
                                </li>
                            </ol>
                            <p><strong>虚函数表的结构：</strong></p>
                            <p>假设有以下类定义：</p>
                            <div class="code-block">
                                <div class="code-header">C++类定义示例</div>
                                <pre><code>class Base {
public:
    virtual void f1();
    virtual void f2();
};

class Derived : public Base {
public:
    void f1() override;   // 重写f1
    virtual void f3();   // 新的虚函数
};</code></pre>
                            </div>
                            <p>虚函数表的结构可能如下：</p>
                            <div class="code-block">
                                <div class="code-header">虚函数表示例</div>
                                <pre><code>// Base类的虚函数表 (Base::vtable)
+-----------------+
|   &Base::f1     |    // 指向Base::f1的地址
+-----------------+
|   &Base::f2     |    // 指向Base::f2的地址
+-----------------+

// Derived类的虚函数表 (Derived::vtable)
+-----------------+
|   &Derived::f1  |    // 指向Derived::f1的地址 (重写)
+-----------------+
|   &Base::f2     |    // 指向Base::f2的地址 (继承)
+-----------------+
|   &Derived::f3  |    // 指向Derived::f3的地址 (新增)
+-----------------+</code></pre>
                            </div>
                            <p><strong>对象内存布局：</strong></p>
                            <div class="code-block">
                                <div class="code-header">对象内存布局示例</div>
                                <pre><code>// Base对象
+----------+-------------------+
|  vptr    | --> Base::vtable  |
+----------+-------------------+
|   ...    |                   |    // 其他成员数据
+----------+-------------------+

// Derived对象
+----------+-------------------+
|  vptr    | --> Derived::vtable |
+----------+-------------------+
|   ...    |                   |    // Base类的成员数据
+----------+-------------------+
|   ...    |                   |    // Derived类的成员数据
+----------+-------------------+</code></pre>
                            </div>
                            <p><strong>虚函数表的特性：</strong></p>
                            <ul>
                                <li>虚函数表本质是一个虚函数指针数组，元素顺序取决于虚函数的声明顺序，大小由虚函数的数量决定。</li>
                                <li>虚表是由虚函数的地址组成，而编译期间虚函数的地址已经存在，因此能够在编译期间完成。</li>
                                <li>虚函数继承体系中，基类先生成一份虚表，之后派生类自己的虚表都是基于从父类继承下来的虚表。</li>
                                <li>子类会继承父类的虚函数表（开辟一个新的数组，浅拷贝），派生类自己新增加的虚函数，从继承的虚表的最后一个元素开始，按其在派生类中的声明次序增加到派生类虚表的最后。</li>
                            </ul>
                            <p><strong>虚函数表指针的初始化：</strong>对象中的虚表指针在构造函数中初始化。虚表指针初始化是在构造函数的初始化列表中完成的，要先执行完构造函数，才能有虚函数。</p>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">3.5 接口概念与C++实现</div>
                        <div class="content-body">
                            <p>在C++中，接口概念主要通过抽象类和纯虚函数来实现。接口定义了一组纯虚函数，这些函数在派生类中必须被实现。抽象基类是一个包含至少一个纯虚函数的类，它可以被继承，并且作为其他类的公共接口。</p>
                            <p><strong>纯接口类的定义：</strong>纯接口类只包含纯虚函数和静态函数，无非静态数据成员，构造函数受限，且需虚析构函数。</p>
                            <div class="code-block">
                                <div class="code-header">C++纯接口类定义</div>
                                <pre><code>class IInterface {
public:
    virtual void function1() = 0;
    virtual void function2() = 0;
    virtual ~IInterface() = default;
};</code></pre>
                            </div>
                            <p><strong>接口继承与实现继承：</strong></p>
                            <p>普通虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口+缺省实现，目的是为了重写，达成多态。纯虚函数只继承了接口，要求用户必须要重写函数的实现。</p>
                            <p>纯虚函数定义了接口的契约，要求派生类必须实现。纯虚函数在C++中扮演了接口的角色，主要用于定义行为规范，具体实现由派生类完成。</p>
                            <p><strong>接口设计原则：</strong></p>
                            <p>理想的接口应具备以下特点：</p>
                            <ul>
                                <li>向用户呈现完整且连贯的一组概念</li>
                                <li>在组件的所有部分保持一致</li>
                                <li>不向用户透露实现细节</li>
                                <li>可以有多种实现方式</li>
                                <li>是静态类型的</li>
                                <li>使用应用程序级类型表达</li>
                                <li>以有限且明确定义的方式依赖于其他接口</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="chapter">
                <div class="chapter-title">4. 设计模式详解与C++实现</div>
                <div class="content-body">
                    <div class="section">
                        <div class="section-title">4.1 创建型模式</div>
                        <div class="content-body">
                            <div class="subsection">
                                <div class="subsection-title">4.1.1 单例模式（Singleton）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>单例模式确保一个类只能创建一个对象（比如全局配置、日志器），像国家只有一个总统。核心是私有化构造函数，通过静态方法返回唯一实例。</p>
                                    <p><strong>饿汉式实现（C++98）：</strong></p>
                                    <div class="code-block">
                                        <div class="code-header">C++单例模式（饿汉式）</div>
                                        <pre><code>#include <iostream>
using namespace std;

class Singleton {
private:
    // 私有化构造函数，禁止外部创建
    Singleton() { cout << "创建单例对象" << endl; }
    // 私有化拷贝构造和赋值，禁止复制
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    // 静态成员变量，存储唯一实例
    static Singleton instance;
public:
    // 静态方法，返回实例
    static Singleton& getInstance() {
        return instance;
    }
    void doSomething() {
        cout << "单例对象做事" << endl;
    }
};

// 类外初始化静态成员（程序启动时创建）
Singleton Singleton::instance;

int main() {
    // 只能通过getInstance获取对象
    Singleton& s1 = Singleton::getInstance();
    Singleton& s2 = Singleton::getInstance();
    // s1和s2是同一个对象（地址相同）
    cout << &s1 << " " << &s2 << endl;
    s1.doSomething();
    return 0;
}</code></pre>
                                    </div>
                                    <p><strong>懒汉式实现（C++11，线程安全）：</strong></p>
                                    <div class="code-block">
                                        <div class="code-header">C++单例模式（懒汉式）</div>
                                        <pre><code>#include <iostream>
#include <mutex>
using namespace std;

class Singleton {
private:
    Singleton() { cout << "创建单例对象" << endl; }
    ~Singleton() = default;
    static mutex mtx;
public:
    static Singleton& getInstance() {
        static Singleton instance; // C++11保证线程安全
        return instance;
    }
    void doSomething() {
        cout << "单例对象做事" << endl;
    }
};

int main() {
    Singleton& s1 = Singleton::getInstance();
    Singleton& s2 = Singleton::getInstance();
    cout << &s1 << " " << &s2 << endl;
    s1.doSomething();
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.1.2 工厂方法模式（Factory Method）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>工厂方法模式让"子类"决定创建哪种对象（比如披萨店，北京店做北京披萨，上海店做上海披萨）。核心是父类定义创建对象的接口，子类实现具体创建逻辑。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++工厂方法模式</div>
                                        <pre><code>#include <iostream>
#include <string>
using namespace std;

// 抽象产品类
class Pizza {
public:
    virtual void prepare() = 0;
    virtual void bake() = 0;
    virtual void cut() = 0;
    virtual void box() = 0;
    virtual ~Pizza() = default;
};

// 具体产品类
class BeijingPizza : public Pizza {
public:
    void prepare() override { cout << "准备北京披萨材料" << endl; }
    void bake() override { cout << "烘烤北京披萨" << endl; }
    void cut() override { cout << "切割北京披萨" << endl; }
    void box() override { cout << "包装北京披萨" << endl; }
};

class ShanghaiPizza : public Pizza {
public:
    void prepare() override { cout << "准备上海披萨材料" << endl; }
    void bake() override { cout << "烘烤上海披萨" << endl; }
    void cut() override { cout << "切割上海披萨" << endl; }
    void box() override { cout << "包装上海披萨" << endl; }
};

// 抽象工厂类
class PizzaStore {
public:
    virtual Pizza* createPizza() = 0;
    Pizza* orderPizza() {
        Pizza* pizza = createPizza();
        pizza->prepare();
        pizza->bake();
        pizza->cut();
        pizza->box();
        return pizza;
    }
};

// 具体工厂类
class BeijingPizzaStore : public PizzaStore {
public:
    Pizza* createPizza() override {
        return new BeijingPizza();
    }
};

class ShanghaiPizzaStore : public PizzaStore {
public:
    Pizza* createPizza() override {
        return new ShanghaiPizza();
    }
};

int main() {
    PizzaStore* beijingStore = new BeijingPizzaStore();
    PizzaStore* shanghaiStore = new ShanghaiPizzaStore();
    
    Pizza* pizza1 = beijingStore->orderPizza();
    Pizza* pizza2 = shanghaiStore->orderPizza();
    
    delete pizza1;
    delete pizza2;
    delete beijingStore;
    delete shanghaiStore;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.1.3 抽象工厂模式（Abstract Factory）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>抽象工厂模式创建"一系列相关对象"（比如造汽车，宝马工厂造宝马车和宝马零件；奔驰工厂造奔驰车和奔驰零件）。核心是工厂接口定义多个相关产品的创建方法，具体工厂实现这些方法。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++抽象工厂模式</div>
                                        <pre><code>#include <iostream>
using namespace std;

// 抽象产品A
class AbstractProductA {
public:
    virtual void use() = 0;
    virtual ~AbstractProductA() = default;
};

// 具体产品A1
class ProductA1 : public AbstractProductA {
public:
    void use() override { cout << "使用产品A1" << endl; }
};

// 具体产品A2
class ProductA2 : public AbstractProductA {
public:
    void use() override { cout << "使用产品A2" << endl; }
};

// 抽象产品B
class AbstractProductB {
public:
    virtual void operate() = 0;
    virtual ~AbstractProductB() = default;
};

// 具体产品B1
class ProductB1 : public AbstractProductB {
public:
    void operate() override { cout << "操作产品B1" << endl; }
};

// 具体产品B2
class ProductB2 : public AbstractProductB {
public:
    void operate() override { cout << "操作产品B2" << endl; }
};

// 抽象工厂
class AbstractFactory {
public:
    virtual AbstractProductA* createProductA() = 0;
    virtual AbstractProductB* createProductB() = 0;
    virtual ~AbstractFactory() = default;
};

// 具体工厂1
class Factory1 : public AbstractFactory {
public:
    AbstractProductA* createProductA() override {
        return new ProductA1();
    }
    AbstractProductB* createProductB() override {
        return new ProductB1();
    }
};

// 具体工厂2
class Factory2 : public AbstractFactory {
public:
    AbstractProductA* createProductA() override {
        return new ProductA2();
    }
    AbstractProductB* createProductB() override {
        return new ProductB2();
    }
};

int main() {
    AbstractFactory* factory1 = new Factory1();
    AbstractFactory* factory2 = new Factory2();
    
    AbstractProductA* productA1 = factory1->createProductA();
    AbstractProductB* productB1 = factory1->createProductB();
    productA1->use();
    productB1->operate();
    
    AbstractProductA* productA2 = factory2->createProductA();
    AbstractProductB* productB2 = factory2->createProductB();
    productA2->use();
    productB2->operate();
    
    delete productA1;
    delete productB1;
    delete productA2;
    delete productB2;
    delete factory1;
    delete factory2;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.1.4 建造者模式（Builder）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>建造者模式分步创建复杂对象（比如造电脑，先装CPU，再装内存，最后装硬盘，不同配置步骤相同但零件不同）。核心是分离"对象的构建步骤"和"具体零件"，由指挥者控制步骤，建造者提供零件。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++建造者模式</div>
                                        <pre><code>#include <iostream>
#include <string>
using namespace std;

// 产品类
class Computer {
public:
    void setCPU(const string& cpu) { m_cpu = cpu; }
    void setMemory(const string& memory) { m_memory = memory; }
    void setHDD(const string& hdd) { m_hdd = hdd; }
    void showInfo() {
        cout << "电脑配置：" << endl;
        cout << "CPU: " << m_cpu << endl;
        cout << "内存: " << m_memory << endl;
        cout << "硬盘: " << m_hdd << endl;
    }
private:
    string m_cpu;
    string m_memory;
    string m_hdd;
};

// 抽象建造者
class ComputerBuilder {
public:
    virtual void buildCPU() = 0;
    virtual void buildMemory() = 0;
    virtual void buildHDD() = 0;
    virtual Computer* getResult() = 0;
    virtual ~ComputerBuilder() = default;
};

// 具体建造者1（高端配置）
class HighEndBuilder : public ComputerBuilder {
public:
    HighEndBuilder() { m_computer = new Computer(); }
    ~HighEndBuilder() { delete m_computer; }
    void buildCPU() override { m_computer->setCPU("Intel i7-12700K"); }
    void buildMemory() override { m_computer->setMemory("32GB DDR5 4800MHz"); }
    void buildHDD() override { m_computer->setHDD("2TB NVMe SSD"); }
    Computer* getResult() override { return m_computer; }
private:
    Computer* m_computer;
};

// 具体建造者2（中端配置）
class MidEndBuilder : public ComputerBuilder {
public:
    MidEndBuilder() { m_computer = new Computer(); }
    ~MidEndBuilder() { delete m_computer; }
    void buildCPU() override { m_computer->setCPU("Intel i5-12400F"); }
    void buildMemory() override { m_computer->setMemory("16GB DDR4 3200MHz"); }
    void buildHDD() override { m_computer->setHDD("1TB NVMe SSD"); }
    Computer* getResult() override { return m_computer; }
private:
    Computer* m_computer;
};

// 指挥者
class Director {
public:
    void construct(ComputerBuilder* builder) {
        builder->buildCPU();
        builder->buildMemory();
        builder->buildHDD();
    }
};

int main() {
    Director director;
    ComputerBuilder* highEndBuilder = new HighEndBuilder();
    ComputerBuilder* midEndBuilder = new MidEndBuilder();
    
    director.construct(highEndBuilder);
    Computer* highEndComputer = highEndBuilder->getResult();
    highEndComputer->showInfo();
    
    director.construct(midEndBuilder);
    Computer* midEndComputer = midEndBuilder->getResult();
    midEndComputer->showInfo();
    
    delete highEndComputer;
    delete midEndComputer;
    delete highEndBuilder;
    delete midEndBuilder;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.1.5 原型模式（Prototype）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>原型模式通过"复制现有对象"创建新对象（比如文档复制粘贴，避免重新输入）。核心是实现克隆方法，通过已有实例快速创建新实例（深拷贝/浅拷贝需注意）。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++原型模式</div>
                                        <pre><code>#include <iostream>
#include <memory>
using namespace std;

// 原型接口
class Prototype {
public:
    virtual Prototype* clone() = 0;
    virtual void showInfo() = 0;
    virtual ~Prototype() = default;
};

// 具体原型类
class ConcretePrototype : public Prototype {
public:
    ConcretePrototype(int value) : m_value(value) {
        cout << "创建原型对象，值为：" << m_value << endl;
    }
    Prototype* clone() override {
        return new ConcretePrototype(*this);
    }
    void showInfo() override {
        cout << "原型对象，值为：" << m_value << endl;
    }
private:
    int m_value;
};

int main() {
    Prototype* prototype = new ConcretePrototype(100);
    Prototype* clone1 = prototype->clone();
    Prototype* clone2 = prototype->clone();
    
    prototype->showInfo();
    clone1->showInfo();
    clone2->showInfo();
    
    delete prototype;
    delete clone1;
    delete clone2;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">4.2 结构型模式</div>
                        <div class="content-body">
                            <div class="subsection">
                                <div class="subsection-title">4.2.1 适配器模式（Adapter）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>适配器模式让"不兼容的接口"能一起工作（比如手机充电，插头（220V）通过充电器（适配器）转为5V给手机用）。核心是包装不兼容的类，提供目标接口。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++适配器模式</div>
                                        <pre><code>#include <iostream>
using namespace std;

// 目标接口
class Target {
public:
    virtual void request() = 0;
    virtual ~Target() = default;
};

// 适配者类（需要适配的类）
class Adaptee {
public:
    void specificRequest() {
        cout << "适配者执行特定请求" << endl;
    }
};

// 类适配器（继承方式）
class ClassAdapter : public Target, private Adaptee {
public:
    void request() override {
        cout << "类适配器：";
        specificRequest();
    }
};

// 对象适配器（组合方式）
class ObjectAdapter : public Target {
public:
    ObjectAdapter(Adaptee* adaptee) : m_adaptee(adaptee) {}
    void request() override {
        cout << "对象适配器：";
        m_adaptee->specificRequest();
    }
private:
    Adaptee* m_adaptee;
};

int main() {
    Adaptee* adaptee = new Adaptee();
    Target* classAdapter = new ClassAdapter();
    Target* objectAdapter = new ObjectAdapter(adaptee);
    
    classAdapter->request();
    objectAdapter->request();
    
    delete adaptee;
    delete classAdapter;
    delete objectAdapter;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.2.2 桥接模式（Bridge）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>桥接模式将"抽象"和"实现"分离，让它们能独立变化（比如画画，笔（抽象）和颜色（实现）分离，笔可以换不同颜色，颜色也可以给不同笔用）。核心是用组合代替继承，避免类爆炸。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++桥接模式</div>
                                        <pre><code>#include <iostream>
using namespace std;

// 实现抽象
class Implementor {
public:
    virtual void operation() = 0;
    virtual ~Implementor() = default;
};

// 具体实现1
class ConcreteImplementorA : public Implementor {
public:
    void operation() override { cout << "具体实现A" << endl; }
};

// 具体实现2
class ConcreteImplementorB : public Implementor {
public:
    void operation() override { cout << "具体实现B" << endl; }
};

// 抽象类
class Abstraction {
public:
    Abstraction(Implementor* impl) : m_impl(impl) {}
    virtual void operation() {
        m_impl->operation();
    }
    virtual ~Abstraction() { delete m_impl; }
protected:
    Implementor* m_impl;
};

// 扩展抽象类
class RefinedAbstraction : public Abstraction {
public:
    RefinedAbstraction(Implementor* impl) : Abstraction(impl) {}
    void operation() override {
        cout << "扩展抽象：";
        Abstraction::operation();
    }
};

int main() {
    Implementor* implA = new ConcreteImplementorA();
    Implementor* implB = new ConcreteImplementorB();
    
    Abstraction* abs1 = new RefinedAbstraction(implA);
    Abstraction* abs2 = new RefinedAbstraction(implB);
    
    abs1->operation();
    abs2->operation();
    
    delete abs1;
    delete abs2;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.2.3 组合模式（Composite）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>组合模式把"单个对象"和"对象集合"统一对待（比如文件系统，文件和文件夹都可以被删除、复制，文件夹里可以包含文件或子文件夹）。核心是用树形结构表示整体-部分关系，定义统一接口。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++组合模式</div>
                                        <pre><code>#include <iostream>
#include <vector>
using namespace std;

// 组件接口
class Component {
public:
    virtual void add(Component* component) = 0;
    virtual void remove(Component* component) = 0;
    virtual void operation() = 0;
    virtual ~Component() = default;
};

// 叶子节点（没有子节点）
class Leaf : public Component {
public:
    Leaf(string name) : m_name(name) {}
    void add(Component* component) override {
        cout << "叶子节点不能添加子节点" << endl;
    }
    void remove(Component* component) override {
        cout << "叶子节点不能删除子节点" << endl;
    }
    void operation() override {
        cout << "叶子节点：" << m_name << endl;
    }
private:
    string m_name;
};

// 组合节点（可以有子节点）
class Composite : public Component {
public:
    Composite(string name) : m_name(name) {}
    void add(Component* component) override {
        m_children.push_back(component);
    }
    void remove(Component* component) override {
        auto it = find(m_children.begin(), m_children.end(), component);
        if (it != m_children.end()) {
            m_children.erase(it);
        }
    }
    void operation() override {
        cout << "组合节点：" << m_name << "，包含：" << endl;
        for (auto& child : m_children) {
            child->operation();
        }
    }
private:
    string m_name;
    vector<Component*> m_children;
};

int main() {
    Composite* root = new Composite("根目录");
    Composite* dir1 = new Composite("目录1");
    Composite* dir2 = new Composite("目录2");
    Leaf* file1 = new Leaf("文件1.txt");
    Leaf* file2 = new Leaf("文件2.txt");
    Leaf* file3 = new Leaf("文件3.txt");
    
    root->add(dir1);
    root->add(dir2);
    dir1->add(file1);
    dir1->add(file2);
    dir2->add(file3);
    
    root->operation();
    
    delete root;
    delete dir1;
    delete dir2;
    delete file1;
    delete file2;
    delete file3;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.2.4 装饰器模式（Decorator）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>装饰器模式动态给对象"加功能"（比如给咖啡加奶、加糖，不改变咖啡本身，组合出多种搭配）。核心是装饰器和被装饰对象实现相同接口，装饰器持有被装饰对象的引用。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++装饰器模式</div>
                                        <pre><code>#include <iostream>
#include <string>
using namespace std;

// 抽象组件
class Coffee {
public:
    virtual string getDescription() = 0;
    virtual double cost() = 0;
    virtual ~Coffee() = default;
};

// 具体组件（黑咖啡）
class BlackCoffee : public Coffee {
public:
    string getDescription() override { return "黑咖啡"; }
    double cost() override { return 15.0; }
};

// 装饰器基类
class Decorator : public Coffee {
protected:
    Coffee* m_coffee;
public:
    Decorator(Coffee* coffee) : m_coffee(coffee) {}
    virtual ~Decorator() { delete m_coffee; }
};

// 具体装饰器：加奶
class MilkDecorator : public Decorator {
public:
    MilkDecorator(Coffee* coffee) : Decorator(coffee) {}
    string getDescription() override {
        return m_coffee->getDescription() + " + 奶";
    }
    double cost() override {
        return m_coffee->cost() + 3.0;
    }
};

// 具体装饰器：加糖
class SugarDecorator : public Decorator {
public:
    SugarDecorator(Coffee* coffee) : Decorator(coffee) {}
    string getDescription() override {
        return m_coffee->getDescription() + " + 糖";
    }
    double cost() override {
        return m_coffee->cost() + 2.0;
    }
};

int main() {
    Coffee* coffee = new BlackCoffee();
    coffee = new MilkDecorator(coffee);
    coffee = new SugarDecorator(coffee);
    
    cout << "咖啡描述：" << coffee->getDescription() << endl;
    cout << "咖啡价格：" << coffee->cost() << "元" << endl;
    
    delete coffee;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.2.5 外观模式（Facade）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>外观模式给复杂系统提供"简单接口"（比如智能家居，一个按钮控制开灯、开空调、开电视，用户不用关心每个设备的细节）。核心是封装子系统的复杂交互，提供统一入口。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++外观模式</div>
                                        <pre><code>#include <iostream>
using namespace std;

// 子系统类1：灯
class Light {
public:
    void turnOn() { cout << "开灯" << endl; }
    void turnOff() { cout << "关灯" << endl; }
};

// 子系统类2：空调
class AirConditioner {
public:
    void turnOn() { cout << "开空调" << endl; }
    void turnOff() { cout << "关空调" << endl; }
    void setTemperature(int temp) {
        cout << "设置温度为" << temp << "度" << endl;
    }
};

// 子系统类3：电视
class Television {
public:
    void turnOn() { cout << "开电视" << endl; }
    void turnOff() { cout << "关电视" << endl; }
    void setChannel(int channel) {
        cout << "设置频道为" << channel << endl;
    }
};

// 外观类
class SmartHomeFacade {
public:
    SmartHomeFacade() {
        m_light = new Light();
        m_airConditioner = new AirConditioner();
        m_television = new Television();
    }
    ~SmartHomeFacade() {
        delete m_light;
        delete m_airConditioner;
        delete m_television;
    }
    void goHomeMode() {
        cout << "回家模式：" << endl;
        m_light->turnOn();
        m_airConditioner->turnOn();
        m_airConditioner->setTemperature(25);
        m_television->turnOn();
        m_television->setChannel(1);
    }
    void leaveHomeMode() {
        cout << "离家模式：" << endl;
        m_light->turnOff();
        m_airConditioner->turnOff();
        m_television->turnOff();
    }
private:
    Light* m_light;
    AirConditioner* m_airConditioner;
    Television* m_television;
};

int main() {
    SmartHomeFacade* home = new SmartHomeFacade();
    home->goHomeMode();
    cout << endl;
    home->leaveHomeMode();
    delete home;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.2.6 享元模式（Flyweight）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>享元模式复用"重复对象"，节省内存（比如游戏中大量相同的树，只存一份树的模型，不同位置共享该模型）。核心是分离"内部状态"（共享部分）和"外部状态"（变化部分）。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++享元模式</div>
                                        <pre><code>#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

// 享元接口
class TreeFlyweight {
public:
    virtual void display(int x, int y) = 0;
    virtual ~TreeFlyweight() = default;
};

// 具体享元类
class ConcreteTreeFlyweight : public TreeFlyweight {
private:
    string m_type;
    string m_texture;
public:
    ConcreteTreeFlyweight(string type, string texture) : m_type(type), m_texture(texture) {}
    void display(int x, int y) override {
        cout << "绘制" << m_type << "树，纹理：" << m_texture << "，位置：(" << x << "," << y << ")" << endl;
    }
};

// 享元工厂
class TreeFlyweightFactory {
private:
    unordered_map<string, TreeFlyweight*> m_flyweights;
public:
    TreeFlyweight* getTree(string type) {
        if (m_flyweights.find(type) == m_flyweights.end()) {
            string texture;
            if (type == "松树") {
                texture = "针叶纹理";
            } else if (type == "杨树") {
                texture = "阔叶纹理";
            } else {
                texture = "默认纹理";
            }
            m_flyweights[type] = new ConcreteTreeFlyweight(type, texture);
        }
        return m_flyweights[type];
    }
    ~TreeFlyweightFactory() {
        for (auto& pair : m_flyweights) {
            delete pair.second;
        }
    }
};

int main() {
    TreeFlyweightFactory factory;
    // 绘制10棵树（只有2种类型，复用模型）
    factory.getTree("松树")->display(10, 20);
    factory.getTree("松树")->display(30, 40);
    factory.getTree("杨树")->display(50, 60);
    factory.getTree("松树")->display(70, 80);
    factory.getTree("杨树")->display(90, 100);
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.2.7 代理模式（Proxy）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>代理模式给对象找个"替身"，控制对原对象的访问（比如代购，帮你买国外商品，你不用直接去国外）。核心是代理和原对象实现同一接口，代理中包含原对象的引用。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++代理模式</div>
                                        <pre><code>#include <iostream>
#include <string>
using namespace std;

// 抽象主题
class Subject {
public:
    virtual void request() = 0;
    virtual ~Subject() = default;
};

// 真实主题
class RealSubject : public Subject {
public:
    void request() override {
        cout << "真实主题执行请求" << endl;
    }
};

// 代理类
class Proxy : public Subject {
private:
    RealSubject* m_realSubject;
public:
    Proxy() : m_realSubject(nullptr) {}
    void request() override {
        if (m_realSubject == nullptr) {
            m_realSubject = new RealSubject();
        }
        cout << "代理预处理..." << endl;
        m_realSubject->request();
        cout << "代理后处理..." << endl;
    }
    ~Proxy() {
        if (m_realSubject) {
            delete m_realSubject;
        }
    }
};

int main() {
    Proxy* proxy = new Proxy();
    proxy->request();
    proxy->request(); // 第二次调用不会重新创建RealSubject
    delete proxy;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="section">
                        <div class="section-title">4.3 行为型模式</div>
                        <div class="content-body">
                            <div class="subsection">
                                <div class="subsection-title">4.3.1 责任链模式（Chain of Responsibility）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>责任链模式让请求"沿着链传递"，直到有对象处理它（比如请假审批，组长→经理→总监，谁有权批就谁批）。核心是每个对象都有下一个处理者的引用，形成链条。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++责任链模式</div>
                                        <pre><code>#include <iostream>
#include <string>
using namespace std;

// 请求类
class LeaveRequest {
public:
    LeaveRequest(string name, int days) : m_name(name), m_days(days) {}
    string getName() { return m_name; }
    int getDays() { return m_days; }
};

// 处理者抽象类
class Handler {
public:
    Handler(Handler* next = nullptr) : m_next(next) {}
    virtual void handleRequest(LeaveRequest request) = 0;
protected:
    Handler* m_next;
};

// 具体处理者：组长
class GroupLeaderHandler : public Handler {
public:
    GroupLeaderHandler(Handler* next = nullptr) : Handler(next) {}
    void handleRequest(LeaveRequest request) override {
        if (request.getDays() <= 1) {
            cout << "组长批准" << request.getName() << "请假" << request.getDays() << "天" << endl;
        } else if (m_next) {
            m_next->handleRequest(request);
        }
    }
};

// 具体处理者：经理
class ManagerHandler : public Handler {
public:
    ManagerHandler(Handler* next = nullptr) : Handler(next) {}
    void handleRequest(LeaveRequest request) override {
        if (request.getDays() <= 3) {
            cout << "经理批准" << request.getName() << "请假" << request.getDays() << "天" << endl;
        } else if (m_next) {
            m_next->handleRequest(request);
        }
    }
};

// 具体处理者：总监
class DirectorHandler : public Handler {
public:
    DirectorHandler(Handler* next = nullptr) : Handler(next) {}
    void handleRequest(LeaveRequest request) override {
        if (request.getDays() <= 5) {
            cout << "总监批准" << request.getName() << "请假" << request.getDays() << "天" << endl;
        } else if (m_next) {
            m_next->handleRequest(request);
        }
    }
};

int main() {
    Handler* groupLeader = new GroupLeaderHandler();
    Handler* manager = new ManagerHandler(groupLeader);
    Handler* director = new DirectorHandler(manager);
    
    director->handleRequest(LeaveRequest("张三", 1));
    director->handleRequest(LeaveRequest("李四", 3));
    director->handleRequest(LeaveRequest("王五", 5));
    director->handleRequest(LeaveRequest("赵六", 10));
    
    delete groupLeader;
    delete manager;
    delete director;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.3.2 命令模式（Command）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>命令模式将"请求"封装成对象（比如遥控器，每个按钮对应一个命令，按按钮就是执行命令，可记录、撤销）。核心是命令对象包含接收者和执行动作，调用者只需调用命令的执行方法。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++命令模式</div>
                                        <pre><code>#include <iostream>
using namespace std;

// 接收者：灯
class Light {
public:
    void on() { cout << "灯打开" << endl; }
    void off() { cout << "灯关闭" << endl; }
};

// 接收者：电视
class Television {
public:
    void on() { cout << "电视打开" << endl; }
    void off() { cout << "电视关闭" << endl; }
};

// 抽象命令
class Command {
public:
    virtual void execute() = 0;
    virtual void undo() = 0;
    virtual ~Command() = default;
};

// 具体命令：开灯命令
class LightOnCommand : public Command {
private:
    Light* m_light;
public:
    LightOnCommand(Light* light) : m_light(light) {}
    void execute() override {
        m_light->on();
    }
    void undo() override {
        m_light->off();
    }
};

// 具体命令：关灯命令
class LightOffCommand : public Command {
private:
    Light* m_light;
public:
    LightOffCommand(Light* light) : m_light(light) {}
    void execute() override {
        m_light->off();
    }
    void undo() override {
        m_light->on();
    }
};

// 调用者：遥控器
class RemoteControl {
private:
    Command* m_command;
public:
    RemoteControl() : m_command(nullptr) {}
    void setCommand(Command* command) {
        m_command = command;
    }
    void pressButton() {
        if (m_command) {
            m_command->execute();
        }
    }
    void pressUndoButton() {
        if (m_command) {
            m_command->undo();
        }
    }
};

int main() {
    Light* light = new Light();
    Television* tv = new Television();
    
    LightOnCommand* lightOn = new LightOnCommand(light);
    LightOffCommand* lightOff = new LightOffCommand(light);
    
    RemoteControl* remote = new RemoteControl();
    
    remote->setCommand(lightOn);
    remote->pressButton();
    
    remote->setCommand(lightOff);
    remote->pressButton();
    
    delete light;
    delete tv;
    delete lightOn;
    delete lightOff;
    delete remote;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.3.3 解释器模式（Interpreter）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>解释器模式定义"语言语法"的解释器（比如简单的计算器，解析"1+2*3"这样的表达式）。核心是用类表示语法规则，递归解析表达式。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++解释器模式</div>
                                        <pre><code>#include <iostream>
#include <string>
#include <memory>
using namespace std;

// 抽象表达式
class Expression {
public:
    virtual int interpret() = 0;
    virtual ~Expression() = default;
};

// 数字表达式
class NumberExpression : public Expression {
private:
    int m_value;
public:
    NumberExpression(int value) : m_value(value) {}
    int interpret() override {
        return m_value;
    }
};

// 加法表达式
class AddExpression : public Expression {
private:
    Expression* m_left;
    Expression* m_right;
public:
    AddExpression(Expression* left, Expression* right) : m_left(left), m_right(right) {}
    int interpret() override {
        return m_left->interpret() + m_right->interpret();
    }
    ~AddExpression() {
        delete m_left;
        delete m_right;
    }
};

// 减法表达式
class SubtractExpression : public Expression {
private:
    Expression* m_left;
    Expression* m_right;
public:
    SubtractExpression(Expression* left, Expression* right) : m_left(left), m_right(right) {}
    int interpret() override {
        return m_left->interpret() - m_right->interpret();
    }
    ~SubtractExpression() {
        delete m_left;
        delete m_right;
    }
};

// 表达式解析器
class ExpressionParser {
public:
    static unique_ptr<Expression> parse(string expression) {
        // 简化实现，只支持数字和加减
        int pos = 0;
        unique_ptr<Expression> left = parseTerm(expression, pos);
        
        while (pos < expression.length()) {
            char op = expression[pos++];
            if (op == '+' || op == '-') {
                unique_ptr<Expression> right = parseTerm(expression, pos);
                if (op == '+') {
                    left = make_unique<AddExpression>(left.release(), right.release());
                } else {
                    left = make_unique<SubtractExpression>(left.release(), right.release());
                }
            } else {
                throw runtime_error("非法操作符: " + string(1, op));
            }
        }
        return left;
    }
    
private:
    static unique_ptr<Expression> parseTerm(string& expression, int& pos) {
        // 解析数字
        int value = 0;
        while (pos < expression.length() && isdigit(expression[pos])) {
            value = value * 10 + (expression[pos++] - '0');
        }
        return make_unique<NumberExpression>(value);
    }
};

int main() {
    string expression = "10 + 5 - 3 + 2";
    try {
        unique_ptr<Expression> exp = ExpressionParser::parse(expression);
        int result = exp->interpret();
        cout << "表达式 " << expression << " = " << result << endl;
    } catch (exception& e) {
        cout << "解析错误: " << e.what() << endl;
    }
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.3.4 迭代器模式（Iterator）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>迭代器模式统一"遍历集合"的方式（比如遍历数组、链表、哈希表，用同样的方法：hasNext()、next()）。核心是将集合的遍历逻辑抽离到迭代器中，集合只负责存储数据。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++迭代器模式</div>
                                        <pre><code>#include <iostream>
#include <vector>
using namespace std;

// 抽象迭代器
template<typename T>
class Iterator {
public:
    virtual bool hasNext() = 0;
    virtual T next() = 0;
    virtual ~Iterator() = default;
};

// 具体迭代器：数组迭代器
template<typename T>
class ArrayIterator : public Iterator<T> {
private:
    vector<T>* m_array;
    int m_index;
public:
    ArrayIterator(vector<T>* array) : m_array(array), m_index(0) {}
    bool hasNext() override {
        return m_index < m_array->size();
    }
    T next() override {
        if (hasNext()) {
            return (*m_array)[m_index++];
        }
        throw out_of_range("迭代器越界");
    }
};

// 集合接口
template<typename T>
class Container {
public:
    virtual Iterator<T>* createIterator() = 0;
    virtual ~Container() = default;
};

// 具体集合：数组容器
template<typename T>
class ArrayContainer : public Container<T> {
private:
    vector<T> m_elements;
public:
    void add(T element) {
        m_elements.push_back(element);
    }
    Iterator<T>* createIterator() override {
        return new ArrayIterator<T>(&m_elements);
    }
};

int main() {
    ArrayContainer<int>* container = new ArrayContainer<int>();
    container->add(1);
    container->add(2);
    container->add(3);
    container->add(4);
    container->add(5);
    
    Iterator<int>* iterator = container->createIterator();
    
    cout << "遍历集合：";
    while (iterator->hasNext()) {
        cout << iterator->next() << " ";
    }
    cout << endl;
    
    delete iterator;
    delete container;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.3.5 中介者模式（Mediator）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>中介者模式用"中介者"协调多个对象的交互（比如机场塔台，飞机之间不直接通信，都通过塔台协调，避免混乱）。核心是中介者封装对象间的交互逻辑，对象只和中介者通信。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++中介者模式</div>
                                        <pre><code>#include <iostream>
#include <string>
#include <vector>
using namespace std;

// 中介者接口
class Mediator {
public:
    virtual void registerColleague(Colleague* colleague) = 0;
    virtual void sendMessage(string message, Colleague* sender) = 0;
    virtual ~Mediator() = default;
};

// 同事类（抽象）
class Colleague {
protected:
    Mediator* m_mediator;
public:
    Colleague(Mediator* mediator) : m_mediator(mediator) {}
    virtual void receiveMessage(string message) = 0;
    virtual void sendMessage(string message) = 0;
};

// 具体同事：飞机A
class AircraftA : public Colleague {
public:
    AircraftA(Mediator* mediator) : Colleague(mediator) {}
    void receiveMessage(string message) override {
        cout << "飞机A收到消息：" << message << endl;
    }
    void sendMessage(string message) override {
        cout << "飞机A发送消息：" << message << endl;
        m_mediator->sendMessage(message, this);
    }
};

// 具体同事：飞机B
class AircraftB : public Colleague {
public:
    AircraftB(Mediator* mediator) : Colleague(mediator) {}
    void receiveMessage(string message) override {
        cout << "飞机B收到消息：" << message << endl;
    }
    void sendMessage(string message) override {
        cout << "飞机B发送消息：" << message << endl;
        m_mediator->sendMessage(message, this);
    }
};

// 具体中介者：塔台
class TowerMediator : public Mediator {
private:
    vector<Colleague*> m_colleagues;
public:
    void registerColleague(Colleague* colleague) override {
        m_colleagues.push_back(colleague);
    }
    void sendMessage(string message, Colleague* sender) override {
        for (auto& colleague : m_colleagues) {
            if (colleague != sender) {
                colleague->receiveMessage(message);
            }
        }
    }
};

int main() {
    TowerMediator* tower = new TowerMediator();
    AircraftA* aircraftA = new AircraftA(tower);
    AircraftB* aircraftB = new AircraftB(tower);
    
    tower->registerColleague(aircraftA);
    tower->registerColleague(aircraftB);
    
    aircraftA->sendMessage("请求降落");
    aircraftB->sendMessage("请求起飞");
    
    delete tower;
    delete aircraftA;
    delete aircraftB;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.3.6 备忘录模式（Memento）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>备忘录模式保存对象的"历史状态"，以便后续恢复（比如游戏存档，死前存档，死后读档回到之前状态）。核心是备忘录存储状态，原发器创建/恢复备忘录，负责人管理备忘录。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++备忘录模式</div>
                                        <pre><code>#include <iostream>
#include <string>
#include <vector>
using namespace std;

// 备忘录类
class Memento {
private:
    string m_state;
public:
    Memento(string state) : m_state(state) {}
    string getState() { return m_state; }
};

// 原发器类
class Originator {
private:
    string m_state;
public:
    Originator(string state) : m_state(state) {}
    Memento* createMemento() {
        return new Memento(m_state);
    }
    void restoreMemento(Memento* memento) {
        m_state = memento->getState();
    }
    void setState(string state) {
        m_state = state;
        cout << "设置状态为：" << m_state << endl;
    }
    string getState() {
        return m_state;
    }
};

// 负责人类
class Caretaker {
private:
    vector<Memento*> m_mementos;
public:
    void addMemento(Memento* memento) {
        m_mementos.push_back(memento);
    }
    Memento* getMemento(int index) {
        if (index >= 0 && index < m_mementos.size()) {
            return m_mementos[index];
        }
        return nullptr;
    }
    ~Caretaker() {
        for (auto& memento : m_mementos) {
            delete memento;
        }
    }
};

int main() {
    Originator* originator = new Originator("状态1");
    Caretaker* caretaker = new Caretaker();
    
    caretaker->addMemento(originator->createMemento());
    originator->setState("状态2");
    caretaker->addMemento(originator->createMemento());
    originator->setState("状态3");
    caretaker->addMemento(originator->createMemento());
    
    originator->restoreMemento(caretaker->getMemento(1));
    cout << "恢复到状态：" << originator->getState() << endl;
    
    originator->restoreMemento(caretaker->getMemento(0));
    cout << "恢复到状态：" << originator->getState() << endl;
    
    delete originator;
    delete caretaker;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="subsection">
                                <div class="subsection-title">4.3.7 观察者模式（Observer）</div>
                                <div class="content-body">
                                    <p><strong>概念与特点：</strong>观察者模式实现"一个变，多个跟着变"（比如微信公众号，作者发文章，所有订阅者都收到推送）。</p>
                                    <div class="code-block">
                                        <div class="code-header">C++观察者模式</div>
                                        <pre><code>#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 观察者接口
class Observer {
public:
    virtual void update(string message) = 0;
    virtual ~Observer() = default;
};

// 具体观察者：用户
class User : public Observer {
private:
    string m_name;
public:
    User(string name) : m_name(name) {}
    void update(string message) override {
        cout << m_name << " 收到消息: " << message << endl;
    }
};

// 主题接口
class Subject {
public:
    virtual void attach(Observer* observer) = 0;
    virtual void detach(Observer* observer) = 0;
    virtual void notify(string message) = 0;
    virtual ~Subject() = default;
};

// 具体主题：公众号
class PublicAccount : public Subject {
private:
    vector<Observer*> m_observers;
public:
    void attach(Observer* observer) override {
        m_observers.push_back(observer);
    }
    void detach(Observer* observer) override {
        auto it = find(m_observers.begin(), m_observers.end(), observer);
        if (it != m_observers.end()) {
            m_observers.erase(it);
        }
    }
    void notify(string message) override {
        for (auto& observer : m_observers) {
            observer->update(message);
        }
    }
};

int main() {
    PublicAccount* account = new PublicAccount();
    User* user1 = new User("张三");
    User* user2 = new User("李四");
    User* user3 = new User("王五");
    
    account->attach(user1);
    account->attach(user2);
    account->attach(user3);
    
    account->notify("新文章发布：C++设计模式详解");
    
    account->detach(user2);
    account->notify("新文章发布：编程范式比较");
    
    delete account;
    delete user1;
    delete user2;
    delete user3;
    return 0;
}</code></pre>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>编程范式与设计模式技术文档 &copy; 2023</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 获取所有章节标题
            const chapterTitles = document.querySelectorAll('.chapter-title');
            const sectionTitles = document.querySelectorAll('.section-title');
            const subsectionTitles = document.querySelectorAll('.subsection-title');
            
            // 章节标题点击事件
            chapterTitles.forEach(title => {
                title.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const isActive = this.classList.contains('active');
                    
                    // 切换活动状态
                    this.classList.toggle('active');
                    
                    // 显示或隐藏内容
                    if (isActive) {
                        content.classList.remove('active');
                    } else {
                        content.classList.add('active');
                    }
                });
            });
            
            // 小节标题点击事件
            sectionTitles.forEach(title => {
                title.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const isActive = this.classList.contains('active');
                    
                    // 切换活动状态
                    this.classList.toggle('active');
                    
                    // 显示或隐藏内容
                    if (isActive) {
                        content.classList.remove('active');
                    } else {
                        content.classList.add('active');
                    }
                });
            });
            
            // 子小节标题点击事件
            subsectionTitles.forEach(title => {
                title.addEventListener('click', function() {
                    const content = this.nextElementSibling;
                    const isActive = this.classList.contains('active');
                    
                    // 切换活动状态
                    this.classList.toggle('active');
                    
                    // 显示或隐藏内容
                    if (isActive) {
                        content.classList.remove('active');
                    } else {
                        content.classList.add('active');
                    }
                });
            });
            
            // 默认展开第一章节
            if (chapterTitles.length > 0) {
                chapterTitles[0].classList.add('active');
                chapterTitles[0].nextElementSibling.classList.add('active');
            }
        });
    </script>
</body>
</html>