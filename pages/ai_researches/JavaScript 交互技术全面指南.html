<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript 交互技术全面指南</title>
    <style>
        :root {
            --primary-color: #4a6fa5;
            --secondary-color: #6b8cbc;
            --accent-color: #ff6b6b;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f5f7fa;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            background: white;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
        }

        .tab {
            padding: 15px 25px;
            background: white;
            border: none;
            cursor: pointer;
            flex: 1;
            text-align: center;
            font-weight: 600;
            transition: var(--transition);
        }

        .tab:hover {
            background: #e9ecef;
        }

        .tab.active {
            background: var(--primary-color);
            color: white;
        }

        .tab-content {
            display: none;
            padding: 30px;
            background: white;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--box-shadow);
        }

        .tab-content.active {
            display: block;
        }

        h2 {
            color: var(--primary-color);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e9ecef;
        }

        h3 {
            color: var(--secondary-color);
            margin: 25px 0 15px;
        }

        .section {
            margin-bottom: 40px;
        }

        .accordion {
            margin: 20px 0;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .accordion-header {
            padding: 15px 20px;
            background: var(--light-color);
            border: none;
            width: 100%;
            text-align: left;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: var(--transition);
        }

        .accordion-header:hover {
            background: #e9ecef;
        }

        .accordion-header::after {
            content: '+';
            font-size: 1.5rem;
            transition: var(--transition);
        }

        .accordion-header.active::after {
            content: '-';
        }

        .accordion-content {
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
            background: white;
        }

        .accordion-content.active {
            padding: 20px;
            max-height: 1000px;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: var(--border-radius);
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.5;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            border-radius: var(--border-radius);
            overflow: hidden;
        }

        .comparison-table th, .comparison-table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        .comparison-table th {
            background: var(--primary-color);
            color: white;
        }

        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .comparison-table tr:hover {
            background: #e9ecef;
        }

        .example-box {
            background: #f8f9fa;
            border-left: 4px solid var(--accent-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
        }

        .example-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--dark-color);
        }

        .demo-container {
            margin: 25px 0;
            padding: 20px;
            background: white;
            border-radius: var(--border-radius);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .demo-button {
            padding: 10px 20px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            font-weight: 600;
        }

        .demo-button:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
        }

        .demo-element {
            padding: 15px;
            margin: 15px 0;
            background: #e9ecef;
            border-radius: var(--border-radius);
            transition: var(--transition);
        }

        .highlight {
            background-color: #fff3cd;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: 600;
        }

        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px;
            color: #6c757d;
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .tabs {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>JavaScript 交互技术全面指南</h1>
            <p class="subtitle">从基础事件处理到高级交互模式，深入理解JavaScript交互技术</p>
        </header>

        <div class="tabs">
            <button class="tab active" data-tab="basics">交互基础</button>
            <button class="tab" data-tab="syntax">语法解析</button>
            <button class="tab" data-tab="implementations">效果实现</button>
        </div>

        <div class="tab-content active" id="basics">
            <div class="section">
                <h2>1. JavaScript 交互基础方法</h2>
                
                <div class="accordion">
                    <button class="accordion-header">1.1 事件监听机制与 DOM 操作</button>
                    <div class="accordion-content">
                        <p>JavaScript 交互的核心在于事件监听机制和 DOM（文档对象模型）操作的结合。事件监听允许网页对用户的各种操作做出响应，而 DOM 操作则提供了动态修改页面内容的能力。</p>
                        
                        <p>在 JavaScript 中，最常用的事件监听方法是 <span class="highlight">addEventListener()</span>。这个方法为指定元素添加事件监听器，当指定的事件发生时，调用关联的处理函数。</p>
                        
                        <div class="code-block">
// addEventListener 基本语法
element.addEventListener(eventType, listener, options);
                        </div>
                        
                        <p>其中，<span class="highlight">eventType</span> 是事件类型字符串（如 'click'、'keydown'、'scroll'），<span class="highlight">listener</span> 是事件触发时执行的回调函数，<span class="highlight">options</span> 是可选的配置对象。</p>
                        
                        <div class="example-box">
                            <div class="example-title">示例：使用 addEventListener 添加多个事件监听器</div>
                            <div class="code-block">
// 为按钮添加多个点击事件监听器
const button = document.getElementById('myButton');

button.addEventListener('click', function() {
    console.log('第一个事件监听器被触发');
});

button.addEventListener('click', function() {
    console.log('第二个事件监听器被触发');
});
                            </div>
                        </div>
                        
                        <p>除了 addEventListener()，JavaScript 还提供了其他事件绑定方式，包括 HTML 属性绑定（如 &lt;button onclick="handleClick()"&gt;）和 DOM 属性绑定（如 button.onclick = handleClick）。但这些方式都有各自的局限性，addEventListener() 是目前最推荐的标准方式。</p>
                        
                        <h3>常用 DOM 操作方法</h3>
                        <ul>
                            <li><span class="highlight">document.getElementById()</span>：通过 ID 获取元素</li>
                            <li><span class="highlight">document.getElementsByTagName()</span>：通过标签名获取元素集合</li>
                            <li><span class="highlight">document.getElementsByClassName()</span>：通过类名获取元素集合</li>
                            <li><span class="highlight">document.querySelector()</span> 和 <span class="highlight">document.querySelectorAll()</span>：通过 CSS 选择器获取元素</li>
                        </ul>
                        
                        <div class="code-block">
// 获取元素后，可以通过以下方式修改其内容和属性

// 修改文本内容
element.textContent = "新的文本内容";

// 修改 HTML 内容
element.innerHTML = "&lt;strong&gt;新的 HTML 内容&lt;/strong&gt;";

// 修改样式
element.style.color = "red";
element.style.fontSize = "20px";

// 修改属性
element.setAttribute("href", "https://example.com");
                        </div>
                    </div>
                </div>
                
                <div class="accordion">
                    <button class="accordion-header">1.2 事件类型详解</button>
                    <div class="accordion-content">
                        <p>JavaScript 支持多种类型的事件，涵盖了用户与页面交互的各个方面。</p>
                        
                        <h3>鼠标事件</h3>
                        <ul>
                            <li><span class="highlight">click</span>：鼠标点击时触发</li>
                            <li><span class="highlight">dblclick</span>：鼠标双击时触发</li>
                            <li><span class="highlight">mousedown</span>：鼠标按键按下时触发</li>
                            <li><span class="highlight">mouseup</span>：鼠标按键释放时触发</li>
                            <li><span class="highlight">mouseenter</span>：鼠标进入元素时触发（不会冒泡）</li>
                            <li><span class="highlight">mouseleave</span>：鼠标离开元素时触发（不会冒泡）</li>
                            <li><span class="highlight">mousemove</span>：鼠标在元素内移动时触发</li>
                        </ul>
                        
                        <h3>键盘事件</h3>
                        <p>用于监听键盘输入：</p>
                        <ul>
                            <li><span class="highlight">keydown</span>：键盘按键按下时触发</li>
                            <li><span class="highlight">keypress</span>：按下字符键时触发（已逐渐被弃用）</li>
                            <li><span class="highlight">keyup</span>：键盘按键释放时触发</li>
                        </ul>
                        
                        <p>在键盘事件处理函数中，可以通过 <span class="highlight">event.key</span> 属性获取按下的键名，通过 <span class="highlight">event.ctrlKey</span>、<span class="highlight">event.shiftKey</span>、<span class="highlight">event.altKey</span> 和 <span class="highlight">event.metaKey</span> 判断是否按下了修饰键。</p>
                        
                        <h3>表单事件</h3>
                        <p>专门用于表单元素：</p>
                        <ul>
                            <li><span class="highlight">submit</span>：表单提交时触发</li>
                            <li><span class="highlight">reset</span>：表单重置时触发</li>
                            <li><span class="highlight">input</span>：输入框内容改变时触发</li>
                            <li><span class="highlight">change</span>：表单元素值改变时触发</li>
                            <li><span class="highlight">focus</span>：元素获得焦点时触发</li>
                            <li><span class="highlight">blur</span>：元素失去焦点时触发</li>
                        </ul>
                        
                        <h3>窗口和文档事件</h3>
                        <ul>
                            <li><span class="highlight">load</span>：页面加载完成时触发</li>
                            <li><span class="highlight">resize</span>：窗口大小改变时触发</li>
                            <li><span class="highlight">scroll</span>：页面滚动时触发</li>
                            <li><span class="highlight">DOMContentLoaded</span>：DOM 解析完成时触发</li>
                        </ul>
                    </div>
                </div>
                
                <div class="accordion">
                    <button class="accordion-header">1.3 事件对象与事件流</button>
                    <div class="accordion-content">
                        <p><span class="highlight">事件对象（Event Object）</span>是事件处理函数的参数，包含了事件的所有相关信息。通过事件对象，我们可以获取触发事件的元素、鼠标位置、键盘状态等信息。</p>
                        
                        <h3>事件对象的常用属性</h3>
                        <ul>
                            <li><span class="highlight">event.type</span>：事件类型</li>
                            <li><span class="highlight">event.target</span>：触发事件的元素（事件源）</li>
                            <li><span class="highlight">event.currentTarget</span>：绑定事件监听器的元素</li>
                            <li><span class="highlight">event.clientX</span> 和 <span class="highlight">event.clientY</span>：鼠标相对于视口的坐标</li>
                            <li><span class="highlight">event.key</span>：按下的键名（键盘事件）</li>
                            <li><span class="highlight">event.which</span>：按下的键码（已逐渐被弃用）</li>
                        </ul>
                        
                        <h3>事件流</h3>
                        <p>事件流描述了事件在页面中的传播路径。根据 W3C 标准，事件传播分为三个阶段：</p>
                        <ol>
                            <li><span class="highlight">捕获阶段</span>：事件从最外层元素（window）开始，逐级向内传播到目标元素</li>
                            <li><span class="highlight">目标阶段</span>：事件到达目标元素本身</li>
                            <li><span class="highlight">冒泡阶段</span>：事件从目标元素开始，逐级向外传播到最外层元素</li>
                        </ol>
                        
                        <p>在实际开发中，我们通常在冒泡阶段处理事件。可以通过设置 addEventListener() 的第三个参数为 true 来在捕获阶段处理事件。</p>
                        
                        <div class="example-box">
                            <div class="example-title">示例：事件捕获与冒泡</div>
                            <div class="code-block">
// 捕获阶段处理事件
document.getElementById('outer').addEventListener('click', function() {
    console.log('捕获阶段：外部元素');
}, true);

// 冒泡阶段处理事件（默认）
document.getElementById('inner').addEventListener('click', function() {
    console.log('冒泡阶段：内部元素');
});
                            </div>
                        </div>
                        
                        <p>事件冒泡机制可以用于实现<span class="highlight">事件委托</span>，这是一种高效的事件处理模式。通过将事件监听器绑定到父元素，而不是每个子元素，可以处理大量子元素的事件，提高性能并简化代码。</p>
                    </div>
                </div>
                
                <div class="accordion">
                    <button class="accordion-header">1.4 事件委托与高级事件处理</button>
                    <div class="accordion-content">
                        <p><span class="highlight">事件委托</span>是利用事件冒泡机制，将子元素的事件委托给父元素处理的技术。这种方法特别适用于处理动态生成的元素，因为不需要为每个新生成的元素单独绑定事件监听器。</p>
                        
                        <h3>实现事件委托的基本步骤</h3>
                        <ol>
                            <li>将事件监听器绑定到父元素</li>
                            <li>在事件处理函数中，通过 event.target 判断实际触发事件的元素</li>
                            <li>根据条件执行相应的操作</li>
                        </ol>
                        
                        <div class="example-box">
                            <div class="example-title">示例：处理列表项的点击事件</div>
                            <div class="code-block">
const list = document.getElementById('list');

list.addEventListener('click', function(event) {
    if (event.target.tagName === 'LI') {
        console.log('点击了列表项:', event.target.textContent);
    }
});
                            </div>
                        </div>
                        
                        <h3>事件委托的优势</h3>
                        <ul>
                            <li>只需要一个事件监听器，减少内存占用</li>
                            <li>自动处理动态添加的子元素</li>
                            <li>简化了事件管理逻辑</li>
                        </ul>
                        
                        <h3>高级事件处理技术</h3>
                        
                        <p><span class="highlight">event.preventDefault()</span>：阻止事件的默认行为。例如，阻止链接跳转或表单提交：</p>
                        <div class="code-block">
link.addEventListener('click', function(event) {
    event.preventDefault();
    console.log('链接被点击，但不会跳转');
});
                        </div>
                        
                        <p><span class="highlight">event.stopPropagation()</span>：阻止事件继续传播，包括冒泡和捕获：</p>
                        <div class="code-block">
element.addEventListener('click', function(event) {
    event.stopPropagation();
    console.log('事件已被阻止传播');
});
                        </div>
                        
                        <h3>事件委托的应用场景</h3>
                        <ul>
                            <li>处理大量列表项的点击事件</li>
                            <li>处理动态生成的表单元素</li>
                            <li>实现可点击的表格单元格</li>
                            <li>创建复杂的用户界面交互</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-content" id="syntax">
            <div class="section">
                <h2>2. JavaScript 语法深度解析与语言对比</h2>
                
                <div class="accordion">
                    <button class="accordion-header">2.1 JavaScript 语法基础与 ES6+ 新特性</button>
                    <div class="accordion-content">
                        <p>JavaScript 的语法基础包含变量声明、数据类型、运算符、流程控制语句和函数等核心概念。</p>
                        
                        <h3>变量声明</h3>
                        <p>变量声明是 JavaScript 编程的基础。ES6 引入了 <span class="highlight">let</span> 和 <span class="highlight">const</span> 关键字，与传统的 <span class="highlight">var</span> 形成了完整的变量声明体系：</p>
                        
                        <table class="comparison-table">
                            <thead>
                                <tr>
                                    <th>关键字</th>
                                    <th>作用域</th>
                                    <th>变量提升</th>
                                    <th>特点</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>var</td>
                                    <td>函数作用域</td>
                                    <td>存在</td>
                                    <td>可重复声明，可重新赋值</td>
                                </tr>
                                <tr>
                                    <td>let</td>
                                    <td>块级作用域</td>
                                    <td>不存在</td>
                                    <td>不可重复声明，可重新赋值</td>
                                </tr>
                                <tr>
                                    <td>const</td>
                                    <td>块级作用域</td>
                                    <td>不存在</td>
                                    <td>不可重复声明，不可重新赋值</td>
                                </tr>
                            </tbody>
                        </table>
                        
                        <h3>ES6+ 新特性</h3>
                        
                        <p><span class="highlight">箭头函数</span>提供了更简洁的函数定义方式：</p>
                        <div class="code-block">
// 传统函数
function add(a, b) { return a + b; }

// 箭头函数
const add = (a, b) => a + b;

// 多行函数体
const multiply = (a, b) => {
    return a * b;
};

// 无参数函数
const greet = () => console.log('Hello');

// 单个参数可以省略括号
const square = x => x * x;
                        </div>
                        
                        <p><span class="highlight">箭头函数的特点</span>：</p>
                        <ul>
                            <li>没有自己的 this，继承外层作用域的 this</li>
                            <li>没有 arguments 对象，可用剩余参数替代</li>
                            <li>不能用作构造函数</li>
                            <li>更适合用于回调函数和函数式编程</li>
                        </ul>
                        
                        <p><span class="highlight">解构赋值</span>允许从数组或对象中提取值并赋给变量：</p>
                        <div class="code-block">
// 数组解构
const numbers = [1, 2, 3];
const [a, b, c] = numbers;
console.log(a, b, c); // 1 2 3

// 对象解构
const person = { name: 'Alice', age: 30 };
const { name, age } = person;
console.log(name, age); // Alice 30

// 嵌套解构
const nested = { a: { b: { c: 42 } } };
const { a: { b: { c } } } = nested;
console.log(c); // 42

// 默认值
const { city = 'Beijing' } = person;
console.log(city); // Beijing
                        </div>
                        
                        <p><span class="highlight">模板字符串</span>提供了更灵活的字符串处理方式：</p>
                        <div class="code-block">
const name = 'Alice';
const age = 30;

// 字符串插值
console.log(`姓名：${name}，年龄：${age}`);

// 多行字符串
const message = `第一行
第二行
第三行`;

// 标签模板
function html(strings, ...values) {
    return strings.reduce((acc, str, i) => {
        return acc + str + (values[i] || '');
    }, '');
}

const userHtml = html`<div>${name}</div><div>${age}</div>`;
                        </div>
                        
                        <p><span class="highlight">Promise</span>解决了回调地狱问题，提供了更优雅的异步编程方式：</p>
                        <div class="code-block">
const fetchData = () => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const data = { result: 'success' };
            resolve(data);
        }, 1000);
    });
};

fetchData()
    .then(data => {
        console.log(data);
    })
    .catch(error => {
        console.error(error);
    });
                        </div>
                        
                        <p><span class="highlight">async/await</span>是基于 Promise 的语法糖，使异步代码看起来像同步代码：</p>
                        <div class="code-block">
async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error(error);
    }
}
                        </div>
                    </div>
                </div>
                
                <div class="accordion">
                    <button class="accordion-header">2.2 JavaScript 与 Java 的语法对比分析</button>
                    <div class="accordion-content">
                        <p>JavaScript 和 Java 在名称上相似，但实际上是两种完全不同的编程语言，它们在语法、运行机制和应用场景等方面存在显著差异。</p>
                        
                        <h3>变量声明与类型系统</h3>
                        
                        <p><span class="highlight">Java</span>是静态类型语言，变量必须在声明时指定类型：</p>
                        <div class="code-block">
int age = 30;
String name = "Alice";
boolean isStudent = true;
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>是动态类型语言，变量类型由值决定，可以在运行时改变：</p>
                        <div class="code-block">
let age = 30;
let name = "Alice";
let isStudent = true;

// 可以重新赋值为不同类型
age = "thirty";
                        </div>
                        
                        <p>这种差异导致两种语言在编程思维上的根本不同。Java 的类型检查在编译时进行，而 JavaScript 的类型检查在运行时进行。</p>
                        
                        <h3>函数定义与作用域</h3>
                        
                        <p><span class="highlight">Java</span>使用类和方法：</p>
                        <div class="code-block">
public class MathUtils {
    public static int add(int a, int b) {
        return a + b;
    }
}
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>可以使用函数声明或表达式：</p>
                        <div class="code-block">
function add(a, b) {
    return a + b;
}

const add = (a, b) => a + b;
                        </div>
                        
                        <p>JavaScript 在 ES6 之前只有函数作用域，ES6 引入了块级作用域（let 和 const）。Java 则一直支持块级作用域。</p>
                        
                        <h3>面向对象机制</h3>
                        
                        <p><span class="highlight">Java</span>是纯粹的面向对象语言，所有代码必须写在类中：</p>
                        <div class="code-block">
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void sayHello() {
        System.out.println("Hello, my name is " + name);
    }
}
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>基于原型链实现面向对象：</p>
                        <div class="code-block">
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.sayHello = function() {
    console.log(`Hello, my name is ${this.name}`);
};

// ES6 类语法（基于原型的语法糖）
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    sayHello() {
        console.log(`Hello, my name is ${this.name}`);
    }
}
                        </div>
                        
                        <p>JavaScript 的类是 ES6 引入的语法糖，底层仍然基于原型链。这是与 Java 类继承机制的根本区别。</p>
                        
                        <h3>并发处理机制</h3>
                        
                        <p><span class="highlight">Java</span>内置多线程支持，通过 Thread 类和 Runnable 接口实现：</p>
                        <div class="code-block">
new Thread(() -> {
    // 执行耗时操作
}).start();
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>是单线程语言，通过事件循环实现异步操作：</p>
                        <div class="code-block">
setTimeout(() => {
    // 异步回调
}, 1000);
                        </div>
                        
                        <p>这种差异使得 JavaScript 在处理 I/O 密集型任务时表现优异，但在 CPU 密集型任务中不如 Java。</p>
                    </div>
                </div>
                
                <div class="accordion">
                    <button class="accordion-header">2.3 JavaScript 与 Python 的语法对比分析</button>
                    <div class="accordion-content">
                        <p>JavaScript 和 Python 都是动态类型语言，在某些方面有相似之处，但在语法风格和运行机制上存在明显差异。</p>
                        
                        <h3>变量声明与类型系统</h3>
                        
                        <p><span class="highlight">Python</span>使用 = 直接赋值，无需声明类型：</p>
                        <div class="code-block">
age = 30
name = "Alice"
is_student = True
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>在 ES6 后使用 let 和 const：</p>
                        <div class="code-block">
let age = 30;
const name = "Alice";
let isStudent = true;
                        </div>
                        
                        <p>两种语言都支持动态类型，但 Python 没有块级作用域（使用 if、for 等不会创建新作用域），而 JavaScript 的 let 和 const 支持块级作用域。</p>
                        
                        <h3>函数定义与语法风格</h3>
                        
                        <p><span class="highlight">Python</span>使用 def 关键字定义函数，使用缩进表示代码块：</p>
                        <div class="code-block">
def add(a, b):
    return a + b

def greet(name):
    print(f"Hello, {name}")
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>使用 function 或箭头函数，使用 {} 表示代码块：</p>
                        <div class="code-block">
function add(a, b) {
    return a + b;
}

const greet = (name) => {
    console.log(`Hello, ${name}`);
};
                        </div>
                        
                        <p>Python 的语法更注重可读性，强制使用缩进。JavaScript 的语法相对灵活，允许省略分号等。</p>
                        
                        <h3>数据结构</h3>
                        
                        <p><span class="highlight">Python</span>的列表和字典：</p>
                        <div class="code-block">
# 列表
list1 = [1, 2, 3]
list1.append(4)
print(list1)  # [1, 2, 3, 4]

# 字典
dict1 = {'name': 'Alice', 'age': 30}
print(dict1['name'])  # Alice
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>的数组和对象：</p>
                        <div class="code-block">
// 数组
const arr = [1, 2, 3];
arr.push(4);
console.log(arr); // [1, 2, 3, 4]

// 对象
const obj = { name: 'Alice', age: 30 };
console.log(obj.name); // Alice
                        </div>
                        
                        <p>两种语言的基本数据结构类似，但 JavaScript 的对象更灵活，可以动态添加属性和方法。</p>
                        
                        <h3>异步编程</h3>
                        
                        <p><span class="highlight">Python</span> 3.5+ 引入了 async/await：</p>
                        <div class="code-block">
import asyncio

async def fetch_data():
    await asyncio.sleep(1)
    return "data"
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>的 async/await：</p>
                        <div class="code-block">
async function fetchData() {
    await new Promise(resolve => setTimeout(resolve, 1000));
    return "data";
}
                        </div>
                        
                        <p>两种语言的异步编程语法相似，但 JavaScript 的事件循环机制与 Python 的异步 I/O 模型有所不同。</p>
                    </div>
                </div>
                
                <div class="accordion">
                    <button class="accordion-header">2.4 JavaScript 与 C++ 的语法对比分析</button>
                    <div class="accordion-content">
                        <p>C++ 和 JavaScript 在语法、运行机制和应用场景上存在巨大差异，理解这些差异对 C++ 开发者学习 JavaScript 至关重要。</p>
                        
                        <h3>类型系统与变量声明</h3>
                        
                        <p><span class="highlight">C++</span>是静态强类型语言，变量必须声明类型：</p>
                        <div class="code-block">
int age = 30;
const char* name = "Alice";
bool isStudent = true;
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>是动态弱类型语言：</p>
                        <div class="code-block">
let age = 30;
let name = "Alice";
let isStudent = true;

// 可以动态改变类型
age = "thirty";
                        </div>
                        
                        <p>这种差异意味着 C++ 开发者需要改变思维方式，不能依赖编译时类型检查，需要在运行时处理类型相关问题。</p>
                        
                        <h3>内存管理机制</h3>
                        
                        <p><span class="highlight">C++</span>需要手动管理内存，使用 new 和 delete：</p>
                        <div class="code-block">
int* p = new int(5);
delete p;

std::string* str = new std::string("Hello");
delete str;
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>自动进行垃圾回收，无需手动管理内存：</p>
                        <div class="code-block">
const obj = { key: "value" };
// 无需手动释放内存
                        </div>
                        
                        <p>这是两种语言的重要区别。C++ 开发者需要适应无需关心内存分配和释放的编程方式，但也要注意闭包等可能导致内存泄漏的情况。</p>
                        
                        <h3>面向对象机制</h3>
                        
                        <p><span class="highlight">C++</span>使用类和继承：</p>
                        <div class="code-block">
class Animal {
public:
    virtual void speak() { std::cout << "Animal speaks" << std::endl; }
};

class Dog : public Animal {
public:
    void speak() override { std::cout << "Woof!" << std::endl; }
};
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>基于原型链：</p>
                        <div class="code-block">
function Animal() {}
Animal.prototype.speak = function() {
    console.log("Animal speaks");
};

function Dog() {}
Dog.prototype = new Animal();
Dog.prototype.constructor = Dog;
Dog.prototype.speak = function() {
    console.log("Woof!");
};

// ES6 类语法
class Animal {
    speak() {
        console.log("Animal speaks");
    }
}

class Dog extends Animal {
    speak() {
        console.log("Woof!");
    }
}
                        </div>
                        
                        <p>JavaScript 的面向对象机制与 C++ 的类继承完全不同，需要重新理解原型链和基于原型的继承机制。</p>
                        
                        <h3>函数与作用域</h3>
                        
                        <p><span class="highlight">C++</span>的函数和作用域：</p>
                        <div class="code-block">
int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5;
    {
        int y = 10; // 块级作用域
    }
    // y 在此处不可用
    return 0;
}
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>在 ES6 前只有函数作用域，ES6 引入块级作用域：</p>
                        <div class="code-block">
function add(a, b) {
    return a + b;
}

{
    let x = 5; // 块级作用域
}
// x 在此处不可用
                        </div>
                        
                        <h3>运行环境与性能</h3>
                        
                        <p><span class="highlight">C++</span>是编译型语言，直接编译为机器码，性能极高：</p>
                        <div class="code-block">
// C++ 性能测试
#include <chrono>
#include <iostream>

int main() {
    auto start = std::chrono::high_resolution_clock::now();
    long sum = 0;
    for (long i = 0; i < 1000000000; ++i) {
        sum += i;
    }
    auto end = std::chrono::high_resolution_clock::now();
    std::cout << "Time: " << std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() << "ms" << std::endl;
    return 0;
}
                        </div>
                        
                        <p><span class="highlight">JavaScript</span>是解释型语言，通过 JavaScript 引擎执行：</p>
                        <div class="code-block">
// JavaScript 性能测试
const start = Date.now();
let sum = 0;
for (let i = 0; i < 1000000000; i++) {
    sum += i;
}
const end = Date.now();
console.log(`Time: ${end - start}ms`);
                        </div>
                        
                        <p>JavaScript 的执行速度通常比 C++ 慢 100-1000 倍，但现代 JavaScript 引擎（如 V8）通过 JIT 编译等技术大幅提升了性能。在实际应用中，JavaScript 更适合 I/O 密集型任务而非 CPU 密集型任务。</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-content" id="implementations">
            <div class="section">
                <h2>3. 基础交互效果实现</h2>
                
                <div class="accordion">
                    <button class="accordion-header">3.1 页面跳转与路由管理</button>
                    <div class="accordion-content">
                        <p>页面跳转是 Web 应用中最基本的交互功能之一。在 JavaScript 中，可以通过多种方式实现页面跳转和路由管理。</p>
                        
                        <h3>基本页面跳转方法</h3>
                        
                        <p>使用 &lt;a&gt; 标签：最传统的方式，通过 href 属性指定目标 URL</p>
                        <div class="code-block">
&lt;a href="https://example.com"&gt;跳转到示例网站&lt;/a&gt;
&lt;a href="/about"&gt;跳转到关于页面&lt;/a&gt;
&lt;a href="#section"&gt;跳转到页面内锚点&lt;/a&gt;
                        </div>
                        
                        <p>使用 <span class="highlight">window.location.href</span>：通过 JavaScript 动态改变当前页面的 URL</p>
                        <div class="code-block">
// 跳转到新页面
window.location.href = "https://example.com";

// 跳转到相对路径
window.location.href = "/about.html";

// 跳转到锚点
window.location.href = "#section2";
                        </div>
                        
                        <p>使用 <span class="highlight">window.open()</span>：打开新窗口或标签页</p>
                        <div class="code-block">
// 打开新窗口
window.open("https://example.com", "_blank");

// 打开指定窗口
window.open("https://example.com", "myWindow", "width=800,height=600");
                        </div>
                        
                        <h3>锚点跳转与页面内导航</h3>
                        
                        <p>锚点跳转允许在同一页面内快速定位到特定位置。实现步骤：</p>
                        
                        <ol>
                            <li>在目标位置添加 id 属性：</li>
                            <div class="code-block">
&lt;div id="section1"&gt;这是第一部分&lt;/div&gt;
                            </div>
                            
                            <li>创建指向该锚点的链接：</li>
                            <div class="code-block">
&lt;a href="#section1"&gt;跳转到第一部分&lt;/a&gt;
                            </div>
                            
                            <li>使用 JavaScript 实现平滑滚动效果：</li>
                            <div class="code-block">
document.querySelector('a[href="#section1"]').addEventListener('click', function(e) {
    e.preventDefault();
    const target = document.getElementById('section1');
    target.scrollIntoView({ behavior: 'smooth' });
});
                            </div>
                        </ol>
                        
                        <h3>单页应用（SPA）路由管理</h3>
                        
                        <p>现代 Web 应用越来越多地采用单页应用架构，通过 JavaScript 动态更新页面内容而不刷新整个页面。</p>
                        
                        <p>实现 SPA 路由的基本方法：</p>
                        
                        <p><span class="highlight">哈希路由（Hash Routing）</span>：利用 URL 中的哈希部分（# 后面的内容）</p>
                        <div class="code-block">
// 监听哈希变化
window.addEventListener('hashchange', function() {
    const hash = window.location.hash.substr(1);
    switch (hash) {
        case 'home':
            showHomePage();
            break;
        case 'about':
            showAboutPage();
            break;
        case 'contact':
            showContactPage();
            break;
        default:
            showHomePage();
    }
});

// 初始加载
window.addEventListener('load', function() {
    const hash = window.location.hash.substr(1) || 'home';
    showPage(hash);
});
                        </div>
                        
                        <p><span class="highlight">HTML5 历史 API（History API）</span>：使用 history.pushState() 和 history.replaceState()</p>
                        <div class="code-block">
// 跳转到新路由
function navigateTo(path) {
    history.pushState({}, '', path);
    showPage(path);
}

// 监听路由变化
window.addEventListener('popstate', function() {
    const path = window.location.pathname;
    showPage(path);
});
                        </div>
                        
                        <h3>路由框架推荐</h3>
                        
                        <p>对于复杂的单页应用，建议使用成熟的路由框架：</p>
                        <ul>
                            <li>React Router：用于 React 应用的路由管理</li>
                            <li>Vue Router：用于 Vue 应用的路由管理</li>
                            <li>Angular Router：用于 Angular 应用的路由管理</li>
                        </ul>
                        
                        <p>React Router：支持嵌套路由、路由参数、路由守卫等高级功能</p>
                    </div>
                </div>
                
                <div class="accordion">
                    <button class="accordion-header">3.2 按钮显示隐藏与状态切换</button>
                    <div class="accordion-content">
                        <p>按钮的显示隐藏和状态切换是 Web 应用中常见的交互效果，通过 JavaScript 可以轻松实现这些功能。</p>
                        
                        <h3>基本显示隐藏效果</h3>
                        
                        <p>通过修改元素的 <span class="highlight">style.display</span> 或 <span class="highlight">style.visibility</span> 属性可以控制元素的显示和隐藏。</p>
                        
                        <div class="code-block">
&lt;button id="toggleButton"&gt;切换显示&lt;/button&gt;
&lt;div id="targetElement"&gt;这是要显示/隐藏的内容&lt;/div&gt;

&lt;script&gt;
const button = document.getElementById('toggleButton');
const target = document.getElementById('targetElement');

button.addEventListener('click', function() {
    // 方法一：使用 display 属性
    if (target.style.display === 'none') {
        target.style.display = 'block';
    } else {
        target.style.display = 'none';
    }

    // 方法二：使用 visibility 属性（元素仍占据空间）
    if (target.style.visibility === 'hidden') {
        target.style.visibility = 'visible';
    } else {
        target.style.visibility = 'hidden';
    }

    // 方法三：使用 classList（推荐）
    target.classList.toggle('hidden');
});
&lt;/script&gt;
                        </div>
                        
                        <h3>使用 CSS 类实现样式切换</h3>
                        
                        <p>推荐使用 CSS 类来管理样式，这样可以保持样式与逻辑的分离：</p>
                        
                        <div class="code-block">
.hidden {
    display: none;
}

.disabled {
    opacity: 0.5;
    pointer-events: none;
}

&lt;script&gt;
const button = document.getElementById('myButton');

// 添加禁用状态
button.addEventListener('click', function() {
    button.classList.add('disabled');
    setTimeout(function() {
        button.classList.remove('disabled');
    }, 2000);
});

// 切换多个类
button.addEventListener('click', function() {
    button.classList.toggle('active');
    button.classList.toggle('pressed');
});
&lt;/script&gt;
                        </div>
                        
                        <h3>按钮状态管理</h3>
                        
                        <p>按钮可以有多种状态，如正常、按下、禁用、选中、加载中等。通过 JavaScript 可以动态切换这些状态。</p>
                        
                        <div class="code-block">
&lt;button id="submitButton" disabled&gt;提交&lt;/button&gt;
&lt;span id="loading" style="display: none;"&gt;加载中...&lt;/span&gt;

&lt;script&gt;
const button = document.getElementById('submitButton');
const loading = document.getElementById('loading');

button.addEventListener('click', function() {
    // 禁用按钮
    button.disabled = true;
    loading.style.display = 'inline';

    // 模拟异步操作
    setTimeout(function() {
        // 恢复按钮状态
        button.disabled = false;
        loading.style.display = 'none';
        
        // 显示成功消息
        alert('提交成功！');
    }, 2000);
});
&lt;/script&gt;
                        </div>
                        
                        <h3>动态创建按钮</h3>
                        
                        <p>通过 JavaScript 动态创建按钮并添加交互：</p>
                        
                        <div class="code-block">
function createButton(text, className) {
    const button = document.createElement('button');
    button.textContent = text;
    if (className) {
        button.className = className;
    }
    
    // 添加点击事件
    button.addEventListener('click', function() {
        alert(`点击了按钮：${text}`);
    });
    
    return button;
}

// 在页面中添加按钮
const container = document.getElementById('buttonContainer');
container.appendChild(createButton('按钮1', 'btn-primary'));
container.appendChild(createButton('按钮2', 'btn-secondary'));
                        </div>
                    </div>
                </div>
                
                <div class="accordion">
                    <button class="accordion-header">3.3 折叠菜单与面板效果</button>
                    <div class="accordion-content">
                        <p>折叠菜单和面板效果可以在有限的空间内展示大量信息，是 Web 设计中常用的交互模式。</p>
                        
                        <h3>简单折叠面板实现</h3>
                        
                        <p>使用 CSS 过渡和 JavaScript 实现平滑的折叠效果：</p>
                        
                        <div class="code-block">
&lt;button class="toggle-button"&gt;展开/收起&lt;/button&gt;
&lt;div class="panel"&gt;
    &lt;p&gt;这是折叠面板的内容。&lt;/p&gt;
    &lt;p&gt;可以包含任意内容，如文本、图片、表单等。&lt;/p&gt;
&lt;/div&gt;

&lt;style&gt;
.panel {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-out;
    background: #f0f0f0;
    padding: 10px;
    margin-top: 10px;
}

.panel.open {
    max-height: 500px; /* 足够大的值 */
}
&lt;/style&gt;

&lt;script&gt;
const toggleButton = document.querySelector('.toggle-button');
const panel = document.querySelector('.panel');

toggleButton.addEventListener('click', function() {
    panel.classList.toggle('open');
});
&lt;/script&gt;
                        </div>
                        
                        <h3>手风琴效果</h3>
                        
                        <p>手风琴效果允许多个面板存在，但同一时间只能展开一个：</p>
                        
                        <div class="code-block">
&lt;div class="accordion"&gt;
    &lt;div class="accordion-item"&gt;
        &lt;h3 class="accordion-header"&gt;标题1&lt;/h3&gt;
        &lt;div class="accordion-content"&gt;内容1&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="accordion-item"&gt;
        &lt;h3 class="accordion-header"&gt;标题2&lt;/h3&gt;
        &lt;div class="accordion-content"&gt;内容2&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
.accordion-item {
    margin-bottom: 5px;
    border: 1px solid #ccc;
}

.accordion-header {
    padding: 10px;
    background: #f0f0f0;
    cursor: pointer;
}

.accordion-content {
    max-height: 0;
    overflow: hidden;
    transition: max-height 0.3s ease-out;
    padding: 10px;
}

.accordion-content.open {
    max-height: 500px;
}
&lt;/style&gt;

&lt;script&gt;
const headers = document.querySelectorAll('.accordion-header');

headers.forEach(header => {
    header.addEventListener('click', function() {
        // 关闭所有面板
        const panels = document.querySelectorAll('.accordion-content');
        panels.forEach(panel => {
            panel.classList.remove('open');
        });
        
        // 打开当前面板
        const content = this.nextElementSibling;
        content.classList.add('open');
    });
});
&lt;/script&gt;
                        </div>
                        
                        <h3>多级折叠菜单</h3>
                        
                        <p>实现一个多级下拉菜单：</p>
                        
                        <div class="code-block">
&lt;ul class="menu"&gt;
    &lt;li&gt;&lt;a href="#"&gt;首页&lt;/a&gt;&lt;/li&gt;
    &lt;li class="has-submenu"&gt;
        &lt;a href="#"&gt;产品&lt;/a&gt;
        &lt;ul class="submenu"&gt;
            &lt;li&gt;&lt;a href="#"&gt;产品1&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href="#"&gt;产品2&lt;/a&gt;&lt;/li&gt;
            &lt;li class="has-submenu"&gt;
                &lt;a href="#"&gt;产品3&lt;/a&gt;
                &lt;ul class="submenu"&gt;
                    &lt;li&gt;&lt;a href="#"&gt;子产品1&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href="#"&gt;子产品2&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href="#"&gt;关于&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;style&gt;
.menu {
    list-style: none;
    padding: 0;
}

.menu li {
    position: relative;
}

.submenu {
    position: absolute;
    left: 100%;
    top: 0;
    width: 200px;
    background: #fff;
    border: 1px solid #ccc;
    display: none;
}

.menu li:hover > .submenu {
    display: block;
}
&lt;/style&gt;
                        </div>
                        
                        <h3>JavaScript 增强版折叠菜单</h3>
                        
                        <p>使用 JavaScript 实现更复杂的折叠效果：</p>
                        
                        <div class="code-block">
const menuItems = document.querySelectorAll('.has-submenu');

menuItems.forEach(item => {
    const trigger = item.querySelector('a');
    const submenu = item.querySelector('.submenu');
    
    trigger.addEventListener('click', function(e) {
        e.preventDefault();
        submenu.classList.toggle('visible');
    });
});

// 鼠标移入移出效果
menuItems.forEach(item => {
    const submenu = item.querySelector('.submenu');
    
    item.addEventListener('mouseenter', function() {
        submenu.classList.add('visible');
    });
    
    item.addEventListener('mouseleave', function() {
        setTimeout(function() {
            if (!item.matches(':hover')) {
                submenu.classList.remove('visible');
            }
        }, 200);
    });
});
                        </div>
                    </div>
                </div>
                
                <div class="accordion">
                    <button class="accordion-header">3.4 表单验证与交互处理</button>
                    <div class="accordion-content">
                        <p>表单验证是 Web 应用中确保数据合法性的重要机制，通过 JavaScript 可以实现实时的客户端验证。</p>
                        
                        <h3>基本表单验证</h3>
                        
                        <p>验证表单是否为空：</p>
                        
                        <div class="code-block">
&lt;form id="loginForm"&gt;
    &lt;div&gt;
        &lt;label&gt;用户名：&lt;/label&gt;
        &lt;input type="text" id="username" required&gt;
        &lt;span class="error-message" id="usernameError"&gt;&lt;/span&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label&gt;密码：&lt;/label&gt;
        &lt;input type="password" id="password" required minlength="6"&gt;
        &lt;span class="error-message" id="passwordError"&gt;&lt;/span&gt;
    &lt;/div&gt;
    &lt;button type="submit"&gt;登录&lt;/button&gt;
&lt;/form&gt;

&lt;script&gt;
const form = document.getElementById('loginForm');
const username = document.getElementById('username');
const password = document.getElementById('password');
const usernameError = document.getElementById('usernameError');
const passwordError = document.getElementById('passwordError');

form.addEventListener('submit', function(e) {
    let isValid = true;
    
    // 验证用户名
    if (username.value.trim() === '') {
        usernameError.textContent = '用户名不能为空';
        isValid = false;
    } else {
        usernameError.textContent = '';
    }
    
    // 验证密码
    if (password.value === '') {
        passwordError.textContent = '密码不能为空';
        isValid = false;
    } else if (password.value.length < 6) {
        passwordError.textContent = '密码长度不能少于6位';
        isValid = false;
    } else {
        passwordError.textContent = '';
    }
    
    if (!isValid) {
        e.preventDefault(); // 阻止表单提交
    }
});
&lt;/script&gt;
                        </div>
                        
                        <h3>实时表单验证</h3>
                        
                        <p>通过 input 事件实现实时验证：</p>
                        
                        <div class="code-block">
// 实时验证用户名
username.addEventListener('input', function() {
    if (username.value.trim() === '') {
        usernameError.textContent = '用户名不能为空';
    } else {
        usernameError.textContent = '';
    }
});

// 实时验证密码
password.addEventListener('input', function() {
    if (password.value.length < 6) {
        passwordError.textContent = '密码长度不能少于6位';
    } else {
        passwordError.textContent = '';
    }
});
                        </div>
                        
                        <h3>自定义验证规则</h3>
                        
                        <p>使用正则表达式实现复杂验证：</p>
                        
                        <div class="code-block">
function validateEmail(email) {
    const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return regex.test(email);
}

function validatePhone(phone) {
    const regex = /^1[3-9]\d{9}$/;
    return regex.test(phone);
}

// 验证邮箱
const emailInput = document.getElementById('email');
const emailError = document.getElementById('emailError');

emailInput.addEventListener('blur', function() {
    if (!validateEmail(emailInput.value)) {
        emailError.textContent = '请输入有效的邮箱地址';
    } else {
        emailError.textContent = '';
    }
});
                        </div>
                        
                        <h3>表单提交前的最终验证</h3>
                        
                        <p>在表单提交前进行最终验证：</p>
                        
                        <div class="code-block">
form.addEventListener('submit', function(e) {
    // 收集所有错误信息
    const errors = [];
    
    if (username.value.trim() === '') {
        errors.push('用户名不能为空');
    }
    
    if (password.value.length < 6) {
        errors.push('密码长度不能少于6位');
    }
    
    if (!validateEmail(emailInput.value)) {
        errors.push('请输入有效的邮箱地址');
    }
    
    // 如果有错误，阻止提交并显示错误
    if (errors.length > 0) {
        e.preventDefault();
        alert('请修正以下错误：\n' + errors.join('\n'));
    }
});
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>JavaScript 交互技术全面指南 &copy; 2023</p>
            <p>本指南旨在帮助开发者深入理解 JavaScript 交互技术，从基础到高级，全面掌握前端交互开发。</p>
        </footer>
    </div>

    <script>
        // 标签页功能
        document.addEventListener('DOMContentLoaded', function() {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');
            
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // 移除所有标签和内容的active类
                    tabs.forEach(t => t.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));
                    
                    // 添加当前标签和内容的active类
                    this.classList.add('active');
                    const tabId = this.getAttribute('data-tab');
                    document.getElementById(tabId).classList.add('active');
                });
            });
            
            // 折叠面板功能
            const accordionHeaders = document.querySelectorAll('.accordion-header');
            
            accordionHeaders.forEach(header => {
                header.addEventListener('click', function() {
                    // 切换当前面板的active类
                    this.classList.toggle('active');
                    const content = this.nextElementSibling;
                    content.classList.toggle('active');
                    
                    // 如果是手风琴效果，关闭其他面板
                    if (this.parentElement.parentElement.classList.contains('accordion')) {
                        accordionHeaders.forEach(otherHeader => {
                            if (otherHeader !== this) {
                                otherHeader.classList.remove('active');
                                otherHeader.nextElementSibling.classList.remove('active');
                            }
                        });
                    }
                });
            });
            
            // 演示：显示/隐藏效果
            const toggleButton = document.createElement('button');
            toggleButton.textContent = '切换显示演示';
            toggleButton.className = 'demo-button';
            
            const demoElement = document.createElement('div');
            demoElement.textContent = '这是一个演示元素，点击按钮可以显示/隐藏我';
            demoElement.className = 'demo-element';
            
            const demoContainer = document.createElement('div');
            demoContainer.className = 'demo-container';
            demoContainer.appendChild(toggleButton);
            demoContainer.appendChild(demoElement);
            
            // 将演示容器添加到第一个标签内容中
            const basicsTab = document.getElementById('basics');
            const firstAccordion = basicsTab.querySelector('.accordion');
            basicsTab.insertBefore(demoContainer, firstAccordion);
            
            // 添加演示交互
            toggleButton.addEventListener('click', function() {
                demoElement.classList.toggle('hidden');
                this.textContent = demoElement.classList.contains('hidden') ? 
                    '显示演示元素' : '隐藏演示元素';
            });
            
            // 初始化演示元素为隐藏状态
            demoElement.classList.add('hidden');
        });
    </script>
</body>
</html>