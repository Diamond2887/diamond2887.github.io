<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>进程、线程、协程：现代并发编程</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #34495e;
            --text-color: #333;
            --border-radius: 8px;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: #f9f9f9;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        h2 {
            font-size: 1.8rem;
            margin: 25px 0 15px;
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 8px;
        }
        
        h3 {
            font-size: 1.4rem;
            margin: 20px 0 10px;
            color: var(--dark-color);
        }
        
        h4 {
            font-size: 1.2rem;
            margin: 15px 0 8px;
            color: var(--dark-color);
        }
        
        p {
            margin-bottom: 15px;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 20px;
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            overflow: hidden;
        }
        
        .tab {
            flex: 1;
            padding: 15px 20px;
            text-align: center;
            background-color: var(--light-color);
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            color: var(--dark-color);
        }
        
        .tab:hover {
            background-color: #d5dbdb;
        }
        
        .tab.active {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .tab-content {
            display: none;
            background-color: white;
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }
        
        .tab-content.active {
            display: block;
        }
        
        details {
            margin-bottom: 15px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            overflow: hidden;
        }
        
        summary {
            padding: 15px 20px;
            background-color: var(--light-color);
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        summary:hover {
            background-color: #d5dbdb;
        }
        
        details[open] summary {
            background-color: var(--secondary-color);
            color: white;
        }
        
        .details-content {
            padding: 20px;
            border-top: 1px solid #ddd;
        }
        
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: var(--border-radius);
            overflow-x: auto;
            margin: 15px 0;
            border-left: 4px solid var(--secondary-color);
        }
        
        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: var(--shadow);
            border-radius: var(--border-radius);
            overflow: hidden;
        }
        
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        
        th {
            background-color: var(--secondary-color);
            color: white;
            font-weight: bold;
        }
        
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        tr:hover {
            background-color: #e9f7fe;
        }
        
        .comparison {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            flex: 1;
            background-color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }
        
        .comparison-item h3 {
            text-align: center;
            margin-bottom: 15px;
            color: var(--primary-color);
        }
        
        .comparison-item ul {
            padding-left: 20px;
        }
        
        .comparison-item li {
            margin-bottom: 8px;
        }
        
        .highlight {
            background-color: #fffacd;
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .feature-list {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
        }
        
        .feature {
            flex: 1 1 300px;
            background-color: white;
            padding: 15px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }
        
        .feature h4 {
            color: var(--secondary-color);
            margin-bottom: 10px;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: var(--dark-color);
            font-size: 0.9rem;
            border-top: 1px solid #ddd;
        }
        
        @media (max-width: 768px) {
            .tabs {
                flex-direction: column;
            }
            
            .comparison {
                flex-direction: column;
            }
            
            .feature-list {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>进程、线程、协程：现代并发编程</h1>
        <p>深入理解并发编程的三大核心概念</p>
    </header>
    
    <div class="container">
        <div class="tabs">
            <div class="tab active" data-tab="overview">概述</div>
            <div class="tab" data-tab="process">进程</div>
            <div class="tab" data-tab="thread">线程</div>
            <div class="tab" data-tab="coroutine">协程</div>
            <div class="tab" data-tab="comparison">对比分析</div>
            <div class="tab" data-tab="implementation">技术实现</div>
            <div class="tab" data-tab="practice">最佳实践</div>
        </div>
        
        <div class="tab-content active" id="overview">
            <h2>并发编程概述</h2>
            <p>进程、线程、协程是现代并发编程的三大核心概念，它们在操作系统中扮演着不同的角色，各具特色。理解这三者的本质区别、技术特点和应用场景，对于编写高效、稳定的并发程序至关重要。</p>
            
            <div class="feature-list">
                <div class="feature">
                    <h4>进程 (Process)</h4>
                    <p>操作系统资源分配的基本单位，拥有独立的地址空间，提供最强的隔离性。</p>
                </div>
                <div class="feature">
                    <h4>线程 (Thread)</h4>
                    <p>CPU调度的基本单位，共享进程资源，比进程更轻量级，适合I/O密集型任务。</p>
                </div>
                <div class="feature">
                    <h4>协程 (Coroutine)</h4>
                    <p>用户态的轻量级线程，由程序自身调度，资源开销最小，适合超高并发场景。</p>
                </div>
            </div>
            
            <h3>为什么需要并发编程？</h3>
            <p>随着多核CPU的普及和应用程序复杂度的增加，并发编程已成为提高程序性能、响应性和资源利用率的关键技术。通过合理使用进程、线程和协程，我们可以：</p>
            <ul>
                <li>充分利用多核CPU的计算能力</li>
                <li>提高程序的响应性和用户体验</li>
                <li>高效处理I/O密集型任务</li>
                <li>构建高并发、高可用的服务器应用</li>
                <li>实现复杂的异步编程模型</li>
            </ul>
        </div>
        
        <div class="tab-content" id="process">
            <h2>进程基础概念与实现</h2>
            
            <details>
                <summary>进程的定义与特征</summary>
                <div class="details-content">
                    <p><span class="highlight">进程（Process）是操作系统资源分配的基本单位</span>，是正在运行的程序的实例抽象。从操作系统的角度看，进程包含了程序执行所需的所有资源，形成了一个相对独立的执行环境。</p>
                    
                    <h4>进程的核心特征</h4>
                    <ul>
                        <li><strong>独立性</strong>：每个进程拥有独立的虚拟地址空间，包括代码段、数据段、堆、栈等资源，这些资源彼此隔离，互不干扰。</li>
                        <li><strong>进程控制块（PCB）</strong>：操作系统管理进程的核心数据结构，存储了进程的所有关键信息。</li>
                        <li><strong>创建过程</strong>：当调用fork()系统调用时，内核为新进程分配PCB和地址空间。</li>
                        <li><strong>上下文切换机制</strong>：内核保存当前进程的完整上下文，然后加载下一个进程的上下文信息。</li>
                    </ul>
                </div>
            </details>
            
            <details>
                <summary>C++中进程的实现方式</summary>
                <div class="details-content">
                    <p>在C++中，进程的创建和管理主要通过系统调用实现。以下是一个使用fork和exec系列函数创建进程的完整示例：</p>
                    
                    <pre><code>#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;cstdlib&gt;

int main() {
    // 创建子进程
    pid_t pid = fork();
    
    if (pid &lt; 0) {
        // fork失败
        std::cerr &lt;&lt; "Fork failed!" &lt;&lt; std::endl;
        return 1;
    } else if (pid == 0) {
        // 子进程执行路径
        std::cout &lt;&lt; "Child process (PID: " &lt;&lt; getpid() &lt;&lt; ")" &lt;&lt; std::endl;
        std::cout &lt;&lt; "Parent PID: " &lt;&lt; getppid() &lt;&lt; std::endl;
        
        // 使用execlp执行另一个程序
        std::cout &lt;&lt; "Executing 'ls -l'..." &lt;&lt; std::endl;
        if (execlp("ls", "ls", "-l", nullptr) == -1) {
            std::cerr &lt;&lt; "Exec failed!" &lt;&lt; std::endl;
            return 1;
        }
    } else {
        // 父进程执行路径
        std::cout &lt;&lt; "Parent process (PID: " &lt;&lt; getpid() &lt;&lt; ")" &lt;&lt; std::endl;
        std::cout &lt;&lt; "Child PID: " &lt;&lt; pid &lt;&lt; std::endl;
        
        // 等待子进程完成
        int status;
        waitpid(pid, &status, 0);
        
        if (WIFEXITED(status)) {
            std::cout &lt;&lt; "Child exited with status: " &lt;&lt; WEXITSTATUS(status) &lt;&lt; std::endl;
        } else if (WIFSIGNALED(status)) {
            std::cout &lt;&lt; "Child terminated by signal: " &lt;&lt; WTERMSIG(status) &lt;&lt; std::endl;
        }
    }
    
    return 0;
}</code></pre>
                    
                    <p>进程间通信（IPC）是进程编程的重要组成部分。以下是一个使用管道进行进程间通信的示例：</p>
                    
                    <pre><code>#include &lt;iostream&gt;
#include &lt;unistd.h&gt;
#include &lt;cstring&gt;

int main() {
    int pipefd[2];
    char buffer[1024];
    
    // 创建管道
    if (pipe(pipefd) == -1) {
        std::cerr &lt;&lt; "Pipe creation failed!" &lt;&lt; std::endl;
        return 1;
    }
    
    pid_t pid = fork();
    
    if (pid &lt; 0) {
        std::cerr &lt;&lt; "Fork failed!" &lt;&lt; std::endl;
        return 1;
    } else if (pid == 0) {
        // 子进程：从管道读取数据
        close(pipefd[1]); // 关闭写端
        
        ssize_t bytes_read = read(pipefd[0], buffer, sizeof(buffer));
        if (bytes_read &gt; 0) {
            std::cout &lt;&lt; "Child received: " &lt;&lt; buffer &lt;&lt; std::endl;
        }
        
        close(pipefd[0]);
    } else {
        // 父进程：向管道写入数据
        close(pipefd[0]); // 关闭读端
        
        const char *message = "Hello from parent!";
        ssize_t bytes_written = write(pipefd[1], message, strlen(message));
        std::cout &lt;&lt; "Parent sent: " &lt;&lt; message &lt;&lt; std::endl;
        
        close(pipefd[1]);
        
        // 等待子进程完成
        waitpid(pid, nullptr, 0);
    }
    
    return 0;
}</code></pre>
                </div>
            </details>
            
            <details>
                <summary>进程的应用场景</summary>
                <div class="details-content">
                    <h4>需要强隔离性的应用</h4>
                    <p>浏览器的多标签页就是典型例子，每个标签页运行在独立的进程中，一个标签页的崩溃不会影响其他标签页。类似地，微服务容器、操作系统任务等对稳定性要求极高的场景都适合使用进程。</p>
                    
                    <h4>CPU密集型计算</h4>
                    <p>由于进程拥有独立的地址空间和CPU资源，特别适合需要充分利用多核CPU的并行计算任务，如视频编码、科学计算、数据处理等。每个进程可以绑定到不同的CPU核心，实现真正的并行处理。</p>
                    
                    <h4>需要独立资源管理的服务</h4>
                    <p>例如，数据库服务器通常采用多进程架构，主进程负责监听连接，子进程负责处理具体的数据库操作，每个子进程拥有独立的资源，避免了资源竞争和死锁问题。</p>
                </div>
            </details>
        </div>
        
        <div class="tab-content" id="thread">
            <h2>线程基础概念与实现</h2>
            
            <details>
                <summary>线程的定义与特征</summary>
                <div class="details-content">
                    <p><span class="highlight">线程（Thread）是进程内的轻量级执行单元，是CPU调度的基本单位</span>。与进程不同，线程不拥有独立的地址空间，而是共享所属进程的资源，包括代码段、数据段、堆、文件描述符等，但每个线程有自己独立的栈空间、寄存器上下文和线程控制块（TCB）。</p>
                    
                    <h4>线程的核心特征</h4>
                    <ul>
                        <li><strong>资源共享与独立性的平衡</strong>：线程共享进程的地址空间，同时拥有独立的栈空间。</li>
                        <li><strong>线程控制块（TCB）</strong>：操作系统管理线程的数据结构，存储线程的状态信息。</li>
                        <li><strong>调度机制</strong>：由操作系统内核负责，上下文切换开销比进程小。</li>
                        <li><strong>创建和销毁开销</strong>：比进程小得多，适合需要频繁创建和销毁执行单元的场景。</li>
                    </ul>
                </div>
            </details>
            
            <details>
                <summary>C++中线程的实现方式</summary>
                <div class="details-content">
                    <p>在C++中，线程的实现主要有两种方式：使用POSIX线程库（pthread）和C++11标准库的&lt;thread&gt;头文件。</p>
                    
                    <h4>使用pthread的线程实现</h4>
                    <pre><code>#include &lt;iostream&gt;
#include &lt;pthread.h&gt;
#include &lt;unistd.h&gt;

// 线程函数
void *thread_function(void *arg) {
    int *id = static_cast&lt;int*&gt;(arg);
    std::cout &lt;&lt; "Thread " &lt;&lt; *id &lt;&lt; " started" &lt;&lt; std::endl;
    
    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; "Thread " &lt;&lt; *id &lt;&lt; ": " &lt;&lt; i &lt;&lt; std::endl;
        sleep(1);
    }
    
    std::cout &lt;&lt; "Thread " &lt;&lt; *id &lt;&lt; " finished" &lt;&lt; std::endl;
    return nullptr;
}

int main() {
    pthread_t threads[2];
    int thread_ids[2] = {1, 2};
    
    // 创建线程
    for (int i = 0; i &lt; 2; ++i) {
        int ret = pthread_create(&threads[i], nullptr, thread_function, &thread_ids[i]);
        if (ret != 0) {
            std::cerr &lt;&lt; "Failed to create thread " &lt;&lt; i &lt;&lt; std::endl;
            return 1;
        }
    }
    
    // 等待所有线程完成
    for (int i = 0; i &lt; 2; ++i) {
        pthread_join(threads[i], nullptr);
    }
    
    std::cout &lt;&lt; "All threads completed" &lt;&lt; std::endl;
    return 0;
}</code></pre>
                    
                    <h4>使用C++11标准库的线程实现</h4>
                    <pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

void thread_function(int id) {
    std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " started" &lt;&lt; std::endl;
    
    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; ": " &lt;&lt; i &lt;&lt; std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
    
    std::cout &lt;&lt; "Thread " &lt;&lt; id &lt;&lt; " finished" &lt;&lt; std::endl;
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    
    // 创建线程
    for (int i = 1; i &lt;= 2; ++i) {
        threads.emplace_back(thread_function, i);
    }
    
    // 等待所有线程完成
    for (auto& thread : threads) {
        thread.join();
    }
    
    std::cout &lt;&lt; "All threads completed" &lt;&lt; std::endl;
    return 0;
}</code></pre>
                    
                    <h4>线程同步机制示例</h4>
                    <pre><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

std::mutex mtx;
int counter = 0;

void increment() {
    for (int i = 0; i &lt; 1000000; ++i) {
        std::lock_guard&lt;std::mutex&gt; lock(mtx);
        ++counter;
    }
}

int main() {
    std::vector&lt;std::thread&gt; threads;
    
    // 创建10个线程
    for (int i = 0; i &lt; 10; ++i) {
        threads.emplace_back(increment);
    }
    
    // 等待所有线程完成
    for (auto& thread : threads) {
        thread.join();
    }
    
    std::cout &lt;&lt; "Counter: " &lt;&lt; counter &lt;&lt; std::endl;
    return 0;
}</code></pre>
                </div>
            </details>
            
            <details>
                <summary>线程的应用场景</summary>
                <div class="details-content">
                    <h4>I/O密集型任务</h4>
                    <p>Web服务器、数据库连接池、文件处理等应用中，线程可以在等待I/O操作时释放CPU，让其他线程执行，从而提高整体效率。</p>
                    
                    <h4>需要共享数据的并发处理</h4>
                    <p>由于线程共享进程的地址空间，多个线程可以直接访问共享内存，无需复杂的数据传输机制。这在需要频繁数据交换的场景中优势明显。</p>
                    
                    <h4>图形界面应用</h4>
                    <p>主线程负责界面渲染和事件处理，工作线程负责耗时操作，如文件加载、网络请求等。这种设计避免了界面在处理耗时任务时的卡顿。</p>
                    
                    <h4>并行计算任务</h4>
                    <p>当任务可以分解为多个独立的子任务时，可以分配给不同的线程并行处理，充分利用多核CPU的优势。</p>
                </div>
            </details>
        </div>
        
        <div class="tab-content" id="coroutine">
            <h2>协程基础概念与实现</h2>
            
            <details>
                <summary>协程的定义与特征</summary>
                <div class="details-content">
                    <p><span class="highlight">协程（Coroutine）是用户态的轻量级线程，由程序自身而非操作系统内核调度</span>。协程本质上是"可暂停、可恢复的函数"，它能在执行过程中主动挂起（yield），将CPU控制权交给其他协程，待条件满足后再从挂起点恢复执行。</p>
                    
                    <h4>协程的核心特征</h4>
                    <ul>
                        <li><strong>用户态调度和协作式多任务</strong>：协程的调度完全在用户态进行，避免了用户态到内核态的切换开销。</li>
                        <li><strong>内存开销极低</strong>：协程控制块（CCB）通常只有几十字节到几百字节，协程栈的大小通常为几KB到几十KB。</li>
                        <li><strong>上下文切换开销极小</strong>：切换时间通常为纳秒级，比线程的上下文切换快2-3个数量级。</li>
                        <li><strong>调度模型</strong>：主要有N:1模型、1:1模型和M:N模型。</li>
                    </ul>
                </div>
            </details>
            
            <details>
                <summary>C++中协程的实现方式</summary>
                <div class="details-content">
                    <p>C++中协程的实现主要有三种方式：基于ucontext的手动实现、使用Boost.Coroutine库和C++20标准协程。</p>
                    
                    <h4>基于ucontext的协程实现</h4>
                    <pre><code>#include &lt;iostream&gt;
#include &lt;ucontext.h&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

const int STACK_SIZE = 1024 * 1024; // 1MB栈空间

struct Coroutine {
    ucontext_t ctx;
    char stack[STACK_SIZE];
    bool running = false;
};

std::queue&lt;Coroutine*&gt; ready_coros;
Coroutine main_coro;

void coroutine_swap(Coroutine* from, Coroutine* to) {
    if (from-&gt;running) {
        from-&gt;running = false;
        swapcontext(&from-&gt;ctx, &to-&gt;ctx);
    }
}

void coroutine_yield() {
    Coroutine* current = ready_coros.front();
    ready_coros.pop();
    ready_coros.push(current);
    coroutine_swap(current, ready_coros.front());
}

void coroutine_create(void (*func)(), Coroutine* coro) {
    getcontext(&coro-&gt;ctx);
    coro-&gt;ctx.uc_stack.ss_sp = coro-&gt;stack;
    coro-&gt;ctx.uc_stack.ss_size = STACK_SIZE;
    coro-&gt;ctx.uc_link = &main_coro.ctx;
    makecontext(&coro-&gt;ctx, reinterpret_cast&lt;void(*)()&gt;(func), 0);
    ready_coros.push(coro);
}

void coroutine_schedule() {
    while (!ready_coros.empty()) {
        Coroutine* current = ready_coros.front();
        ready_coros.pop();
        current-&gt;running = true;
        coroutine_swap(&main_coro, current);
    }
}

// 协程函数示例
void coroutine_func(int id) {
    for (int i = 0; i &lt; 5; ++i) {
        std::cout &lt;&lt; "Coroutine " &lt;&lt; id &lt;&lt; ": " &lt;&lt; i &lt;&lt; std::endl;
        coroutine_yield();
    }
}

int main() {
    getcontext(&main_coro.ctx);
    
    // 创建两个协程
    Coroutine coro1, coro2;
    coroutine_create([]() { coroutine_func(1); }, &coro1);
    coroutine_create([]() { coroutine_func(2); }, &coro2);
    
    coroutine_schedule();
    return 0;
}</code></pre>
                    
                    <h4>使用Boost.Coroutine的协程实现</h4>
                    <pre><code>#include &lt;iostream&gt;
#include &lt;boost/coroutine2/coroutine.hpp&gt;

// 协程函数
void coroutine_func(boost::coroutines2::coroutine&lt;int&gt;::pull_type& yield) {
    for (int i = 0; i &lt; 5; ++i) {
        yield(i); // 产生值并暂停
        std::cout &lt;&lt; "Coroutine resumed at step " &lt;&lt; i &lt;&lt; std::endl;
    }
}

int main() {
    boost::coroutines2::coroutine&lt;int&gt;::push_type source(coroutine_func);
    
    for (int i = 0; i &lt; 5; ++i) {
        int value = source(); // 恢复协程执行
        std::cout &lt;&lt; "Main received: " &lt;&lt; value &lt;&lt; std::endl;
    }
    
    return 0;
}</code></pre>
                    
                    <h4>C++20标准协程的实现</h4>
                    <pre><code>#include &lt;iostream&gt;
#include &lt;coroutine&gt;

// 简单的协程返回类型
struct SimpleCoroutine {
    struct promise_type {
        SimpleCoroutine get_return_object() {
            return SimpleCoroutine{std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)};
        }
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception() {}
    };
    
    std::coroutine_handle&lt;promise_type&gt; handle;
    
    SimpleCoroutine(std::coroutine_handle&lt;promise_type&gt; h) : handle(h) {}
    ~SimpleCoroutine() { if (handle) handle.destroy(); }
    
    void resume() { if (handle) handle.resume(); }
};

// 协程函数示例
SimpleCoroutine async_operation() {
    std::cout &lt;&lt; "Coroutine started" &lt;&lt; std::endl;
    
    // 模拟异步操作
    co_await std::suspend_always{};
    std::cout &lt;&lt; "Coroutine resumed after first await" &lt;&lt; std::endl;
    
    co_await std::suspend_always{};
    std::cout &lt;&lt; "Coroutine resumed after second await" &lt;&lt; std::endl;
    
    co_return;
}

int main() {
    auto coro = async_operation();
    std::cout &lt;&lt; "Main: Starting coroutine" &lt;&lt; std::endl;
    coro.resume();
    std::cout &lt;&lt; "Main: Coroutine suspended" &lt;&lt; std::endl;
    coro.resume();
    std::cout &lt;&lt; "Main: Coroutine suspended again" &lt;&lt; std::endl;
    coro.resume();
    std::cout &lt;&lt; "Main: Coroutine completed" &lt;&lt; std::endl;
    
    return 0;
}</code></pre>
                </div>
            </details>
            
            <details>
                <summary>协程的应用场景</summary>
                <div class="details-content">
                    <h4>超高并发I/O密集型任务</h4>
                    <p>由于协程的轻量级特性和极低的切换开销，特别适合处理成千上万的并发连接，如微服务架构、实时通信系统、游戏服务器等。</p>
                    
                    <h4>异步编程和事件驱动系统</h4>
                    <p>协程允许使用同步的代码风格编写异步逻辑，大大提高了代码的可读性和可维护性。在网络编程中，协程可以优雅地处理复杂的异步操作序列。</p>
                    
                    <h4>需要大量轻量级任务的场景</h4>
                    <p>例如，网络爬虫系统需要同时处理大量的URL请求，每个请求可以用一个协程处理；流式数据处理系统需要处理大量的数据流。</p>
                    
                    <h4>对响应时间敏感的应用</h4>
                    <p>由于协程的调度完全由程序控制，可以精确控制任务的执行时机和优先级，在需要严格响应时间的场景中优势明显。</p>
                </div>
            </details>
        </div>
        
        <div class="tab-content" id="comparison">
            <h2>进程、线程、协程的对比分析</h2>
            
            <details>
                <summary>资源占用对比</summary>
                <div class="details-content">
                    <p>在资源占用方面，三者存在巨大差异：</p>
                    
                    <h4>内存开销</h4>
                    <p>进程的内存开销最大，通常为MB级别；线程的内存开销为KB级别；协程的内存开销最小，仅为字节到KB级别。</p>
                    
                    <h4>CPU开销</h4>
                    <p>进程的上下文切换开销最大（1-10微秒）；线程的上下文切换开销较小（0.5-1.5微秒）；协程的上下文切换开销极小（纳秒级）。</p>
                    
                    <h4>并发能力</h4>
                    <p>进程的并发能力通常在数百级；线程的并发能力可达数千级；协程的并发能力可达百万级。</p>
                    
                    <table>
                        <tr>
                            <th>性能指标</th>
                            <th>进程</th>
                            <th>线程</th>
                            <th>协程</th>
                        </tr>
                        <tr>
                            <td>创建1000个实例耗时</td>
                            <td>300ms</td>
                            <td>50ms</td>
                            <td>0.3ms</td>
                        </tr>
                        <tr>
                            <td>上下文切换时间</td>
                            <td>1-10μs</td>
                            <td>0.5-1.5μs</td>
                            <td>纳秒级</td>
                        </tr>
                        <tr>
                            <td>内存开销/实例</td>
                            <td>MB级</td>
                            <td>KB级</td>
                            <td>字节-KB级</td>
                        </tr>
                        <tr>
                            <td>典型并发规模</td>
                            <td>数百级</td>
                            <td>数千级</td>
                            <td>百万级</td>
                        </tr>
                        <tr>
                            <td>切换开销对比</td>
                            <td>最高</td>
                            <td>中等</td>
                            <td>最低（比线程快2-3个数量级）</td>
                        </tr>
                    </table>
                </div>
            </details>
            
            <details>
                <summary>调度机制对比</summary>
                <div class="details-content">
                    <h4>调度层级</h4>
                    <p>进程和线程都由操作系统内核调度，属于内核态调度；而协程由用户态的运行时或框架调度，属于用户态调度。</p>
                    
                    <h4>调度方式</h4>
                    <p>进程和线程采用抢占式调度，由内核根据时间片或优先级强制切换。协程采用协作式调度，通过yield、await等操作主动让出执行权。</p>
                    
                    <h4>上下文切换机制</h4>
                    <p>进程切换需要切换完整的地址空间；线程切换因为共享地址空间，无需切换页表；协程切换完全在用户态进行，只需保存和恢复协程的上下文信息。</p>
                </div>
            </details>
            
            <details>
                <summary>数据共享与通信机制对比</summary>
                <div class="details-content">
                    <h4>隔离级别</h4>
                    <p>从高到低依次为进程、线程、协程。进程具有最高的隔离级别；线程的隔离级别中等；协程的隔离级别最低。</p>
                    
                    <h4>通信方式</h4>
                    <p>进程间通信需要使用专门的IPC机制；线程间可以直接通过共享内存通信；协程间的通信方式多样，可以使用共享内存、Channel等。</p>
                    
                    <h4>同步需求</h4>
                    <p>进程间通信需要复杂的同步机制；线程间共享数据需要精细的同步控制；协程在单线程内执行，理论上不存在竞态条件。</p>
                </div>
            </details>
        </div>
        
        <div class="tab-content" id="implementation">
            <h2>技术实现深度分析</h2>
            
            <details>
                <summary>进程实现的底层机制</summary>
                <div class="details-content">
                    <h4>写时复制（Copy-on-Write）技术</h4>
                    <p>当调用fork()时，内核并不立即复制父进程的所有内存，而是让父子进程共享相同的物理内存页，并将这些页标记为只读。只有当父进程或子进程试图修改某一页时，才会为修改方分配新的物理内存页。</p>
                    
                    <h4>虚拟内存映射机制</h4>
                    <p>进程的地址空间通过虚拟内存技术映射到物理内存，每个进程都有独立的页表来维护虚拟地址到物理地址的映射。进程切换时需要刷新TLB，这是进程上下文切换开销大的主要原因之一。</p>
                    
                    <h4>exec系列函数</h4>
                    <p>当调用exec函数时，它会用新程序替换当前进程的整个地址空间，包括代码段、数据段、堆、栈等所有内容。</p>
                </div>
            </details>
            
            <details>
                <summary>线程实现的底层机制</summary>
                <div class="details-content">
                    <h4>线程控制块（TCB）的实现</h4>
                    <p>在Linux中，线程和进程使用相同的task_struct结构体，通过clone()系统调用创建，使用CLONE_VM标志共享内存空间。</p>
                    
                    <h4>线程局部存储（TLS）机制</h4>
                    <p>允许每个线程拥有自己的私有变量。TLS的实现通常有两种方式：静态方式使用__thread关键字；动态方式使用pthread_key_create()等函数。</p>
                    
                    <h4>线程池技术</h4>
                    <p>线程池预先创建一定数量的线程，任务提交到任务队列，线程从队列中取出任务执行。这种方式避免了频繁创建和销毁线程的开销。</p>
                </div>
            </details>
            
            <details>
                <summary>协程实现的底层机制</summary>
                <div class="details-content">
                    <h4>上下文切换机制的实现</h4>
                    <p>主要有几种方式：ucontext方式使用系统提供的ucontext_t结构体；setjmp/longjmp方式通过这对函数实现简单的上下文切换；Boost.Context使用纯汇编实现。</p>
                    
                    <h4>协程调度器的设计</h4>
                    <p>调度器需要管理协程的生命周期，包括创建、挂起、恢复、销毁等操作。常见的调度策略包括FIFO、优先级调度、工作窃取等。</p>
                    
                    <h4>不同协程实现方案的对比</h4>
                    <p>Boost.Coroutine2采用非对称协程模型；腾讯libco提供类pthread的简单接口；魅族libgo实现了100%兼容的syscall hook。</p>
                </div>
            </details>
        </div>
        
        <div class="tab-content" id="practice">
            <h2>选择策略与最佳实践</h2>
            
            <details>
                <summary>选择策略</summary>
                <div class="details-content">
                    <h4>根据任务类型选择</h4>
                    <p>对于CPU密集型任务，优先选择进程或多线程；对于I/O密集型任务，如果并发量较低，选择多线程；如果需要处理高并发请求，选择协程。</p>
                    
                    <h4>根据隔离需求选择</h4>
                    <p>如果应用需要强隔离性，必须使用进程；如果需要共享数据且对隔离性要求不高，可以选择线程或协程。</p>
                    
                    <h4>根据资源限制选择</h4>
                    <p>在资源受限的环境中，协程是最佳选择；如果系统有足够的内存和CPU资源，可以根据并发需求选择线程或进程。</p>
                    
                    <h4>根据开发复杂度选择</h4>
                    <p>进程间通信复杂；线程需要处理同步和线程安全问题；协程的编程模型相对简单。</p>
                </div>
            </details>
            
            <details>
                <summary>性能优化建议</summary>
                <div class="details-content">
                    <h4>进程优化建议</h4>
                    <ul>
                        <li>使用写时复制技术减少fork开销</li>
                        <li>合理设计进程间通信机制，避免频繁的数据交换</li>
                        <li>使用进程池技术复用进程，减少创建和销毁开销</li>
                        <li>考虑使用vfork替代fork</li>
                    </ul>
                    
                    <h4>线程优化建议</h4>
                    <ul>
                        <li>控制线程数量在合理范围，通常为CPU核心数的1-2倍</li>
                        <li>使用线程池管理线程生命周期</li>
                        <li>优化线程局部存储的使用，减少锁竞争</li>
                        <li>注意缓存局部性，避免伪共享问题</li>
                    </ul>
                    
                    <h4>协程优化建议</h4>
                    <ul>
                        <li>根据实际需求调整协程栈大小，避免过度分配</li>
                        <li>合理设计协程调度策略，避免协程饿死</li>
                        <li>注意协程泄漏问题，使用智能指针或RAII机制管理协程生命周期</li>
                        <li>在I/O密集型场景中充分利用协程的优势</li>
                    </ul>
                </div>
            </details>
            
            <details>
                <summary>混合使用策略</summary>
                <div class="details-content">
                    <h4>进程+线程+协程的混合架构</h4>
                    <p>在大型系统中很常见。例如，Nginx服务器使用master-worker进程模型，每个worker进程内部使用事件驱动和协程处理多个连接。</p>
                    
                    <h4>分层架构中的应用</h4>
                    <p>在分布式系统中，不同层次可以使用不同的并发模型。例如，服务发现和配置管理使用进程保证可靠性；业务逻辑处理使用线程池；网络I/O处理使用协程。</p>
                    
                    <h4>动态切换策略</h4>
                    <p>在某些场景中，可以根据负载情况动态调整并发模型。例如，在低负载时使用协程处理请求，在高负载时切换到多线程模式。</p>
                </div>
            </details>
        </div>
    </div>
    
    <footer>
        <p>进程、线程、协程是现代并发编程的三大支柱，各有其独特的优势和适用场景。</p>
        <p>理解这三者的本质差异，掌握它们的实现机制和应用场景，对于编写高效、稳定的并发程序至关重要。</p>
    </footer>

    <script>
        // 标签页切换功能
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                // 移除所有标签的活动状态
                document.querySelectorAll('.tab').forEach(t => {
                    t.classList.remove('active');
                });
                
                // 移除所有内容的活动状态
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // 设置当前标签为活动状态
                tab.classList.add('active');
                
                // 显示对应的内容
                const tabId = tab.getAttribute('data-tab');
                document.getElementById(tabId).classList.add('active');
            });
        });
    </script>
</body>
</html>