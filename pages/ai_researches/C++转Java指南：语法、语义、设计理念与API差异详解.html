<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++转Java指南：语法、语义、设计理念与API差异详解</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            background: linear-gradient(135deg, #2c3e50 0%, #4a6491 100%);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3);
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 20px;
        }
        
        .tag {
            display: inline-block;
            background-color: #3498db;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        .tag.cpp {
            background-color: #00599c;
        }
        
        .tag.java {
            background-color: #b07219;
        }
        
        .tag.guide {
            background-color: #27ae60;
        }
        
        .content-section {
            background-color: white;
            border-radius: 10px;
            margin-bottom: 25px;
            padding: 25px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
            border-left: 5px solid #3498db;
            transition: transform 0.3s ease;
        }
        
        .content-section:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }
        
        h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
            display: flex;
            align-items: center;
        }
        
        h2::before {
            content: "▶";
            margin-right: 10px;
            color: #3498db;
            font-size: 1.2rem;
        }
        
        h3 {
            color: #34495e;
            margin: 20px 0 15px 0;
            padding-left: 10px;
            border-left: 4px solid #3498db;
        }
        
        h4 {
            color: #2c3e50;
            margin: 15px 0 10px 0;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.95rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }
        
        .comparison-table th {
            background-color: #2c3e50;
            color: white;
            padding: 12px 15px;
            text-align: left;
            font-weight: 600;
        }
        
        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        .comparison-table tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        
        .comparison-table tr:hover {
            background-color: #e8f4fc;
        }
        
        .cpp-highlight {
            background-color: #e3f2fd;
            padding: 2px 6px;
            border-radius: 4px;
            border-left: 3px solid #00599c;
            font-weight: 600;
        }
        
        .java-highlight {
            background-color: #f1f8e9;
            padding: 2px 6px;
            border-radius: 4px;
            border-left: 3px solid #b07219;
            font-weight: 600;
        }
        
        .code-block {
            background-color: #f8f9fa;
            border-left: 5px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.95rem;
            line-height: 1.5;
            overflow-x: auto;
            white-space: pre-wrap;
            border-radius: 0 5px 5px 0;
        }
        
        .code-block.cpp {
            border-left-color: #00599c;
        }
        
        .code-block.java {
            border-left-color: #b07219;
        }
        
        .note {
            background-color: #fffde7;
            border-left: 5px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .warning {
            background-color: #ffebee;
            border-left: 5px solid #f44336;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .tip {
            background-color: #e8f5e9;
            border-left: 5px solid #4caf50;
            padding: 15px;
            margin: 15px 0;
            border-radius: 0 5px 5px 0;
        }
        
        .flex-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        
        .flex-item {
            flex: 1 1 300px;
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        .key-point {
            background-color: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 5px solid #2196f3;
        }
        
        .toggle-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            margin: 10px 0;
            transition: background-color 0.3s;
        }
        
        .toggle-button:hover {
            background-color: #2980b9;
        }
        
        .toggle-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }
        
        .toggle-content.expanded {
            max-height: 2000px;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #7f8c8d;
            font-size: 0.9rem;
            border-top: 1px solid #ecf0f1;
        }
        
        .highlight-box {
            background: linear-gradient(to right, #e3f2fd, #f3e5f5);
            padding: 20px;
            border-radius: 10px;
            margin: 25px 0;
            border: 1px solid #bbdefb;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .content-section {
                padding: 15px;
            }
            
            .comparison-table {
                font-size: 0.85rem;
            }
            
            .comparison-table th, 
            .comparison-table td {
                padding: 8px 10px;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>C++转Java指南：语法、语义、设计理念与API差异详解</h1>
        <p class="subtitle">针对具备C++基础的开发者，系统梳理C++与Java的核心差异，完成从C++到Java的平滑过渡</p>
        <div>
            <span class="tag cpp">C++</span>
            <span class="tag java">Java</span>
            <span class="tag guide">迁移指南</span>
            <span class="tag">面向对象</span>
            <span class="tag">编程语言</span>
        </div>
    </header>
    
    <section class="content-section">
        <h2>摘要</h2>
        <p>本指南针对具备C++基础的开发者，系统梳理C++与Java在语法规则、语义模型、面向对象设计理念及标准库API的核心差异，重点解析C++转Java过程中的常见陷阱与范式转换。</p>
        
        <div class="flex-container">
            <div class="flex-item">
                <h4>C++设计哲学</h4>
                <p><span class="cpp-highlight">"零开销抽象"</span>、<span class="cpp-highlight">"多范式支持"</span>为核心，赋予开发者底层控制权</p>
            </div>
            <div class="flex-item">
                <h4>Java设计哲学</h4>
                <p><span class="java-highlight">"简单安全"</span>、<span class="java-highlight">"纯面向对象"</span>为设计哲学，通过JVM实现跨平台与自动资源管理</p>
            </div>
        </div>
        
        <div class="note">
            <p>通过本指南的对比分析，开发者可快速掌握Java的核心特性，完成从C++到Java的平滑过渡。</p>
        </div>
    </section>
    
    <section class="content-section">
        <h2>1. 语法差异</h2>
        <p>C++与Java虽共享C系语法基础，但在变量声明、函数定义、类结构等核心语法上存在显著差异，本质源于两者的设计目标分歧。</p>
        
        <h3>1.1 程序结构与全局声明</h3>
        <p>C++兼容C语言的过程式编程特性，允许全局变量与函数独立于类存在；Java是纯面向对象语言，所有代码必须封装在类或接口中，无全局实体。</p>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>特性</th>
                    <th>C++ (C++23)</th>
                    <th>Java (Java 21 LTS)</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>全局声明</strong></td>
                    <td>支持全局变量、全局函数</td>
                    <td>无，需用<code>static</code>方法/变量模拟</td>
                    <td>C++可在命名空间或全局作用域定义实体；Java所有代码必须属于类/接口</td>
                </tr>
                <tr>
                    <td><strong>入口函数</strong></td>
                    <td><code>int main()</code>（参数可选）</td>
                    <td><code>public static void main(String[] args)</code></td>
                    <td>Java入口函数必须为静态、公共，且参数为字符串数组</td>
                </tr>
                <tr>
                    <td><strong>头文件依赖</strong></td>
                    <td>需手动<code>#include</code>头文件</td>
                    <td>用<code>import</code>导入类</td>
                    <td>C++需显式声明依赖；Java导入仅为语法糖，JVM自动处理类加载</td>
                </tr>
            </tbody>
        </table>
        
        <button class="toggle-button" onclick="toggleContent('code-example-1')">显示代码示例</button>
        <div id="code-example-1" class="toggle-content">
            <div class="flex-container">
                <div class="flex-item">
                    <h4>C++全局函数示例</h4>
                    <div class="code-block cpp">
#include &lt;iostream&gt;
using namespace std;

void globalFunc() { // 全局函数
    cout &lt;&lt; "Hello C++ Global" &lt;&lt; endl;
}

int main() {
    globalFunc();
    return 0;
}
                    </div>
                </div>
                <div class="flex-item">
                    <h4>Java静态方法模拟全局函数</h4>
                    <div class="code-block java">
package com.example;

public class Main {
    public static void globalMethod() { // 静态方法模拟全局函数
        System.out.println("Hello Java Static");
    }
    
    public static void main(String[] args) {
        globalMethod();
    }
}
                    </div>
                </div>
            </div>
        </div>
        
        <h3>1.2 变量声明与基本类型</h3>
        <p>C++支持指针、引用等底层内存操作；Java仅提供受管控的引用，无显式指针，核心差异集中在内存控制权与类型推导机制。</p>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>特性</th>
                    <th>C++</th>
                    <th>Java</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>声明位置</strong></td>
                    <td>代码块任意位置</td>
                    <td>局部变量可在任意位置（Java 8+），类成员需在类内声明</td>
                    <td>C++传统规则允许函数内任意位置声明；Java 8前需在代码块开头声明</td>
                </tr>
                <tr>
                    <td><strong>分配方式</strong></td>
                    <td>栈分配、堆分配</td>
                    <td>基本类型栈分配，对象堆分配（<code>new</code>关键字）</td>
                    <td>Java对象无栈分配，所有对象实例均在堆上创建</td>
                </tr>
                <tr>
                    <td><strong>类型推导</strong></td>
                    <td><code>auto</code>（编译期推导）</td>
                    <td><code>var</code>（局部变量推导，Java 10+）</td>
                    <td>C++<code>auto</code>可推导指针/引用类型；Java<code>var</code>仅适用于局部变量</td>
                </tr>
            </tbody>
        </table>
        
        <h3>1.6 关键字对比</h3>
        <p>C++与Java的关键字存在显著差异，部分关键字同名但语义不同，需重点区分：</p>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>C++关键字</th>
                    <th>Java对应/替代</th>
                    <th>差异说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code>auto</code></td>
                    <td><code>var</code>（局部变量推导）</td>
                    <td>C++<code>auto</code>可推导指针/引用；Java<code>var</code>仅适用于局部变量</td>
                </tr>
                <tr>
                    <td><code>const</code></td>
                    <td><code>final</code></td>
                    <td>C++<code>const</code>表示只读；Java<code>final</code>表示引用不可变</td>
                </tr>
                <tr>
                    <td><code>virtual</code></td>
                    <td><code>abstract</code>（方法）、默认非静态方法</td>
                    <td>C++需显式声明<code>virtual</code>启用多态；Java非静态方法默认可重写</td>
                </tr>
                <tr>
                    <td><code>new</code>/<code>delete</code></td>
                    <td><code>new</code>（无<code>delete</code>，GC自动回收）</td>
                    <td>C++需手动<code>delete</code>释放内存；Java<code>new</code>仅分配内存，GC自动回收</td>
                </tr>
            </tbody>
        </table>
    </section>
    
    <section class="content-section">
        <h2>2. 语义差异</h2>
        <p>语法差异是表象，语义差异是C++转Java过程中最易踩坑的核心——两者对内存、拷贝、引用的底层理解完全不同。</p>
        
        <h3>2.1 引用与指针的本质</h3>
        <p>C++与Java的"引用"语义存在本质差异，直接决定了内存操作的安全性。</p>
        
        <div class="flex-container">
            <div class="flex-item">
                <h4>C++引用</h4>
                <p>C++引用（<code>T&</code>）是变量的<strong>别名</strong>，在编译器底层通过指针实现：</p>
                <ul>
                    <li>必须在定义时初始化，且无法重新绑定到其他变量</li>
                    <li>不存在空引用（<code>nullptr</code>）</li>
                    <li>主要用于参数传递与返回值，避免拷贝开销</li>
                </ul>
            </div>
            <div class="flex-item">
                <h4>Java引用</h4>
                <p>Java引用是<strong>对象的句柄</strong>，本质为封装的指针：</p>
                <ul>
                    <li>可重绑定到其他对象，也可赋值为<code>null</code></li>
                    <li>仅能指向堆上的对象实例</li>
                    <li>JVM通过引用追踪对象可达性，自动回收无引用的对象</li>
                </ul>
            </div>
        </div>
        
        <h3>2.4 内存管理与生命周期</h3>
        <p>C++与Java的内存管理模型完全不同，直接决定了资源泄漏的风险与调试难度。</p>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>特性</th>
                    <th>C++</th>
                    <th>Java</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>管理方式</strong></td>
                    <td>手动（<code>new</code>/<code>delete</code>）+ RAII自动管理</td>
                    <td>自动GC（可达性分析）</td>
                </tr>
                <tr>
                    <td><strong>释放时机</strong></td>
                    <td>精确（对象析构时）</td>
                    <td>不确定（GC触发时）</td>
                </tr>
                <tr>
                    <td><strong>资源类型</strong></td>
                    <td>所有资源（内存、文件、锁）</td>
                    <td>仅内存（其他资源需手动关闭）</td>
                </tr>
                <tr>
                    <td><strong>安全风险</strong></td>
                    <td>内存泄漏、双重释放、悬空指针</td>
                    <td>内存泄漏（如强引用未释放）、GC停顿</td>
                </tr>
            </tbody>
        </table>
        
        <div class="tip">
            <h4>重要提示</h4>
            <p>C++转Java的核心挑战之一就是放弃手动内存管理思维，转而信任JVM的垃圾回收机制。虽然GC带来了便利，但也需要注意避免内存泄漏（如未释放强引用）和了解GC停顿对性能的影响。</p>
        </div>
    </section>
    
    <section class="content-section">
        <h2>3. 设计理念</h2>
        <p>C++与Java的面向对象设计理念差异，源于两者的核心设计目标：C++追求"零开销抽象"与灵活性，Java追求"简单安全"与跨平台。</p>
        
        <h3>3.1 核心设计哲学对比</h3>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>维度</th>
                    <th>C++</th>
                    <th>Java</th>
                    <th>核心设计目标</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>范式支持</strong></td>
                    <td>多范式（过程式、面向对象、泛型、函数式）</td>
                    <td>纯面向对象（辅以函数式特性，Java 8+）</td>
                    <td>C++兼容C语言，满足系统级开发需求；Java聚焦企业级开发</td>
                </tr>
                <tr>
                    <td><strong>信任模型</strong></td>
                    <td>"信任程序员"——赋予完全控制权</td>
                    <td>"保护程序员"——限制危险操作</td>
                    <td>C++允许直接操作内存、指针运算；Java禁止指针、自动GC</td>
                </tr>
                <tr>
                    <td><strong>抽象开销</strong></td>
                    <td>零开销抽象（You don't pay for what you don't use）</td>
                    <td>可控开销（JVM优化）</td>
                    <td>C++保证高级特性不牺牲性能；Java通过JVM优化平衡抽象与性能</td>
                </tr>
                <tr>
                    <td><strong>跨平台性</strong></td>
                    <td>编译为机器码，平台相关</td>
                    <td>编译为字节码，JVM跨平台</td>
                    <td>C++需针对不同平台重新编译；Java"一次编写，到处运行"（WORA）</td>
                </tr>
            </tbody>
        </table>
        
        <h3>3.2 面向对象特性的设计差异</h3>
        <p>尽管两者均支持封装、继承、多态三大OOP特性，但实现细节与设计意图存在显著差异。</p>
        
        <div class="highlight-box">
            <h4>继承差异关键点</h4>
            <p><strong>C++</strong>支持多继承（一个类可继承多个基类），但需用虚继承解决菱形继承问题。</p>
            <p><strong>Java</strong>不支持类多重继承，但支持接口多实现，通过<code>implements</code>实现多接口，避免了C++的菱形继承问题。</p>
        </div>
        
        <button class="toggle-button" onclick="toggleContent('inheritance-example')">显示继承示例</button>
        <div id="inheritance-example" class="toggle-content">
            <div class="flex-container">
                <div class="flex-item">
                    <h4>C++多继承（需处理菱形继承）</h4>
                    <div class="code-block cpp">
class A {};
class B : public A {};
class C : public A {};
class D : public B, public C {}; 
// 菱形继承：D包含两个A实例
                    </div>
                </div>
                <div class="flex-item">
                    <h4>Java接口多实现（无菱形继承问题）</h4>
                    <div class="code-block java">
interface Flyable { void fly(); }
interface Swimmable { void swim(); }

class Duck implements Flyable, Swimmable {
    public void fly() { /* ... */ }
    public void swim() { /* ... */ }
}
                    </div>
                </div>
            </div>
        </div>
    </section>
    
    <section class="content-section">
        <h2>4. API差异：标准库对比</h2>
        <p>C++标准库（STL）与Java标准库（JDK）的设计理念存在本质差异：STL以泛型编程为核心，追求效率与灵活性；JDK以面向对象为核心，追求易用性与完整性。</p>
        
        <h3>4.1 核心组件对比</h3>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>组件类型</th>
                    <th>C++ STL</th>
                    <th>Java JDK</th>
                    <th>设计理念差异</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>容器框架</strong></td>
                    <td>序列式容器（<code>vector</code>、<code>list</code>）、关联式容器（<code>map</code>、<code>set</code>）</td>
                    <td>集合框架（<code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>）</td>
                    <td>STL容器为值语义（拷贝时复制元素）；JDK集合为引用语义（拷贝时复制引用）</td>
                </tr>
                <tr>
                    <td><strong>算法库</strong></td>
                    <td><code>&lt;algorithm&gt;</code>（如<code>sort</code>、<code>find</code>）</td>
                    <td><code>Collections</code>工具类（如<code>sort</code>、<code>binarySearch</code>）</td>
                    <td>STL算法适用于所有容器（通过迭代器）；JDK算法仅适用于特定容器</td>
                </tr>
                <tr>
                    <td><strong>字符串处理</strong></td>
                    <td><code>std::string</code>（可变）</td>
                    <td><code>String</code>（不可变）、<code>StringBuilder</code>（可变）</td>
                    <td>STL字符串支持底层操作；JDK字符串强调不可变性与线程安全</td>
                </tr>
            </tbody>
        </table>
        
        <h3>4.2 容器框架的设计差异</h3>
        <p>STL与JDK容器的核心差异，在于"算法-容器解耦"与"值语义vs引用语义"。</p>
        
        <div class="key-point">
            <h4>STL：算法-容器-迭代器三元组</h4>
            <p>STL的核心设计是<strong>算法与容器分离</strong>，通过迭代器作为桥梁——算法仅依赖迭代器的接口，不依赖具体容器类型。</p>
        </div>
        
        <div class="key-point">
            <h4>JDK：接口-实现耦合</h4>
            <p>JDK集合框架的设计是<strong>算法与容器耦合</strong>——算法作为容器类的方法或<code>Collections</code>工具类的静态方法存在，仅适用于特定容器类型。</p>
        </div>
        
        <h3>4.5 并发编程API</h3>
        <p>C++11的并发库与Java的<code>java.util.concurrent</code>包均支持多线程编程，但抽象层级不同。</p>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>特性</th>
                    <th>C++ 并发库（C++11+）</th>
                    <th>Java <code>java.util.concurrent</code></th>
                    <th>差异说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>线程管理</strong></td>
                    <td><code>std::thread</code>（底层线程句柄）</td>
                    <td><code>Thread</code>、<code>ExecutorService</code>（线程池）</td>
                    <td>C++<code>std::thread</code>为底层封装；Java线程池为高层抽象，自动管理线程复用</td>
                </tr>
                <tr>
                    <td><strong>同步机制</strong></td>
                    <td><code>std::mutex</code>、<code>std::condition_variable</code></td>
                    <td><code>synchronized</code>关键字、<code>Lock</code>接口</td>
                    <td>C++同步机制为底层API；Java<code>Lock</code>接口比<code>synchronized</code>更灵活</td>
                </tr>
                <tr>
                    <td><strong>任务异步</strong></td>
                    <td><code>std::future</code>、<code>std::promise</code></td>
                    <td><code>Future</code>、<code>CompletableFuture</code>（Java 8+）</td>
                    <td>C++<code>future</code>仅支持阻塞获取结果；Java<code>CompletableFuture</code>支持链式异步操作</td>
                </tr>
            </tbody>
        </table>
    </section>
    
    <section class="content-section">
        <h2>5. 总结与迁移建议</h2>
        <p>C++转Java的核心挑战，不是语法的差异，而是<strong>思维方式的转变</strong>——从"手动控制一切"转向"信任JVM与框架"，从"效率优先"转向"安全与可维护性优先"。</p>
        
        <h3>5.1 核心差异速查表</h3>
        
        <table class="comparison-table">
            <thead>
                <tr>
                    <th>维度</th>
                    <th>C++</th>
                    <th>Java</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>编程范式</strong></td>
                    <td>多范式（过程式、OOP、泛型）</td>
                    <td>纯OOP（辅以函数式）</td>
                </tr>
                <tr>
                    <td><strong>内存管理</strong></td>
                    <td>手动（<code>new</code>/<code>delete</code>）+ RAII</td>
                    <td>自动GC</td>
                </tr>
                <tr>
                    <td><strong>引用模型</strong></td>
                    <td>指针+左值/右值引用（不可重绑定）</td>
                    <td>对象引用（可重绑定，无指针）</td>
                </tr>
                <tr>
                    <td><strong>拷贝语义</strong></td>
                    <td>默认值语义（深拷贝）</td>
                    <td>默认引用语义（浅拷贝）</td>
                </tr>
                <tr>
                    <td><strong>继承模型</strong></td>
                    <td>多继承（需虚继承解决菱形问题）</td>
                    <td>单继承+多接口实现</td>
                </tr>
                <tr>
                    <td><strong>异常处理</strong></td>
                    <td>非强制，可抛任意类型</td>
                    <td>强制受检异常，仅抛<code>Throwable</code>子类</td>
                </tr>
            </tbody>
        </table>
        
        <h3>5.2 迁移建议</h3>
        
        <div class="warning">
            <h4>重要迁移建议</h4>
            <ol>
                <li><strong>放弃指针思维</strong>：Java无显式指针，依赖JVM的内存安全机制</li>
                <li><strong>拥抱GC与RAII替代</strong>：Java的GC自动回收内存，非内存资源需用<code>try-with-resources</code>管理</li>
                <li><strong>理解引用语义</strong>：Java对象赋值仅拷贝引用，修改对象内容会影响原对象</li>
                <li><strong>优先组合而非继承</strong>：Java仅支持单继承，应通过接口与组合实现代码复用</li>
                <li><strong>适应OOP纯范式</strong>：Java所有代码必须在类中，全局功能用静态方法模拟</li>
                <li><strong>利用JDK标准库</strong>：优先使用JDK内置工具类，避免重复造轮子</li>
                <li><strong>处理异常正确</strong>：Java受检异常需强制处理，不要忽略异常</li>
                <li><strong>学习lambda与Stream</strong>：Java 8+的lambda与Stream API提供了函数式编程能力</li>
            </ol>
        </div>
        
        <div class="note">
            <p>通过理解上述差异与建议，C++开发者可快速掌握Java的核心特性，写出符合Java设计哲学的高质量代码。</p>
        </div>
    </section>
    
    <footer>
        <p>C++转Java指南：语法、语义、设计理念与API差异详解</p>
        <p>本指南内容由AI生成，仅供参考学习</p>
    </footer>
    
    <script>
        // 简单的折叠功能
        function toggleContent(id) {
            const content = document.getElementById(id);
            content.classList.toggle('expanded');
            
            const button = content.previousElementSibling;
            if (content.classList.contains('expanded')) {
                button.textContent = '隐藏代码示例';
            } else {
                button.textContent = '显示代码示例';
            }
        }
        
        // 默认展开第一个代码示例
        document.addEventListener('DOMContentLoaded', function() {
            // 可以在这里添加任何初始化逻辑
        });
    </script>
</body>
</html>