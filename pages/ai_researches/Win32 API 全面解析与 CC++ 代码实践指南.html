<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Win32 API 全面解析与 C/C++ 代码实践指南</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #2a3a7c);
            color: #e0e0e0;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(25, 35, 45, 0.95);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            padding: 30px;
            border: 1px solid #3a4a6c;
        }
        
        header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #4a5a8c;
        }
        
        h1 {
            color: #4da6ff;
            font-size: 2.8rem;
            margin-bottom: 15px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.7);
        }
        
        .subtitle {
            color: #a0c8ff;
            font-size: 1.3rem;
            font-style: italic;
        }
        
        h2 {
            color: #66b3ff;
            margin: 30px 0 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #3a5a8c;
            font-size: 1.8rem;
        }
        
        h3 {
            color: #80ccff;
            margin: 25px 0 12px;
            font-size: 1.4rem;
        }
        
        h4 {
            color: #99ddff;
            margin: 20px 0 10px;
            font-size: 1.2rem;
        }
        
        p {
            margin: 15px 0;
            text-align: justify;
        }
        
        .section {
            background: rgba(40, 50, 70, 0.7);
            border-radius: 8px;
            padding: 20px;
            margin: 25px 0;
            border-left: 5px solid #4a7bc8;
        }
        
        .highlight {
            background-color: rgba(30, 60, 90, 0.7);
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #5a9de0;
        }
        
        .code-block {
            background-color: #0d1b2a;
            color: #cce7ff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            border: 1px solid #2a4a6a;
        }
        
        .code-block code {
            display: block;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .note {
            background-color: rgba(30, 50, 30, 0.7);
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #4ca64c;
        }
        
        .warning {
            background-color: rgba(80, 50, 30, 0.7);
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border-left: 4px solid #ff9966;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: rgba(30, 40, 60, 0.8);
        }
        
        th {
            background-color: #2a4a7c;
            color: #cce7ff;
            padding: 12px;
            text-align: left;
            border: 1px solid #3a5a8c;
        }
        
        td {
            padding: 10px 12px;
            border: 1px solid #3a5a8c;
            vertical-align: top;
        }
        
        tr:nth-child(even) {
            background-color: rgba(40, 50, 80, 0.6);
        }
        
        .timeline {
            position: relative;
            padding-left: 30px;
            margin: 20px 0;
        }
        
        .timeline-item {
            position: relative;
            margin-bottom: 25px;
            padding-left: 20px;
        }
        
        .timeline-item:before {
            content: '';
            position: absolute;
            left: -6px;
            top: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #4da6ff;
        }
        
        .timeline-item:after {
            content: '';
            position: absolute;
            left: 0;
            top: 17px;
            width: 2px;
            height: calc(100% + 8px);
            background-color: #4da6ff;
        }
        
        .timeline-item:last-child:after {
            display: none;
        }
        
        .timeline-year {
            color: #4da6ff;
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 5px;
        }
        
        .timeline-desc {
            color: #cce7ff;
        }
        
        details {
            background-color: rgba(40, 50, 70, 0.5);
            border-radius: 8px;
            margin: 15px 0;
            padding: 5px;
            border: 1px solid #3a5a8c;
        }
        
        summary {
            padding: 15px;
            font-weight: bold;
            cursor: pointer;
            color: #80ccff;
            font-size: 1.1rem;
            list-style: none;
        }
        
        summary::-webkit-details-marker {
            display: none;
        }
        
        summary:before {
            content: '▶';
            margin-right: 10px;
            color: #4da6ff;
            display: inline-block;
            transition: transform 0.3s;
        }
        
        details[open] summary:before {
            transform: rotate(90deg);
        }
        
        .details-content {
            padding: 0 15px 15px 15px;
        }
        
        .pill {
            display: inline-block;
            background-color: #3a5a8c;
            color: #e0f0ff;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            margin: 2px 5px;
        }
        
        .comparison-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
        }
        
        .comparison-header {
            background-color: #2a4a7c;
            padding: 12px;
            font-weight: bold;
            text-align: center;
            border-radius: 6px 6px 0 0;
        }
        
        .comparison-cell {
            background-color: rgba(30, 40, 60, 0.8);
            padding: 15px;
            border-radius: 0 0 6px 6px;
            min-height: 100px;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #3a5a8c;
            color: #a0c8ff;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .comparison-table {
                grid-template-columns: 1fr;
            }
            
            .code-block {
                padding: 15px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Win32 API 全面解析与 C/C++ 代码实践指南</h1>
            <p class="subtitle">Windows 系统原生应用程序编程接口深度解析</p>
        </header>
        
        <div class="section">
            <h2>1. 引言：Win32 API 的核心定位与历史演进</h2>
            <p>Win32 API（现官方统一称为 Windows API）是微软 Windows 操作系统的原生应用程序编程接口，是连接用户态应用与系统内核服务的核心桥梁。它直接以 C 语言风格设计，支持 32/64 位 Windows 系统，是桌面应用、系统工具及高性能服务端开发的底层基础。</p>
            
            <div class="highlight">
                <h3>1.1 历史演进：从 16 位到 64 位的兼容逻辑</h3>
                <p>Win32 API 的演进与 Windows 系统架构的迭代高度绑定，其核心里程碑与兼容机制如下：</p>
                
                <div class="timeline">
                    <div class="timeline-item">
                        <div class="timeline-year">1980s 末</div>
                        <div class="timeline-desc">16 位 Windows API 诞生，仅支持 16 位地址空间与单任务/协程模型</div>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-year">1993 年</div>
                        <div class="timeline-desc">首次引入 Win32 API，支持 32 位虚拟地址空间、多线程与 preemptive 调度，成为现代 Windows 开发的基石</div>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-year">1995 年</div>
                        <div class="timeline-desc">Win32 API 向下兼容 16 位应用（via WOW32 子系统），成为桌面开发主流接口</div>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-year">2001 年</div>
                        <div class="timeline-desc">完成 32/64 位架构整合，Win32 API 正式支持 64 位扩展（Win64 API）</div>
                    </div>
                    <div class="timeline-item">
                        <div class="timeline-year">2015 年至今</div>
                        <div class="timeline-desc">引入 UWP、WinUI 等现代框架，但 Win32 API 仍为底层核心，官方承诺长期维护</div>
                    </div>
                </div>
                
                <p>对于 64 位 Windows 系统，32 位 Win32 应用的兼容由 <strong>WoW64（Windows 32-bit on Windows 64-bit）</strong> 子系统实现：该层通过 <code>wow64.dll</code>（核心仿真层）、<code>wow64win.dll</code>（Win32k.sys 系统调用转换）等模块，将 32 位 API 调用转换为 64 位原生调用。</p>
            </div>
            
            <div class="highlight">
                <h3>1.2 Windows 系统架构中的 Win32 层级</h3>
                <p>Windows 采用分层架构（用户态 Ring3 / 内核态 Ring0），Win32 API 位于用户态最底层：</p>
                
                <table>
                    <tr>
                        <th>层级</th>
                        <th>核心组件</th>
                        <th>功能描述</th>
                    </tr>
                    <tr>
                        <td>0（内核态）</td>
                        <td>硬件抽象层（HAL.dll）+ 内核（Ntoskrnl.exe）</td>
                        <td>直接与硬件交互，管理进程/线程调度、内存、I/O 等核心资源</td>
                    </tr>
                    <tr>
                        <td>1（用户态）</td>
                        <td>NT Native API（Ntdll.dll）</td>
                        <td>用户态与内核态的直接接口，Win32 API 的底层依赖</td>
                    </tr>
                    <tr>
                        <td>2（用户态）</td>
                        <td>Win32 API 骨干（Kernel32.dll、User32.dll、GDI32.dll 等）</td>
                        <td>向应用暴露核心功能：Kernel32 负责进程/内存/文件系统，User32 负责窗口管理与消息，GDI32 负责图形绘制</td>
                    </tr>
                    <tr>
                        <td>3（用户态）</td>
                        <td>扩展 API（如 DirectX、WinRT）</td>
                        <td>建立在 Win32 API 之上的垂直领域扩展</td>
                    </tr>
                </table>
                
                <p>Win32 API 的调用流程为：应用调用 User32/Kernel32 中的函数 → 函数内部转换为 Native API 调用 → 通过系统调用（syscall）从用户态切换到内核态 → 内核执行对应服务 → 将结果返回给应用。</p>
            </div>
            
            <div class="note">
                <h3>1.3 与现代框架的关系：Win32 API 的不可替代性</h3>
                <p>尽管 .NET（WPF、Windows Forms）、WinRT（UWP、WinUI 3）等框架已成为 Windows 开发的主流选择，但 Win32 API 仍具有不可替代的核心地位：</p>
                <ul>
                    <li><strong>.NET 框架</strong>：其底层（如 <code>System.IO</code>、<code>System.Threading</code>）完全通过 P/Invoke 调用 Win32 API 实现</li>
                    <li><strong>WinRT 框架</strong>：WinRT 是 Windows 10 后推出的现代 API 集合，但仍需依赖 Win32 API 实现底层系统访问</li>
                </ul>
                <p>简言之，Win32 API 是 Windows 生态的基石，所有上层框架均构建于其上。</p>
            </div>
        </div>
        
        <div class="section">
            <h2>2. 基础入门：第一个 Win32 API 程序</h2>
            <p>本节将通过经典的「Hello World」窗口程序，展示 Win32 API 的基本开发流程与核心概念。</p>
            
            <details>
                <summary>2.1 开发环境准备</summary>
                <div class="details-content">
                    <p>Win32 API 开发需配置支持原生 Windows 编译的工具链，推荐以下两种方案：</p>
                    <div class="comparison-table">
                        <div>
                            <div class="comparison-header">方案 1：Microsoft Visual Studio（推荐）</div>
                            <div class="comparison-cell">MSVC 是微软官方编译器，对 Win32 API 支持最完善。需安装「使用 C++ 的桌面开发」 workload，该组件会自动配置 Windows SDK。</div>
                        </div>
                        <div>
                            <div class="comparison-header">方案 2：MinGW-w64</div>
                            <div class="comparison-cell">MinGW-w64 是开源的 Windows 编译工具链，支持 32/64 位编译。需下载安装包并将其 <code>bin</code> 目录添加至系统 PATH 环境变量。</div>
                        </div>
                    </div>
                </div>
            </details>
            
            <details>
                <summary>2.2 编写代码：完整的窗口程序</summary>
                <div class="details-content">
                    <p>以下是使用 Unicode 编码的完整 C++ 代码，核心包含窗口类注册、窗口创建、消息循环与窗口过程四大模块：</p>
                    
                    <div class="code-block">
                        <code>#include &lt;windows.h&gt;

// 窗口过程：处理所有发送到窗口的消息
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, 
                           WPARAM wParam, LPARAM lParam);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   PWSTR pCmdLine, int nCmdShow) {
    // 1. 注册窗口类
    WNDCLASSEX wc = {0};
    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = hInstance;
    wc.lpszClassName = L"Sample Window Class";
    
    RegisterClassEx(&wc);
    
    // 2. 创建窗口
    HWND hwnd = CreateWindowEx(
        0,                          // 扩展样式
        L"Sample Window Class",     // 窗口类名
        L"我的第一个 Win32 窗口",   // 窗口标题
        WS_OVERLAPPEDWINDOW,        // 窗口样式
        CW_USEDEFAULT, CW_USEDEFAULT, // 位置
        640, 480,                   // 大小
        NULL, NULL, hInstance, NULL
    );
    
    // 3. 显示窗口
    ShowWindow(hwnd, nCmdShow);
    UpdateWindow(hwnd);
    
    // 4. 消息循环
    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    
    return (int)msg.wParam;
}

// 窗口过程实现
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, 
                           WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
        case WM_PAINT: {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);
            
            const wchar_t text[] = L"Hello, Win32 API!";
            TextOutW(hdc, 50, 50, text, ARRAYSIZE(text) - 1);
            
            EndPaint(hwnd, &ps);
            return 0;
        }
        
        case WM_DESTROY:
            PostQuitMessage(0);
            return 0;
            
        default:
            return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
}</code>
                    </div>
                </div>
            </details>
            
            <div class="highlight">
                <h3>2.3 代码解释：核心概念</h3>
                <p>上述代码涉及 Win32 API 的三大核心概念，是所有 Win32 应用的基础：</p>
                <ol>
                    <li><strong>窗口类（Window Class）</strong>：<code>WNDCLASSEX</code> 结构描述了窗口的核心属性，<code>RegisterClassEx</code> 向系统注册该类。</li>
                    <li><strong>窗口句柄（HWND）</strong>：<code>CreateWindowEx</code> 返回的 <code>HWND</code> 是窗口的唯一标识符。</li>
                    <li><strong>消息循环（Message Loop）</strong>：<code>GetMessage</code> 从消息队列中获取消息，<code>DispatchMessage</code> 将消息分发到窗口过程。</li>
                    <li><strong>窗口过程（Window Procedure）</strong>：<code>WindowProc</code> 是回调函数，系统将所有发送到窗口的消息转发至此函数。</li>
                </ol>
            </div>
            
            <details>
                <summary>2.4 编译与运行</summary>
                <div class="details-content">
                    <p>针对不同工具链，编译命令如下：</p>
                    
                    <div class="code-block">
                        <code># Visual Studio 命令行
cl /EHsc hello_win32.cpp user32.lib gdi32.lib

# MinGW-w64
g++ hello_win32.cpp -o hello_win32.exe -mwindows -luser32 -lgdi32</code>
                    </div>
                </div>
            </details>
        </div>
        
        <div class="section">
            <h2>3. 核心模块深入：窗口与消息机制</h2>
            <p>窗口与消息机制是 Win32 API 的核心，所有 GUI 应用的交互逻辑均基于此。</p>
            
            <div class="highlight">
                <h3>3.1 窗口管理：CreateWindowEx 与窗口样式</h3>
                <p><code>CreateWindowEx</code> 是创建窗口的核心函数，其扩展样式（<code>dwExStyle</code>）与基础样式（<code>dwStyle</code>）决定了窗口的外观与行为。</p>
                
                <div class="code-block">
                    <code>HWND CreateWindowEx(
    DWORD dwExStyle,      // 扩展窗口样式
    LPCWSTR lpClassName,  // 窗口类名（已注册）
    LPCWSTR lpWindowName, // 窗口标题
    DWORD dwStyle,        // 窗口样式
    int x, int y,         // 初始坐标
    int nWidth, int nHeight, // 初始大小
    HWND hWndParent,      // 父窗口句柄
    HMENU hMenu,          // 菜单句柄
    HINSTANCE hInstance,  // 实例句柄
    LPVOID lpParam        // 创建参数
);</code>
                </div>
                
                <h4>常用窗口样式</h4>
                <table>
                    <tr>
                        <th>样式常量</th>
                        <th>含义</th>
                        <th>适用场景</th>
                    </tr>
                    <tr>
                        <td><code>WS_OVERLAPPEDWINDOW</code></td>
                        <td>组合样式：带标题栏、边框、最大化/最小化按钮、系统菜单</td>
                        <td>主窗口</td>
                    </tr>
                    <tr>
                        <td><code>WS_CHILD</code></td>
                        <td>子窗口样式（必须指定父窗口）</td>
                        <td>按钮、文本框等控件</td>
                    </tr>
                    <tr>
                        <td><code>WS_POPUP</code></td>
                        <td>弹出窗口样式（无标题栏）</td>
                        <td>对话框、提示框</td>
                    </tr>
                    <tr>
                        <td><code>WS_EX_LAYERED</code></td>
                        <td>分层窗口样式（支持透明度与异形窗口）</td>
                        <td>半透明窗口、自定义形状窗口</td>
                    </tr>
                </table>
            </div>
            
            <div class="highlight">
                <h3>3.2 消息机制：深入理解 Windows 消息循环</h3>
                <p>Windows 是<strong>消息驱动（Message-Driven）</strong>的操作系统，所有用户交互、系统事件均以消息的形式传递。</p>
                
                <h4>核心消息类型</h4>
                <table>
                    <tr>
                        <th>消息常量</th>
                        <th>触发条件</th>
                        <th>处理要点</th>
                    </tr>
                    <tr>
                        <td><code>WM_PAINT</code></td>
                        <td>窗口客户区需要重绘</td>
                        <td>必须调用 <code>BeginPaint</code>/<code>EndPaint</code> 配对函数</td>
                    </tr>
                    <tr>
                        <td><code>WM_COMMAND</code></td>
                        <td>用户操作菜单、按钮或快捷键</td>
                        <td>通过 <code>LOWORD(wParam)</code> 获取控件 ID</td>
                    </tr>
                    <tr>
                        <td><code>WM_MOUSEMOVE</code></td>
                        <td>鼠标在窗口内移动</td>
                        <td>通过 <code>lParam</code> 获取鼠标坐标</td>
                    </tr>
                    <tr>
                        <td><code>WM_DESTROY</code></td>
                        <td>窗口被销毁</td>
                        <td>必须调用 <code>PostQuitMessage(0)</code></td>
                    </tr>
                </table>
                
                <h4>消息发送与处理流程</h4>
                <ol>
                    <li><strong>消息生成</strong>：系统或应用生成消息</li>
                    <li><strong>消息队列</strong>：消息被放入对应线程的消息队列</li>
                    <li><strong>消息循环</strong>：应用通过 <code>GetMessage</code> 获取消息</li>
                    <li><strong>消息处理</strong>：窗口过程根据消息类型执行逻辑</li>
                </ol>
            </div>
            
            <div class="highlight">
                <h3>3.3 绘图基础：GDI 与设备上下文（HDC）</h3>
                <p>图形设备接口（GDI）是 Win32 API 中负责图形输出的模块，通过设备上下文（HDC）实现与硬件无关的绘图。</p>
                
                <div class="code-block">
                    <code>case WM_PAINT: {
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hwnd, &ps);
    
    // 创建红色画笔
    HPEN hPenRed = CreatePen(PS_SOLID, 2, RGB(255, 0, 0));
    // 创建蓝色画刷
    HBRUSH hBrushBlue = CreateSolidBrush(RGB(0, 0, 255));
    
    // 选入 HDC
    HPEN hOldPen = (HPEN)SelectObject(hdc, hPenRed);
    HBRUSH hOldBrush = (HBRUSH)SelectObject(hdc, hBrushBlue);
    
    // 绘制矩形
    Rectangle(hdc, 100, 100, 300, 200);
    
    // 恢复原 GDI 对象
    SelectObject(hdc, hOldPen);
    SelectObject(hdc, hOldBrush);
    
    // 释放 GDI 对象
    DeleteObject(hPenRed);
    DeleteObject(hBrushBlue);
    
    EndPaint(hwnd, &ps);
    return 0;
}</code>
                </div>
                
                <h4>GDI+ 与传统 GDI 的差异</h4>
                <div class="comparison-table">
                    <div>
                        <div class="comparison-header">传统 GDI</div>
                        <div class="comparison-cell">
                            <ul>
                                <li>过程式（函数调用）</li>
                                <li>需手动设置抗锯齿</li>
                                <li>仅支持 BMP、ICO 等基础格式</li>
                                <li>性能更高</li>
                            </ul>
                        </div>
                    </div>
                    <div>
                        <div class="comparison-header">GDI+</div>
                        <div class="comparison-cell">
                            <ul>
                                <li>面向对象（类如 <code>Graphics</code>、<code>Pen</code>）</li>
                                <li>默认支持抗锯齿</li>
                                <li>支持 JPEG、PNG、GIF 等主流格式</li>
                                <li>支持复杂文本布局</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>4. 系统核心：进程、线程与内存管理</h2>
            <p>Win32 API 提供了一套完整的进程、线程与内存管理接口，是系统级开发与性能优化的关键。</p>
            
            <details>
                <summary>4.1 进程管理：CreateProcess 与进程生命周期</summary>
                <div class="details-content">
                    <p>进程是 Windows 资源分配的基本单位，每个进程拥有独立的虚拟地址空间、文件句柄与环境变量。</p>
                    
                    <div class="code-block">
                        <code>#include &lt;windows.h&gt;

int main() {
    STARTUPINFOW si = {0};
    si.cb = sizeof(STARTUPINFOW);
    PROCESS_INFORMATION pi;
    
    // 创建新进程：启动 Notepad.exe
    BOOL success = CreateProcess(
        L"C:\\Windows\\notepad.exe",  // 可执行文件路径
        L"notepad.exe test.txt",     // 命令行参数
        NULL, NULL, FALSE, 0, NULL, NULL,
        &si, &pi
    );
    
    if (success) {
        printf("进程创建成功！PID: %lu\n", pi.dwProcessId);
        
        // 关闭句柄
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    
    return 0;
}</code>
                    </div>
                    
                    <h4>进程与线程的差异</h4>
                    <table>
                        <tr>
                            <th>维度</th>
                            <th>进程</th>
                            <th>线程</th>
                        </tr>
                        <tr>
                            <td>资源</td>
                            <td>拥有独立的虚拟地址空间、文件句柄</td>
                            <td>共享所属进程的所有资源</td>
                        </tr>
                        <tr>
                            <td>调度</td>
                            <td>操作系统调度的基本单位，切换开销大</td>
                            <td>调度的基本单位，切换开销小</td>
                        </tr>
                        <tr>
                            <td>通信</td>
                            <td>需通过跨进程通信（IPC）机制</td>
                            <td>可通过全局变量、事件等同步机制直接通信</td>
                        </tr>
                    </table>
                </div>
            </details>
            
            <details>
                <summary>4.2 线程管理：CreateThread 与同步机制</summary>
                <div class="details-content">
                    <p>线程是操作系统调度的基本单位，一个进程可包含多个线程，共享进程的资源。</p>
                    
                    <div class="code-block">
                        <code>DWORD WINAPI ThreadProc(LPVOID lpParameter) {
    int param = *(int*)lpParameter;
    printf("线程 %lu 启动，参数: %d\n", 
           GetCurrentThreadId(), param);
    
    Sleep(2000);  // 模拟线程工作
    
    printf("线程 %lu 结束\n", GetCurrentThreadId());
    return 0;
}

int main() {
    int param = 123;
    HANDLE hThread = CreateThread(
        NULL, 0, ThreadProc, &param, 0, NULL
    );
    
    // 等待线程结束
    WaitForSingleObject(hThread, INFINITE);
    
    CloseHandle(hThread);
    return 0;
}</code>
                    </div>
                    
                    <h4>线程同步机制</h4>
                    <table>
                        <tr>
                            <th>同步对象</th>
                            <th>适用场景</th>
                            <th>核心函数</th>
                        </tr>
                        <tr>
                            <td><strong>临界区（Critical Section）</strong></td>
                            <td>进程内多线程同步（最常用）</td>
                            <td><code>EnterCriticalSection</code>, <code>LeaveCriticalSection</code></td>
                        </tr>
                        <tr>
                            <td><strong>互斥量（Mutex）</strong></td>
                            <td>跨进程或进程内同步（可命名）</td>
                            <td><code>CreateMutex</code>, <code>ReleaseMutex</code></td>
                        </tr>
                        <tr>
                            <td><strong>事件（Event）</strong></td>
                            <td>线程间信号通知</td>
                            <td><code>CreateEvent</code>, <code>SetEvent</code></td>
                        </tr>
                        <tr>
                            <td><strong>信号量（Semaphore）</strong></td>
                            <td>控制同时访问资源的线程数量</td>
                            <td><code>CreateSemaphore</code>, <code>ReleaseSemaphore</code></td>
                        </tr>
                    </table>
                </div>
            </details>
            
            <details open>
                <summary>4.3 内存管理：VirtualAlloc 与虚拟内存</summary>
                <div class="details-content">
                    <p>Win32 API 提供了底层虚拟内存管理接口，允许开发者直接控制进程的地址空间。</p>
                    
                    <h4>虚拟内存的核心概念</h4>
                    <p>Windows 虚拟内存采用「预留（Reserve）-提交（Commit）」两步模型：</p>
                    <ol>
                        <li><strong>预留（Reserve）</strong>：在进程地址空间中标记一段连续的地址范围，但不分配物理内存</li>
                        <li><strong>提交（Commit）</strong>：为已预留的地址范围分配物理内存或页文件空间</li>
                        <li><strong>释放（Release）</strong>：释放已提交的内存，或同时释放预留的地址空间</li>
                    </ol>
                    
                    <div class="code-block">
                        <code>#include &lt;windows.h&gt;

int main() {
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    DWORD dwPageSize = si.dwPageSize;
    
    // 1. 预留内存（仅占地址空间，不分配物理内存）
    LPVOID lpvBase = VirtualAlloc(
        NULL,                    // 系统分配起始地址
        dwPageSize * 80,        // 预留大小（80 页）
        MEM_RESERVE,            // 分配类型：预留
        PAGE_NOACCESS           // 保护属性：不可访问
    );
    
    // 2. 提交第一页内存
    LPVOID lpvCommit = VirtualAlloc(
        lpvBase,                // 起始地址
        dwPageSize,             // 提交大小（1 页）
        MEM_COMMIT,             // 分配类型：提交
        PAGE_READWRITE          // 保护属性：可读可写
    );
    
    // 3. 使用内存
    memset(lpvCommit, 0xAA, dwPageSize);
    
    // 4. 释放所有内存
    VirtualFree(lpvBase, 0, MEM_RELEASE);
    
    return 0;
}</code>
                    </div>
                </div>
            </details>
        </div>
        
        <div class="section">
            <h2>5. 高级特性：安全、性能与现代 UI 适配</h2>
            <p>本节介绍 Win32 API 在现代开发中的高级特性，包括 UAC 权限提升、大内存页优化、IOCP 高并发与 WinUI 3 互操作。</p>
            
            <details>
                <summary>5.1 安全编程：UAC 权限提升与 SDL 规范</summary>
                <div class="details-content">
                    <p>Windows 用户账户控制（UAC）是系统安全的核心机制，Win32 API 提供了对应的权限提升接口。</p>
                    
                    <div class="code-block">
                        <code>#include &lt;windows.h&gt;
#include &lt;shellapi.h&gt;

int main() {
    SHELLEXECUTEINFOW sei = {0};
    sei.cbSize = sizeof(SHELLEXECUTEINFOW);
    sei.lpVerb = L"runas";  // 动作：以管理员身份运行
    sei.lpFile = L"C:\\Windows\\notepad.exe";
    sei.nShow = SW_SHOWNORMAL;
    
    // 执行权限提升
    BOOL success = ShellExecuteExW(&sei);
    
    if (!success) {
        DWORD dwError = GetLastError();
        if (dwError == ERROR_CANCELLED) {
            printf("用户取消了权限提升\n");
        }
        return 1;
    }
    
    return 0;
}</code>
                    </div>
                    
                    <div class="warning">
                        <h4>安全开发生命周期（SDL）规范</h4>
                        <p>微软 SDL 规范定义了 Win32 API 开发的安全基线：</p>
                        <ol>
                            <li><strong>禁用危险函数</strong>：禁止使用易导致缓冲区溢出的 C 标准库函数（如 <code>strcpy</code>、<code>sprintf</code>）</li>
                            <li><strong>启用安全编译选项</strong>：在 MSVC 中启用 <code>/SDL</code>（SDL 安全检查）、<code>/GS</code>（缓冲区安全检查）</li>
                            <li><strong>最小权限原则</strong>：应用应使用最低必要权限运行</li>
                            <li><strong>输入验证</strong>：对所有用户输入、文件数据进行严格验证</li>
                        </ol>
                    </div>
                </div>
            </details>
            
            <details>
                <summary>5.2 性能优化：大内存页与 IOCP</summary>
                <div class="details-content">
                    <p>Win32 API 提供了多种性能优化工具，其中大内存页与 IOCP 是最核心的两个特性。</p>
                    
                    <h4>大内存页（Large Page）</h4>
                    <p>大内存页（通常为 2MB 或 1GB）的核心优势是减少 CPU 翻译后备缓冲区（TLB）的命中率，提升内存密集型应用的性能。</p>
                    
                    <div class="code-block">
                        <code>// 启用 SE_LOCK_MEMORY 特权（大内存页必须）
BOOL EnablePrivilege(const wchar_t* pszPrivilege, BOOL bEnable);

int main() {
    // 1. 启用 SE_LOCK_MEMORY 特权
    if (!EnablePrivilege(SE_LOCK_MEMORY_NAME, TRUE)) {
        return 1;
    }
    
    // 2. 获取大内存页的最小大小
    SIZE_T dwLargePageSize = GetLargePageMinimum();
    
    // 3. 分配大内存页
    LPVOID lpvBase = VirtualAlloc(
        NULL,
        dwLargePageSize * 2,  // 分配 2 个大内存页
        MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES,
        PAGE_READWRITE
    );
    
    // 4. 使用大内存页
    memset(lpvBase, 0xAA, dwLargePageSize * 2);
    
    // 5. 释放大内存页
    VirtualFree(lpvBase, 0, MEM_RELEASE);
    
    return 0;
}</code>
                    </div>
                    
                    <div class="note">
                        <h4>I/O 完成端口（IOCP）</h4>
                        <p>IOCP（I/O Completion Port）是 Windows 平台下最高效的高并发 I/O 模型，核心优势是<strong>线程池复用</strong>与<strong>内核级 I/O 完成通知</strong>。</p>
                        <p>IOCP 的核心流程：</p>
                        <ol>
                            <li><strong>创建完成端口</strong>：通过 <code>CreateIoCompletionPort</code> 创建完成端口对象</li>
                            <li><strong>绑定 I/O 句柄</strong>：将套接字、文件等 I/O 句柄绑定到完成端口</li>
                            <li><strong>提交异步 I/O 请求</strong>：通过 <code>WSARecv</code>、<code>WriteFile</code> 等异步函数提交 I/O 请求</li>
                            <li><strong>工作线程处理</strong>：工作线程通过 <code>GetQueuedCompletionStatus</code> 等待 I/O 完成通知</li>
                        </ol>
                    </div>
                </div>
            </details>
            
            <details>
                <summary>5.3 现代 UI 适配：Win32 API 与 WinUI 3 互操作</summary>
                <div class="details-content">
                    <p>WinUI 3 是微软推出的现代 UI 框架，但 Win32 API 仍可通过互操作机制嵌入 WinUI 3 应用。</p>
                    
                    <div class="code-block">
                        <code>// WinUI 3 代码中嵌入 Win32 窗口
#include &lt;windows.h&gt;

// 获取 WinUI 3 窗口的 HWND 句柄
HWND hWndWinUI = WindowNative::GetWindowHandle(window);

// 创建传统 Win32 窗口（作为子窗口嵌入 WinUI 3）
HWND hWndWin32 = CreateWindowEx(
    0,
    L"Win32EmbeddedWindowClass",
    L"嵌入的 Win32 窗口",
    WS_CHILD | WS_VISIBLE,
    10, 10, 300, 200,
    hWndWinUI,  // 父窗口为 WinUI 3 窗口的 HWND
    NULL,
    GetModuleHandle(NULL),
    NULL
);

// 在 Win32 窗口中绘制文本
HDC hdc = GetDC(hWndWin32);
const wchar_t text[] = L"Hello from Win32 API!";
TextOutW(hdc, 50, 50, text, ARRAYSIZE(text) - 1);
ReleaseDC(hWndWin32, hdc);</code>
                    </div>
                    
                    <div class="warning">
                        <p><strong>注意事项</strong>：</p>
                        <ul>
                            <li>需在 WinUI 3 项目中添加 <code>#include &lt;Windows.h&gt;</code> 头文件</li>
                            <li>嵌入的 Win32 窗口需设置 <code>WS_CHILD</code> 样式</li>
                            <li>互操作可能存在性能开销，应仅在必要时使用</li>
                        </ul>
                    </div>
                </div>
            </details>
        </div>
        
        <div class="section">
            <h2>6. 工程实践：工具链、调试与兼容性</h2>
            
            <div class="highlight">
                <h3>6.1 开发工具链</h3>
                <p>Win32 API 开发的核心工具链包括编译器、构建系统与 SDK：</p>
                
                <table>
                    <tr>
                        <th>工具链</th>
                        <th>描述</th>
                        <th>适用场景</th>
                    </tr>
                    <tr>
                        <td><strong>Microsoft Visual Studio</strong></td>
                        <td>官方 IDE，集成 MSVC 编译器、Windows SDK 与调试工具</td>
                        <td>企业级开发、GUI 应用</td>
                    </tr>
                    <tr>
                        <td><strong>MinGW-w64</strong></td>
                        <td>开源编译器，支持 32/64 位编译，兼容 GCC 语法</td>
                        <td>开源项目、跨平台开发</td>
                    </tr>
                    <tr>
                        <td><strong>Windows SDK</strong></td>
                        <td>包含 Win32 API 的头文件、库文件与工具</td>
                        <td>所有 Win32 API 开发</td>
                    </tr>
                    <tr>
                        <td><strong>CMake</strong></td>
                        <td>跨平台构建系统</td>
                        <td>跨平台项目、自动化构建</td>
                    </tr>
                </table>
            </div>
            
            <div class="highlight">
                <h3>6.2 调试与诊断工具</h3>
                <p>Win32 API 开发的核心调试工具：</p>
                
                <table>
                    <tr>
                        <th>工具</th>
                        <th>用途</th>
                        <th>核心功能</th>
                    </tr>
                    <tr>
                        <td><strong>WinDbg</strong></td>
                        <td>内核级调试工具</td>
                        <td>查看调用栈、内存dump分析、断点设置</td>
                    </tr>
                    <tr>
                        <td><strong>Visual Studio Debugger</strong></td>
                        <td>集成开发环境中的调试工具</td>
                        <td>单步执行、变量监视、内存查看</td>
                    </tr>
                    <tr>
                        <td><strong>Process Explorer</strong></td>
                        <td>进程管理工具</td>
                        <td>查找句柄泄漏、DLL版本冲突、内存泄漏</td>
                    </tr>
                    <tr>
                        <td><strong>Process Monitor</strong></td>
                        <td>系统监控工具</td>
                        <td>记录进程的文件、注册表、网络操作</td>
                    </tr>
                </table>
            </div>
            
            <div class="highlight">
                <h3>6.3 跨版本兼容性</h3>
                <p>Win32 API 具有良好的向后兼容性，但需遵循以下最佳实践：</p>
                <ol>
                    <li><strong>检查 API 最低支持版本</strong>：使用 <code>WINVER</code> 或 <code>_WIN32_WINNT</code> 宏定义目标 Windows 版本</li>
                    <li><strong>使用 API 集（API Sets）</strong>：Windows 10 后引入的 API 集可自动映射到不同版本的系统 DLL</li>
                    <li><strong>动态加载高版本 API</strong>：对于仅在高版本 Windows 中存在的 API，需通过 <code>LoadLibrary</code> 与 <code>GetProcAddress</code> 动态加载</li>
                </ol>
                
                <div class="code-block">
                    <code>// 动态加载高版本 API 示例
#include &lt;windows.h&gt;

// 定义函数指针类型
typedef HRESULT (WINAPI* PFNDWMSETWINDOWATTRIBUTE)(HWND, DWORD, LPCVOID, DWORD);

int main() {
    // 动态加载 dwmapi.dll
    HMODULE hDwmApi = LoadLibrary(L"dwmapi.dll");
    
    // 获取 DwmSetWindowAttribute 函数地址
    PFNDWMSETWINDOWATTRIBUTE pfnDwmSetWindowAttribute = 
        (PFNDWMSETWINDOWATTRIBUTE)GetProcAddress(hDwmApi, 
                                                "DwmSetWindowAttribute");
    
    if (pfnDwmSetWindowAttribute != NULL) {
        // Windows 11 以上：设置窗口圆角
        HWND hwnd = GetConsoleWindow();
        DWORD dwAttribute = DWMWA_WINDOW_CORNER_PREFERENCE;
        DWORD dwValue = DWMWCP_ROUND;
        pfnDwmSetWindowAttribute(hwnd, dwAttribute, 
                                 &dwValue, sizeof(dwValue));
    }
    
    // 释放 DLL
    FreeLibrary(hDwmApi);
    return 0;
}</code>
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2>7. 总结与学习路径</h2>
            <p>Win32 API 是 Windows 开发的基石，掌握它不仅能深入理解 Windows 系统的底层逻辑，还能为高性能、系统级应用开发提供坚实的基础。</p>
            
            <div class="highlight">
                <h3>7.1 核心知识点总结</h3>
                <table>
                    <tr>
                        <th>模块</th>
                        <th>核心内容</th>
                    </tr>
                    <tr>
                        <td><strong>基础架构</strong></td>
                        <td>Windows 分层架构、Win32 API 与内核的交互逻辑、64 位兼容机制（WoW64）</td>
                    </tr>
                    <tr>
                        <td><strong>窗口与消息</strong></td>
                        <td>窗口类注册、<code>CreateWindowEx</code> 函数、消息循环、窗口过程</td>
                    </tr>
                    <tr>
                        <td><strong>GDI 绘图</strong></td>
                        <td>HDC 设备上下文、GDI 对象（画笔、画刷、字体）、绘图函数</td>
                    </tr>
                    <tr>
                        <td><strong>进程与线程</strong></td>
                        <td><code>CreateProcess</code>/<code>CreateThread</code> 函数、线程同步机制</td>
                    </tr>
                    <tr>
                        <td><strong>内存管理</strong></td>
                        <td>虚拟内存的「预留-提交」模型、<code>VirtualAlloc</code> 函数、大内存页优化</td>
                    </tr>
                    <tr>
                        <td><strong>高级特性</strong></td>
                        <td>UAC 权限提升、IOCP 高并发模型、Win32 API 与 WinUI 3 互操作</td>
                    </tr>
                </table>
            </div>
            
            <div class="highlight">
                <h3>7.2 学习路径建议</h3>
                <table>
                    <tr>
                        <th>阶段</th>
                        <th>学习目标</th>
                        <th>核心资源</th>
                    </tr>
                    <tr>
                        <td><strong>阶段 1：入门</strong></td>
                        <td>理解 Win32 API 的核心概念，编写第一个窗口程序</td>
                        <td>《Windows 程序设计》（Petzold）、Microsoft Learn 文档</td>
                    </tr>
                    <tr>
                        <td><strong>阶段 2：核心模块</strong></td>
                        <td>深入学习窗口管理、消息机制、GDI 绘图、进程/线程与内存管理</td>
                        <td>《Windows 核心编程》（Jeffrey Richter）、MSDN 官方文档</td>
                    </tr>
                    <tr>
                        <td><strong>阶段 3：高级特性</strong></td>
                        <td>学习 UAC 权限提升、大内存页、IOCP 等高级特性</td>
                        <td>《Windows 高性能编程》、GitHub 开源项目</td>
                    </tr>
                    <tr>
                        <td><strong>阶段 4：工程实践</strong></td>
                        <td>掌握开发工具链、调试技巧与跨版本兼容性，完成实际项目</td>
                        <td>个人项目、开源贡献、Microsoft Learn 工程实践文档</td>
                    </tr>
                </table>
            </div>
        </div>
        
        <footer>
            <p>Win32 API 全面解析与 C/C++ 代码实践指南</p>
            <p>内容涵盖 Windows 系统底层开发的核心知识与最佳实践</p>
        </footer>
    </div>
</body>
</html>