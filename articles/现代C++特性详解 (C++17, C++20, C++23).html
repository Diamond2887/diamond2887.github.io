<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>现代C++特性详解 (C++17, C++20, C++23)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 30px 0;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .version-tag {
            display: inline-block;
            background-color: #ff6b6b;
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-left: 10px;
            vertical-align: middle;
        }
        
        .cpp17 { background-color: #4CAF50; }
        .cpp20 { background-color: #2196F3; }
        .cpp23 { background-color: #9C27B0; }
        
        .chapter {
            background-color: white;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .chapter-title {
            background-color: #2c3e50;
            color: white;
            padding: 15px 20px;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }
        
        .chapter-title::after {
            content: '+';
            font-size: 1.8rem;
            transition: transform 0.3s;
        }
        
        .chapter.active .chapter-title::after {
            transform: rotate(45deg);
        }
        
        .chapter-content {
            display: none;
            padding: 0;
        }
        
        .chapter.active .chapter-content {
            display: block;
        }
        
        .section {
            padding: 20px;
            border-bottom: 1px solid #eee;
        }
        
        .section:last-child {
            border-bottom: none;
        }
        
        h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }
        
        h4 {
            color: #34495e;
            margin: 15px 0 10px;
            font-size: 1.1rem;
        }
        
        p {
            margin-bottom: 15px;
        }
        
        .code-block {
            background-color: #272822;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            white-space: pre-wrap;
        }
        
        .note {
            background-color: #e3f2fd;
            border-left: 4px solid #2196F3;
            padding: 10px 15px;
            margin: 15px 0;
        }
        
        .tip {
            background-color: #e8f5e9;
            border-left: 4px solid #4CAF50;
            padding: 10px 15px;
            margin: 15px 0;
        }
        
        .warning {
            background-color: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px 15px;
            margin: 15px 0;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .feature-card {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border-top: 4px solid #3498db;
        }
        
        .feature-card h4 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        @media (max-width: 768px) {
            .feature-grid {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .chapter-title {
                font-size: 1.3rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>现代C++特性详解</h1>
            <p class="subtitle">C++17, C++20, C++23 核心特性与最佳实践</p>
        </header>
        
        <div class="chapter active">
            <div class="chapter-title">引言</div>
            <div class="chapter-content">
                <div class="section">
                    <p>C++作为一门历史悠久的编程语言，自C++11以来经历了前所未有的快速发展。从2017年的C++17到2020年的C++20，再到2023年的C++23，每一个版本都带来了革命性的变化。本文将系统介绍这三个版本的核心新特性，重点分析协程、模块、概念、范围、三路比较运算符等关键功能，并深入探讨std::expected、std::format、std::print等实用组件的使用方法和最佳实践，帮助读者全面掌握现代C++的强大能力。</p>
                </div>
            </div>
        </div>
        
        <div class="chapter">
            <div class="chapter-title">一、C++17核心特性详解 <span class="version-tag cpp17">C++17</span></div>
            <div class="chapter-content">
                <div class="section">
                    <h3>1.1 语法层面的革命性改进</h3>
                    <p>C++17在语法层面引入了多项重要改进，这些特性不仅提高了代码的可读性，还显著增强了编译时的能力。</p>
                    
                    <h4>结构化绑定（Structured Bindings）</h4>
                    <p>是C++17最受欢迎的特性之一。它允许将复杂类型（如pair、tuple、数组、结构体）解构为独立变量。这项特性在处理多返回值和复杂数据结构时特别有用。</p>
                    <div class="code-block">// 示例：遍历std::map时直接解构键值对
std::map&lt;std::string, int&gt; myMap = {{"Alice", 25}, {"Bob", 30}};
for (const auto& [name, age] : myMap) {
    std::cout &lt;&lt; name &lt;&lt; ": " &lt;&lt; age &lt;&lt; "\n";
}</div>
                    
                    <h4>if constexpr</h4>
                    <p>是另一个革命性的特性，它允许在编译期根据常量表达式的结果选择性地启用或忽略特定代码分支。这在模板编程中特别有用，可以避免冗余的模板特化。</p>
                    <div class="code-block">// 示例：根据类型选择不同处理逻辑
template &lt;typename T&gt;
auto process(T val) {
    if constexpr (std::is_integral_v&lt;T&gt;) {
        return val + 1;  // 仅对整数类型生效
    } else {
        return val * 0.5;  // 对浮点类型生效
    }
}</div>
                    
                    <h4>折叠表达式（Fold Expressions）</h4>
                    <p>极大地简化了可变参数模板的递归展开。它支持四种折叠模式（左/右折叠，初始值可选），允许使用32个二元操作符对形参包中的参数进行计算。</p>
                    <div class="code-block">// 示例：可变参数求和
template &lt;typename... Args&gt;
auto sum(Args... args) {
    return (... + args);  // 左折叠，展开为 args1 + args2 + ...
}

// 示例：逻辑与折叠
template &lt;typename... Args&gt;
bool allTrue(Args... args) {
    return (... && args);  // 逻辑与折叠
}</div>
                    
                    <h4>类模板参数推导（CTAD）</h4>
                    <p>让程序员无需显式指定模板参数，编译器可以根据构造函数参数自动推导模板类型。</p>
                    <div class="code-block">// 示例：自动推导模板类型
std::vector vec = {1, 2, 3};    // 自动推导为 vector&lt;int&gt;
std::pair p(42, "hello");       // 推导为 pair&lt;int, const char*&gt;</div>
                    
                    <h4>constexpr lambda</h4>
                    <p>允许在编译时使用Lambda表达式，这为编译时编程提供了更大的灵活性。</p>
                    <div class="code-block">// 示例：编译时计算lambda表达式
constexpr auto square = [](int x) { return x * x; };
static_assert(square(5) == 25);  // 编译时计算</div>
                </div>
                
                <div class="section">
                    <h3>1.2 标准库的重大更新</h3>
                    <p>C++17对标准库进行了全面更新，引入了多个实用的新组件。</p>
                    
                    <h4>std::optional</h4>
                    <p>表示可能存在或不存在的值，避免了使用特殊值（如-1或nullptr）的陋习。它在处理可能失败的操作时特别有用。</p>
                    <div class="code-block">// 示例：使用std::optional处理可能失败的操作
std::optional&lt;int&gt; findById(int id) {
    if (id == 42) return 42;
    return std::nullopt;  // 无结果
}

auto result = findById(10);
if (result.has_value()) {
    std::cout &lt;&lt; *result &lt;&lt; "\n";  // 解引用
}</div>
                    
                    <h4>std::variant</h4>
                    <p>提供了类型安全的联合体，可以存储多种类型之一。配合std::visit使用，可以方便地访问variant中的值。</p>
                    <div class="code-block">// 示例：使用std::variant存储不同类型数据
std::variant&lt;int, std::string, double&gt; data;
data = "Hello";  // 存储字符串

std::visit([](auto&& arg) {
    std::cout &lt;&lt; arg &lt;&lt; "\n";  // 自动推导类型
}, data);</div>
                    
                    <h4>std::filesystem</h4>
                    <p>提供了跨平台的文件与目录操作能力。</p>
                    <div class="code-block">// 示例：文件系统操作
#include &lt;filesystem&gt;
namespace fs = std::filesystem;

fs::path dir = "docs";
if (!fs::exists(dir)) {
    fs::create_directory(dir);  // 创建目录
}

for (const auto& entry : fs::directory_iterator(dir)) {
    std::cout &lt;&lt; entry.path() &lt;&lt; "\n";  // 遍历文件
}</div>
                </div>
                
                <div class="section">
                    <h3>1.3 其他重要改进</h3>
                    <p>除了上述特性，C++17还带来了许多其他改进。</p>
                    
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>嵌套命名空间</h4>
                            <p>提供了更简洁的语法，允许使用<code>namespace A::B::C { ... }</code>代替传统的嵌套语法。</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>属性语法</h4>
                            <p>新增了<code>[[nodiscard]]</code>、<code>[[fallthrough]]</code>、<code>[[maybe_unused]]</code>等属性。</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>强制省略拷贝</h4>
                            <p>要求编译器必须省略临时对象的拷贝或移动操作，直接构造目标对象。这极大地提高了对象构造的效率。</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>UTF-8字符字面量</h4>
                            <p>为C++增加了对UTF-8编码的支持。</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="chapter">
            <div class="chapter-title">二、C++20核心特性详解 <span class="version-tag cpp20">C++20</span></div>
            <div class="chapter-content">
                <div class="section">
                    <h3>2.1 "四大天王"特性</h3>
                    <p>C++20被认为是继C++11之后最具革命性的版本，引入了被称为"四大天王"的核心特性：概念（Concepts）、模块（Modules）、协程（Coroutines）和范围（Ranges）。</p>
                    
                    <h4>概念（Concepts）</h4>
                    <p>是一种用于约束模板参数的机制，允许开发者定义接口并在编译时检查类型是否符合这些接口。概念将类型约束提升为一等公民，实现了声明式编程。</p>
                    <div class="code-block">// 示例：定义和使用概念
template&lt;typename T&gt;
concept Addable = requires(T a, T b) {
    { a + b } -> std::convertible_to&lt;T&gt;;
};

template&lt;Addable T&gt;
T add(T a, T b) {
    return a + b;
}</div>
                    
                    <h4>模块（Modules）</h4>
                    <p>是一种新的代码组织方式，旨在替代传统的头文件包含机制。模块可以减少编译时间，避免头文件互相包含的问题，使代码组织更清晰。</p>
                    <div class="code-block">// math.ixx - 模块接口文件
export module Math;

export int add(int a, int b) {
    return a + b;
}

// main.cpp
import Math;
import &lt;iostream&gt;;

int main() {
    std::cout &lt;&lt; add(3, 4) &lt;&lt; std::endl;  // 输出7
}</div>
                    
                    <h4>协程（Coroutines）</h4>
                    <p>是一种轻量级的并发编程机制，允许函数在执行过程中暂停并在适当的时候恢复执行。</p>
                    <div class="code-block">// 生成器示例
Generator&lt;int&gt; range(int start, int end) {
    for(int i = start; i &lt;= end; ++i) {
        co_yield i;  // 生成值并暂停
    }
}

// 异步操作示例
async_task&lt;void&gt; http_request() {
    auto data = co_await async_download(url);  // 挂起等待下载
    process(data);
}</div>
                    
                    <h4>范围（Ranges）</h4>
                    <p>库对传统容器和算法编程方式进行了重大改进，提供了统一的接口来操作各种可迭代对象。范围库支持强大的管道操作，使得代码更加简洁和易读。</p>
                    <div class="code-block">// 示例：使用范围库进行数据处理
std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

auto even_numbers = numbers | std::views::filter([](int n) { return n % 2 == 0; });
auto squared_numbers = even_numbers | std::views::transform([](int n) { return n * n; });

for (int n : squared_numbers) {
    std::cout &lt;&lt; n &lt;&lt; ' ';  // 输出: 4 16 36 64 100
}</div>
                </div>
                
                <div class="section">
                    <h3>2.2 其他重要新特性</h3>
                    <p>除了"四大天王"，C++20还引入了许多其他重要特性。</p>
                    
                    <h4>三路比较运算符（<=>）</h4>
                    <p>也称为太空船运算符，允许同时比较两个值并返回它们的相对顺序。</p>
                    <div class="code-block">// 示例：使用三路比较运算符
#include &lt;compare&gt;

struct Point {
    int x, y;
    auto operator&lt;=&gt;(const Point&) const = default;  // 默认比较生成
};

Point p1{1, 2}, p2{3, 4};
if (p1 &lt;=&gt; p2 == 0) {
    std::cout &lt;&lt; "p1 == p2" &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "p1 != p2" &lt;&lt; std::endl;
}</div>
                    
                    <h4>std::format</h4>
                    <p>提供了现代化、类型安全且高效的格式化功能，替代传统的printf和std::ostringstream。</p>
                    <div class="code-block">// 示例：使用std::format进行格式化
std::string result = std::format("Value: {:.2f}, Hex: {:x}, Binary: {:b}", 
                                 3.14159, 255, 42);</div>
                </div>
            </div>
        </div>
        
        <div class="chapter">
            <div class="chapter-title">三、C++23核心特性详解 <span class="version-tag cpp23">C++23</span></div>
            <div class="chapter-content">
                <div class="section">
                    <h3>3.1 语言核心改进</h3>
                    <p>C++23的主题是"完成C++20"，引入了多项重要的语言特性改进。</p>
                    
                    <h4>明确的对象参数（Deducing this）</h4>
                    <p>简化了CRTP（Curiously Recurring Template Pattern）等C++惯用法。现在可以在成员函数中显式声明this参数。</p>
                    <div class="code-block">// 示例：使用明确的对象参数
template&lt;typename T&gt;
class Base {
public:
    void print_value() {
        std::cout &lt;&lt; value &lt;&lt; std::endl;
    }
};

class Derived : public Base&lt;Derived&gt; {
public:
    int value = 42;
};</div>
                    
                    <h4>if consteval</h4>
                    <p>用于检测是否在常量上下文中执行，比<code>is_constant_evaluated()</code>函数更可靠。</p>
                    <div class="code-block">// 示例：使用if consteval
constexpr int compute(int x) {
    if consteval {
        return x * 2;  // 编译时执行
    } else {
        return x * 3;  // 运行时执行
    }
}</div>
                </div>
                
                <div class="section">
                    <h3>3.2 标准库新组件</h3>
                    <p>C++23对标准库进行了重要更新，引入了多个实用的新组件。</p>
                    
                    <h4>std::expected</h4>
                    <p>是C++23最重要的新特性之一，它为函数返回值提供了一种类型安全的错误处理机制。</p>
                    <div class="code-block">// 示例：使用std::expected进行错误处理
std::expected&lt;int, std::string&gt; safe_divide(int a, int b) {
    if (b == 0) {
        return std::unexpected("Division by zero!");
    }
    return a / b;
}

auto result = safe_divide(10, 3);
if (result) {
    std::cout &lt;&lt; "Result: " &lt;&lt; *result &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "Error: " &lt;&lt; result.error() &lt;&lt; std::endl;
}</div>
                    
                    <h4>std::print和std::println</h4>
                    <p>提供了格式化输出功能，其中std::println会自动添加换行符。</p>
                    <div class="code-block">// 示例：使用std::print和std::println
std::print("Binary: {:#b}, Octal: {:#o}, Hex: {:#x}\n", 42, 42, 42);
std::println("The answer is {}!", 42);</div>
                </div>
            </div>
        </div>
        
        <div class="chapter">
            <div class="chapter-title">四、重点特性深入分析</div>
            <div class="chapter-content">
                <div class="section">
                    <h3>4.1 协程（Coroutines）的深入剖析</h3>
                    <p>协程是C++20引入的最重要特性之一，它允许函数在执行过程中挂起并在适当的时候恢复执行。理解协程需要掌握三个核心概念：Promise类型、Awaitable（可等待对象）和std::coroutine_handle。</p>
                    
                    <div class="code-block">// 示例：实现一个简单的生成器协程
#include &lt;coroutine&gt;

struct Generator {
    struct promise_type {
        int current_value;
        
        std::suspend_always yield_value(int v) {
            current_value = v;
            return {};
        }
        
        Generator get_return_object() {
            return Generator{std::coroutine_handle&lt;promise_type&gt;::from_promise(*this)};
        }
        
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void return_void() {}
    };
    
    std::coroutine_handle&lt;promise_type&gt; handle;
    
    bool next() {
        handle.resume();
        return !handle.done();
    }
    
    int value() { return handle.promise().current_value; }
};

Generator counter() {
    for (int i = 0;; ++i) {
        co_yield i;  // 无限生成整数
    }
}

int main() {
    auto gen = counter();
    for (int i = 0; i &lt; 10; ++i) {
        gen.next();
        std::cout &lt;&lt; gen.value() &lt;&lt; ' ';  // 输出: 0 1 2 3 4 5 6 7 8 9
    }
}</div>
                </div>
                
                <div class="section">
                    <h3>4.2 模块（Modules）的实际应用</h3>
                    <p>模块彻底改变了C++的代码组织方式，带来了以下优势：编译时间大幅减少、更好的依赖管理、更好的封装性和避免宏污染。</p>
                    
                    <div class="code-block">// 模块接口文件（.ixx）
export module Math;

export int add(int a, int b);
export int subtract(int a, int b);

// 模块实现文件
module Math;

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

// 导入模块
import Math;
import &lt;iostream&gt;;

int main() {
    std::cout &lt;&lt; add(5, 3) &lt;&lt; std::endl;    // 输出8
    std::cout &lt;&lt; subtract(5, 3) &lt;&lt; std::endl; // 输出2
}</div>
                </div>
            </div>
        </div>
        
        <div class="chapter">
            <div class="chapter-title">五、std库新组件详解</div>
            <div class="chapter-content">
                <div class="section">
                    <h3>5.1 std::expected的错误处理模式</h3>
                    <p>std::expected是C++23引入的强大错误处理机制，它结合了std::optional和std::variant的优点，专门用于错误处理。</p>
                    
                    <div class="code-block">// 示例：std::expected的基本使用方法
std::expected&lt;int, std::string&gt; parse_number(const std::string& input) {
    try {
        return std::stoi(input);
    } catch (...) {
        return std::unexpected("Invalid number format");
    }
}

// 使用方式1：传统的if-else
auto result = parse_number("42");
if (result.has_value()) {
    std::cout &lt;&lt; "Parsed value: " &lt;&lt; result.value() &lt;&lt; std::endl;
} else {
    std::cout &lt;&lt; "Error: " &lt;&lt; result.error() &lt;&lt; std::endl;
}

// 使用方式2：operator bool()
if (result) {
    std::cout &lt;&lt; "Parsed value: " &lt;&lt; *result &lt;&lt; std::endl;  // 解引用
} else {
    std::cout &lt;&lt; "Error: " &lt;&lt; result.error() &lt;&lt; std::endl;
}</div>
                </div>
                
                <div class="section">
                    <h3>5.2 std::format的格式化能力</h3>
                    <p>std::format是C++20引入的现代化格式化库，基于fmtlib开发，具有类型安全、性能优异、语法直观和功能丰富的优势。</p>
                    
                    <div class="code-block">// 示例：std::format的基础用法
// 基础占位符
std::string s1 = std::format("{} + {} = {}", 2, 3, 5);  // "2 + 3 = 5"

// 带编号的占位符
std::string s2 = std::format("{1} {0} {2}", "a", "b", "c");  // "b a c"
std::string s3 = std::format("{0} → {0} → {1}", "X", "Y");  // "X → X → Y"

// 精度控制
std::string s4 = std::format("π ≈ {:.5f}", 3.1415926535);  // "π ≈ 3.14159"

// 对齐和填充
std::string s5 = std::format("{:*>10}", "Hi");      // "********Hi" (右对齐，宽度10，填充*)
std::string s6 = std::format("{:-^9}", "C++20");     // "--C++20--" (居中对齐，宽度9，填充-)
std::string s7 = std::format("{:8.2f}", 3.14159);    // "    3.14" (右对齐，宽度8，精度2)

// 进制转换
std::string s8 = std::format("Binary: {:#b}, Octal: {:#o}, Hex: {:#x}", 42, 42, 42);
// 输出: "Binary: 0b101010, Octal: 0o52, Hex: 0x2a"</div>
                </div>
            </div>
        </div>
        
        <div class="chapter">
            <div class="chapter-title">六、现代C++最佳实践</div>
            <div class="chapter-content">
                <div class="section">
                    <h3>6.1 设计原则</h3>
                    <p>现代C++的设计遵循以下核心原则：</p>
                    
                    <div class="feature-grid">
                        <div class="feature-card">
                            <h4>零开销抽象</h4>
                            <p>高级特性不应带来运行时开销。C++始终坚持这一原则，确保使用现代特性不会牺牲性能。</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>资源即对象（RAII）</h4>
                            <p>通过RAII（Resource Acquisition Is Initialization）管理资源生命周期。</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>类型安全</h4>
                            <p>减少未定义行为，增强编译时检查。</p>
                        </div>
                        
                        <div class="feature-card">
                            <h4>渐进式改进</h4>
                            <p>保持向后兼容，允许逐步采用新特性。</p>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h3>6.2 性能优化策略</h3>
                    <p>现代C++提供了多种性能优化策略：</p>
                    
                    <ul>
                        <li><strong>移动语义的使用</strong>：优先使用移动构造函数和移动赋值运算符</li>
                        <li><strong>避免不必要的拷贝</strong>：使用std::string_view代替std::string传递字符串</li>
                        <li><strong>使用合适的数据结构</strong>：根据场景选择最合适的数据结构</li>
                        <li><strong>算法优化</strong>：优先使用标准算法和并行算法</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div class="chapter">
            <div class="chapter-title">七、实际应用案例</div>
            <div class="chapter-content">
                <div class="section">
                    <h3>7.1 数据处理中的range应用</h3>
                    <p>使用range库处理复杂数据转换：</p>
                    
                    <div class="code-block">// 示例：使用range库进行复杂数据处理
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;ranges&gt;

int main() {
    std::vector&lt;int&gt; data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // 复杂的数据处理管道
    auto result = data
        | std::views::filter([](int x) { return x % 2 == 0; })  // 过滤偶数
        | std::views::transform([](int x) { return x * x; })   // 平方
        | std::views::take(3);                                  // 取前3个
    
    // 输出结果
    for (int x : result) {
        std::cout &lt;&lt; x &lt;&lt; ' ';  // 输出: 4 16 36
    }
    std::cout &lt;&lt; std::endl;
    
    return 0;
}</div>
                </div>
                
                <div class="section">
                    <h3>7.2 错误处理中的std::expected</h3>
                    <p>在文件处理系统中使用std::expected：</p>
                    
                    <div class="code-block">// 示例：使用std::expected进行文件处理错误处理
#include &lt;expected&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

std::expected&lt;std::string, std::string&gt; read_file(const std::string& path) {
    std::ifstream file(path);
    if (!file) {
        return std::unexpected("Failed to open file: " + path);
    }
    
    std::string content((std::istreambuf_iterator&lt;char&gt;(file)), 
                       std::istreambuf_iterator&lt;char&gt;());
    
    if (content.empty()) {
        return std::unexpected("File is empty: " + path);
    }
    
    return content;
}

int main() {
    auto content = read_file("data.txt");
    if (!content) {
        std::cerr &lt;&lt; "Error reading file: " &lt;&lt; content.error() &lt;&lt; std::endl;
        return 1;
    }
    
    std::cout &lt;&lt; "File content: " &lt;&lt; content.value() &lt;&lt; std::endl;
    return 0;
}</div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>内容由 AI 生成 | 现代C++特性详解 (C++17, C++20, C++23)</p>
        </footer>
    </div>

    <script>
        // 添加折叠面板交互功能
        document.querySelectorAll('.chapter-title').forEach(title => {
            title.addEventListener('click', () => {
                const chapter = title.parentElement;
                chapter.classList.toggle('active');
            });
        });
    </script>
</body>
</html>